[{"title":"基于 NumPy 实现无框架版本全连接神经网络","url":"/native_code-fcnn/","content":"\n\n 最近又扎进了深度学习的大坑里边，开始了一段新的学习过程。深度学习的东西相较于之前做后端研发而言代码较为简单，重在理解其中的算法逻辑和公式推导，因为有几个深度学习框架的存在，使得做出一个可用的算法模型变得异常简单，所以想着尝试用原生的方式实现目前比较主流的一些算法，第一个就从最初的全连接开始 \n\n 因为工作相关，我这里以图像分类为例，用的是 mnist 手写数字识别的数据，至于数据的获取这里就不写了，只介绍算法相关 \n 实现神经网络 \n 引入权重 \n 神经网络的本质就是将无法进行明确逻辑梳理的功能实现出来，实现的过程就是用大量符合目标结果的数据喂给机器学习，从而让程序拟合出解决这一类问题的能力 \n 既然是学习，那个我们让输入的数据怎么计算，最后才能符合最终的结果呢，这就涉及到了权重，权重与神经元是从生物学的角度换算得来的，对于一张图片（这里以图像为例，实际包含任何可输入的东西）人看到之后会对其主体作出判断，然后是色彩，细节，这些不同的判断与人们对这张图片最后形成的印象所产生的影响是不同的，由此就有了权重的划分，至于哪些判断是重要的，重要和不重要的权重又应该设置为多少那就是机器需要学习的了 \nclass TwoLayerNet:    def __init__(self, input_size, hidden_size, output_size, weight_init_std=0.01):        self.params = &#123;&#125;        self.params[&quot;W1&quot;] = weight_init_std * np.random.randn(input_size, hidden_size)        self.params[&quot;b1&quot;] = np.zeros(hidden_size)        self.params[&quot;W2&quot;] = weight_init_std * np.random.randn(hidden_size, output_size)        self.params[&quot;b2&quot;] = np.zeros(output_size)\n 依照代码逐行分析为什么要这么写 \n\n 首先看参数，input_size 对应图片输入量，任何图片都可以根据其像素，色域等分成一个多维的数据，为了方便处理，可以将数据压缩成一维，而这个一维数组的长度就是该张图片所有的信息量，也就是这里的 size\nhidden_size 是第二层的大小，对输入的信息进行的运算之后会将其传递给下一层的神经元 \noutput_size 是最终输入层的大小，因为这里是对数字的识别，那么输出的结果就可以看作数组 0∽90\\backsim90∽9 的集合 \nparams 代表所有的权重信息，当结合权重运算的结果大于某个值时才有其发挥的意义，这个值姑且称为 θ\\thetaθ，也就是下方的公式 \n\ny={0(w1x1+w2x2)⪕θ1(w1x1+w2x2)&gt;θ  ⟹  y={0(b+w1x1+w2x2)⪕01(b+w1x1+w2x2)&gt;0y = \\begin{cases}\n  0 (w_{1}x_{1} + w_{2}x_{2}) \\eqslantless \\theta \\\\\n  1 (w_{1}x_{1} + w_{2}x_{2}) &gt; \\theta\n\\end{cases}    \\implies    y = \\begin{cases}\n  0 (b + w_{1}x_{1} + w_{2}x_{2}) \\eqslantless 0 \\\\\n  1 (b + w_{1}x_{1} + w_{2}x_{2}) &gt; 0\n\\end{cases}\ny={0(w1​x1​+w2​x2​)⪕θ1(w1​x1​+w2​x2​)&gt;θ​⟹y={0(b+w1​x1​+w2​x2​)⪕01(b+w1​x1​+w2​x2​)&gt;0​\n 激活函数 \n 我们上方的公式已经可以支撑两层神经网络的训练了，但是对于其输出只有 0, 1 这显然无法起到对数据进行信息量传递的效果，或者说有效果，但是很少，所以需要对其进行其他处理，使其输出一些有价值且信息跳跃不会过大的值，这就引入了激活函数的概念，这里我是用最常见的 sigmoid()，同样输出层函数选用分类场景下最常见的 softmax()，其对应公式如下：\nSigmoid(x)=σ(x)=11+e−xSoftmax(xi)=exi∑j=1nexj\\text{Sigmoid}(x) = \\sigma(x) = \\frac{1}{1 + e^{-x}}\n\\qquad\n\\text{Softmax}(x_i) = \\frac{e^{x_i}}{\\sum_{j=1}^n e^{x_j}}\nSigmoid(x)=σ(x)=1+e−x1​Softmax(xi​)=∑j=1n​exj​exi​​\n 有了公式，代码就实现起来简单多了：\ndef sigmoid(x):    return 1 / (1 + np.exp(-x))def softmax(x):    x = x - np.max(x)    return np.exp(x) / np.sum(np.exp(x))\n 上边的 softmax() 函数中有一行在公式之前的计算，用数组 x 的每个元素减去了数组中的最大值，这其实是为了方式数组中各元素过大导致进行 exe^{x}ex 运算时结果超过计算机有效位数（4 或 8 字节）\n 同时考虑到实际学习中会进行批量数据的导入，下方把批量计算的代码也实现出来，批量无非就是对每一行单独进行计算 \ndef softmax(x):    if x.ndim == 2:        x = x.T        x = x - np.max(x, axis=0)        y = np.exp(x) / np.sum(np.exp(x), axis=0)        return y.T    # if x.ndim == 2:    # x = x - np.max(x, axis=1, keepdims=True)    # return np.exp(x) / np.sum(np.exp(x), axis=1, keepdims=True)    x = x - np.max(x)    return np.exp(x) / np.sum(np.exp(x))\n 将损失函数与权重计算结合起来，代码如下 \ndef perdict(self, x):    w1, w2 = self.params[&quot;W1&quot;], self.params[&quot;W2&quot;]    b1, b2 = self.params[&quot;b1&quot;], self.params[&quot;b2&quot;]    a1 = np.dot(x, w1) + b1    z1 = sigmoid(a1)    a2 = np.dot(z1, w2) + b2    y = softmax(a2)    return y\n 至此一个简单的神经网络就实现完成了，为了便于直观感受，我们可以对总量的一个准确度进行输出 \ndef accuracy(self, x, t):    y = self.perdict(x)    y = np.argmax(y, axis=1)    t = np.argmax(t, axis=1)    accuracy = np.sum(y == t) / float(x.shape[0])    return accuracy\n 损失函数 \n 以上只是一个神经网络的实现过程，好像并没有引入自我学习的概念，所谓学习也就是对权重和偏置的一个修改，使其处在一个合适的值，既可以拟合解决所有的学习数据，又具备相当的泛化能力 \n 那么应该对该权重值怎么进行改变呢，改变的首要条件就是得确定什么样的结果是好的，以这个结果为判断依据才有改变的意义，否则随意调整参数没有任何意思，由此又引入了损失函数的概念 \n 相较于准确度，损失函数有几个优点：\n\n 损失函数是连续的，每个结果的输出都可以用损失函数给出一个明确的差异，而准确度只能说明该结果是否正确，对权重变化不敏感 \n 同样损失函数表达当前结果与正确结果有多大的差异，准确度只能粗暴的将结果都认定为 100%，对于 [0.9,0.1],[0.51,0.49][0.9, 0.1], [0.51, 0.49][0.9,0.1],[0.51,0.49] 这两组数据，表现的信息和可信度就有明确的差异 \n 可微分，能够指明参数优化的方向 \n\n 这里选用交叉熵误差的作为计算本次的损失函数，公式如下：\nCross-Entropy=−1N∑i=1N∑k=1Cyi,klog⁡(y^i,k)\\text{Cross-Entropy} = -\\frac{1}{N} \\sum_{i=1}^N \\sum_{k=1}^C y_{i,k} \\log(\\hat{y}_{i,k})\nCross-Entropy=−N1​i=1∑N​k=1∑C​yi,k​log(y^​i,k​)\n 直接看代码实现，便于理解：\ndef cross_entropy_error(y, t):    if y.ndim == 1:        t = t.reshape(1, t.size)        y = y.reshape(1, y.size)    if t.size == y.size:        t = t.argmax(axis=1)    batch_size = y.shape[0]    return -np.sum(np.log(y[np.arange(batch_size), t] + 1e-7)) / batch_size\n 几个注意点：\n\n 不是批量训练时转换为个数为 111 的二维数组 \n 如果是 one-hot 形式，转换为类别索引（也叫做稀疏标签）\n 计算时对结果加一个极小值 1e−71e-71e−7 防止除数为 000\n\n 梯度计算 \n 目前已经有了损失函数的概念，但是损失函数只是告诉当前训练是好是坏，作为学习依据进行使用，那么有了依据，应该怎么调整权重值，这自然而然就引入了导数的概念 \n 对函数 f(x)=y=x2f(x)=y=x^{2}f(x)=y=x2 进行求导，得到 f′(x)=dydx=2xf&#x27;(x)=\\frac{dy}{dx}=2xf′(x)=dxdy​=2x，其中 x=2x=2x=2 时的值为 444 这里的 444 不仅是看作为结果更是还能看作当 x=2x=2x=2 时其沿着 xxx 坐标增大时（导数值为正数为增大，负数为减少）对应的 yyy 值变大 \n 想象一下这一个巨简单的神经网络损失函数，其只有一个权重值 xxx，那么是否就可以根据导数进行数值的更新，只是对于损失函数而言取负数，这里对导数添加负号即可，每次移动的量尽量小，以免错过最低点，当到达最低点时 yyy 的值最小，也就是损失为 000 达到一个绝对高的准确率（这是最简单的实现理解，并不严谨）\n 将以上函数规模扩大，那么这时计算的所有偏导数值也就是梯度就指明了学习的方向，其导数与梯度公式如下：\nf′(x)=lim⁡h→0f(x+h)−f(x)h∇WL=∂L∂W=[∂L∂W11∂L∂W12⋯∂L∂W1n∂L∂W21∂L∂W22⋯∂L∂W2n⋮⋮⋱⋮∂L∂Wm1∂L∂Wm2⋯∂L∂Wmn]f&#x27;(x) = \\lim_{h \\to 0} \\frac{f(x + h) - f(x)}{h}\n\\qquad\n\\nabla_W L = \\frac{\\partial L}{\\partial W} = \n\\begin{bmatrix}\n\\frac{\\partial L}{\\partial W_{11}} &amp; \\frac{\\partial L}{\\partial W_{12}} &amp; \\cdots &amp; \\frac{\\partial L}{\\partial W_{1n}} \\\\ \n\\frac{\\partial L}{\\partial W_{21}} &amp; \\frac{\\partial L}{\\partial W_{22}} &amp; \\cdots &amp; \\frac{\\partial L}{\\partial W_{2n}} \\\\ \n\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ \n\\frac{\\partial L}{\\partial W_{m1}} &amp; \\frac{\\partial L}{\\partial W_{m2}} &amp; \\cdots &amp; \\frac{\\partial L}{\\partial W_{mn}}\n\\end{bmatrix}\nf′(x)=h→0lim​hf(x+h)−f(x)​∇W​L=∂W∂L​=⎣⎢⎢⎢⎢⎡​∂W11​∂L​∂W21​∂L​⋮∂Wm1​∂L​​∂W12​∂L​∂W22​∂L​⋮∂Wm2​∂L​​⋯⋯⋱⋯​∂W1n​∂L​∂W2n​∂L​⋮∂Wmn​∂L​​⎦⎥⎥⎥⎥⎤​\n 当然我们的权重不可能只有一个，所以这里直接使用梯度，以下为代码实现的经典方式，也就是中心差分法，具体实现逻辑如下：\n\n 对输入数组 x 的每个元素进行正向和反向的微小变化（变化量为 h），然后计算这些变化导致的函数值差值，最后将差值除以 2*h 得到近似的梯度值 \n\ndef _numerical_gradient_no_batch(f, x):    h = 1e-4  # 0.0001    grad = np.zeros_like(x)    for idx in range(x.size):        tmp_val = x[idx]        # 计算正向步长的偏导数         x[idx] = float(tmp_val) + h        fxh1 = f(x)        # 计算反向步长的偏导数         x[idx] = tmp_val - h        fxh2 = f(x)        grad[idx] = (fxh1 - fxh2) / (2 * h)        x[idx] = tmp_val    return grad\n 注意以上代码只是计算一维数组的方式，多维参数使用遍历调用的方式进行实现 \n 反向传播 \n 其实以上就已经能够进行神经网络的基础训练了，但在实际训练过程中会发现他有些过于缓慢了，主要是在计算每个参数的梯度值时需要进行大量的计算，而随着神经网络层级的加深，其对应的计算量也成指数级增加，由此便引入了反向传播法进行梯度的计算 \n\n 反向传播可能带来训练上的一些缺陷，比如梯度不准确（梯度消失或爆炸），学习率选择导致训练不稳定或者收敛过慢，但我们这里只关注反向传播的推导过程和具体实现 \n\n 链式法则 \n 链式法则是反向传播的基础，首先来看其关于复合函数的导数定义：如果某个函数由复合函数表示，那么该复合函数的导数可以由构成复合函数的各函数的导数的乘积进行表示 \n 对于复合函数 z=(x+y)2z=(x+y)^2z=(x+y)2 可看作：z=t2,t=x+yz=t^2, t=x+yz=t2,t=x+y，那么根据复合函数的定义其导数如下：\n∂z∂x=∂z∂t∂t∂x=2t⋅1=2(x+y)\\frac{\\partial z}{\\partial x}=\\frac{\\partial z}{\\partial t}\\frac{\\partial t}{\\partial x}=2t \\cdot 1=2(x+y)\n∂x∂z​=∂t∂z​∂x∂t​=2t⋅1=2(x+y)\n 性质很简单，其实就是把 ∂t{\\partial t}∂t 互相约掉 \n 反向传播实现 \n 以 sigmoid 函数及其链式的公式作为示例 \ny=11+exp(−x)y=\\frac{1}{1+exp(-x)}\ny=1+exp(−x)1​\nxxx 与 −1-1−1 进行相乘然后进行 expexpexp 运算，之后 +1+1+1 然后 1/1/1/\n 然后以反向的方式来看，（反向的起始值表示为 ∂L∂y\\frac{\\partial L}{\\partial y}∂y∂L​）：\n\n/// 节点作为局部函数表示为 y=1/xy=1/xy=1/x，导数解析为 ∂y∂x=−1x2\\frac{\\partial y}{\\partial x}=-\\frac{1}{x^2}∂x∂y​=−x21​，由于 yyy 是已知的，可以简单表示为 ∂y∂x=−y2\\frac{\\partial y}{\\partial x}=-y^2∂x∂y​=−y2。在反向传播时会将上游的值乘以该导数往前传递，结果变为 −∂L∂yy2-\\frac{\\partial L}{\\partial y}y^2−∂y∂L​y2\n 加法的传递不需要改变内容，结果仍为 −∂L∂yy2-\\frac{\\partial L}{\\partial y}y^2−∂y∂L​y2\nexpexpexp 的导数形式不变，用 exp(−x)exp(-x)exp(−x) 乘以上游数据，结果变为 −∂L∂yy2exp(−x)-\\frac{\\partial L}{\\partial y}y^2exp(-x)−∂y∂L​y2exp(−x)\n 然后是与 −1-1−1 相乘，反向传播的乘法需要进行反转，所以乘以 −1-1−1，结果变为 ∂L∂yy2exp(−x)\\frac{\\partial L}{\\partial y}y^2exp(-x)∂y∂L​y2exp(−x)\n\n 对该结果进行公式简化：\n∂L∂yy2exp⁡(−x)=∂L∂y1(1+exp⁡(−x))2exp⁡(−x)=∂L∂y11+exp⁡(−x)exp⁡(−x)1+exp⁡(−x)=∂L∂yy(1−y)\\frac{\\partial L}{\\partial y} y^2 \\exp(-x) = \\frac{\\partial L}{\\partial y} \\frac{1}{(1 + \\exp(-x))^2} \\exp(-x) \\\\\n= \\frac{\\partial L}{\\partial y} \\frac{1}{1 + \\exp(-x)} \\frac{\\exp(-x)}{1 + \\exp(-x)} \\\\\n= \\frac{\\partial L}{\\partial y} y(1 - y)\n∂y∂L​y2exp(−x)=∂y∂L​(1+exp(−x))21​exp(−x)=∂y∂L​1+exp(−x)1​1+exp(−x)exp(−x)​=∂y∂L​y(1−y)\n 代码实现如下：\nclass sigmoid_layer:    def __init__(self):        self.out = None    def forward(self, x):        out = 1 / (1 + np.exp(-x))        self.out = out        return out    def backward(self, dout):        if self.out is None:            raise Exception(&quot;Please forward first&quot;)        dx = dout * (1.0 - self.out) * self.out        return dx\n 总结 \n 以上就是全连接神经网络的简单实现和基本细节，具体代码可以看我的 github/DL-NumPy\n","categories":["深度学习"],"tags":["Python"]},{"title":"PAT 甲级 - 入门模拟","url":"/pat_level_a-get_start/","content":"\n\n当时准备 PAT 竞赛时候，买了本《算法笔记》，书中将题型进行分类，是我最系统的一次算法学习，对题型判断、解题思路都有了新的认知，本篇文章主要记录当时刷的入门模拟题，算是比较简单的算法题（有些都不能称之为算法），就当是打基础了\n包括分类：简单模拟 、 查找元素 、 图形输出 、 日期处理 、 进制转换 、 字符串处理\n\n 简单模拟\n 思想解释\n根据题目的要求去做即可，主要考察代码的编写能力\n 类型练习\n 1042\n题目：Shuffling Machine\nShuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines. Your task is to simulate a shuffling machine.\nThe machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:\nS1, S2, …, S13, H1, H2, …, H13, C1, C2, …, C13, D1, D2, …, D13, J1, J2\nwhere “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains a positive integer K (&lt;= 20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.\nOutput Specification:\nFor each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.\nSample Input:\n\n2\n36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47\n\nSample Output:\n\nS7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5\n\n思路： 用字符串不如使用整型数组直接进行循环调换，根据其编号输出对应的花色\n\n\n建立三个整型数组，分别用来存储初始顺序、洗牌后的顺序、洗牌规则\n\n\n每次洗牌就是将规则数组中的当前数字作为下标用来控制洗牌后的数组被赋值洗牌前的编号\n\n\n最后花色和数值的输出需要对编号进行 -1，这样是为了防止 13、26…这样的边界数字越界的情况，但输出数值时需要再 +1\n\n\n代码：\n#include &lt;cstdio&gt;int main()&#123;    int times;    scanf(&quot;%d&quot;, &amp;times); // 输入洗牌几次    int start[55], end[55], order[55];    for (int i = 1; i &lt; 55; i++)    &#123;        scanf(&quot;%d&quot;, &amp;order[i]); // 输入洗牌规则        start[i] = i;           // 初始化默认排序    &#125;    for (int i = 0; i &lt; times; i++)    &#123;        for (int j = 1; j &lt; 55; j++)        &#123;            end[order[j]] = start[j]; // 根据规则洗牌        &#125;        for (int k = 1; k &lt; 55; k++)        &#123;            start[k] = end[k]; // 将每次洗完的牌放到初始数组，为下一次洗牌做准备        &#125;    &#125;    char color[5] = &#123;&#x27;S&#x27;, &#x27;H&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;J&#x27;&#125;; // 字符花色数组    for (int i = 1; i &lt; 55; i++)    &#123;        end[i]--;        // 每次的序号都要自减，防止 13、26…这样的数字除和摸出 13 时得到的值不符合逻辑        printf(&quot;%c%d&quot;, color[end[i] / 13], end[i] % 13 + 1);        if (i != 54)        &#123; // 避免额外空格            printf(&quot; &quot;);        &#125;    &#125;    return 0;&#125;\n 1046\n题目：Shortest Distance\nThe task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains an integer N (in [3,10510^5105]), followed by N integer distances D1 D2 ⋯ DN, where Di is the distance between the i-th and the (i+1)-st exits, and DN is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (≤10410^4104), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 10710^7107.\nOutput Specification:\nFor each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits.\nSample Input:\n\n5 1 2 4 14 9\n3\n1 3\n2 5\n4 1\n\nSample Output:\n\n3\n10\n7\n\n思路： 实际上只有一条循环线路，只要求出单个方向（如顺时针）的值，用距离总和减去后获得反向距离，返回二者最小值\n\n\n创建一个距离数组 distance[]，其中distance[i] 中保存的是从 V1 点到 Vi+1 的距离，在输入时就将数组和距离总和记录下来减少复杂度\n\n\n输入的起点 begin 和终点 end 之间的顺时针距离 dis_left 为 dis_left=distance[end-1]-distance[begin-1]，需要判断 begin 与 end 的大小关系，始终保持小的在前\n\n\n代码：\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    vector&lt;int&gt; dis(n + 1); // 动态数组分配空间后所有的值为 0    int sum = 0, left, right;    for (int i = 1; i &lt;= n; i++)    &#123;        int temp;        scanf(&quot;%d&quot;, &amp;temp);        sum += temp;        dis[i] = sum; // 距离数组保存的是 V1 到 Vi 的顺时针距离    &#125;    int cnt;    scanf(&quot;%d&quot;, &amp;cnt); // 输入判断几对    for (int i = 0; i &lt; cnt; i++)    &#123;        scanf(&quot;%d %d&quot;, &amp;left, &amp;right);        if (left &gt; right) // 始终保持顺时针判断            swap(left, right);        int temp = dis[right - 1] - dis[left - 1];        printf(&quot;%d\\n&quot;, min(temp, sum - temp));    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1065\n题目：A+B and C (64bit)\nGiven three integers A, B and C in [−2632^{63}263, 2632^{63}263)，you are supposed to tell whether A+B&gt;C.\nInput Specification:\nThe first line of the input gives the positive number of test cases, T (≤10). Then T test cases follow, each consists of a single line containing three integers A, B and C, separated by single spaces.\nOutput Specification:\nFor each test case, output in one line Case #X: true if A+B&gt;C, or Case #X: false otherwise, where X is the case number (starting from 1).\nSample Input:\n\n3\n1 2 3\n2 3 4\n9223372036854775807 -9223372036854775808 0\n\nSample Output:\n\nCase #1: false\nCase #2: true\nCase #3: false\n\n思路： 数据类型过大用 long long 型进行存储，同时需要考虑溢出的情况（同为正值溢出必大于，同为负值溢出必小于）\n\n\n因为 A、B 的大小为 [-2^63, 2^63），用 long long 存储 A 和 B 的值，以及他们相加的值 sum\n\n\n如果 A &gt; 0, B &lt; 0 或者 A &lt; 0, B &gt; 0，sum 是不可能溢出的\n\n\n如果 A &gt; 0, B &gt; 0，sum 可能会溢出，sum 范围理应为 (0, 2^64 – 2]，溢出得到的结果应该是 [-2^63, -2] 是个负数，所以 sum &lt; 0 时候说明溢出了\n\n\n如果 A &lt; 0, B &lt; 0，sum 可能会溢出，同理，sum 溢出后结果是大于 0 的，所以 sum &gt; 0 说明溢出了\n\n\n代码：\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 0; i &lt; n; i++)    &#123;        long long a, b, c;        scanf(&quot;%lld %lld %lld&quot;, &amp;a, &amp;b, &amp;c);        long long sum = a + b;        if (a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; sum &lt; 0)        &#123; // 正溢出，结果必定大于 C            printf(&quot;Case #%d: true\\n&quot;, i + 1);        &#125;        else if (a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; sum &gt;= 0)        &#123; // 负溢出，两个负数相加而且溢出，必小于 C            printf(&quot;Case #%d: false\\n&quot;, i + 1);        &#125;        else if (sum &gt; c) // 无溢出，正常比较        &#123;            printf(&quot;Case #%d: true\\n&quot;, i + 1);        &#125;        else        &#123;            printf(&quot;Case #%d: false\\n&quot;, i + 1);        &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1002\n题目：A+B for Polynomials\nThis time, you are supposed to find A+B where A and B are two polynomials.\nInput Specification:\nEach input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:\n\nK N1 aN1 N2 aN2 … NK aNK\n\nwhere K is the number of nonzero terms in the polynomial, Ni and aNi (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，0≤NK&lt;⋯&lt; N2&lt;N1≤1000.\nOutput Specification:\nFor each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.\nSample Input:\n\n2 1 2.4 0 3.2\n2 2 1.5 1 0.5\n\nSample Output:\n\n3 2 1.5 1 2.9 0 3.2\n\n思路： 使用浮点数组用指数作为下标，存储系数的值，只要指数相同就为同一项，系数直接相加即可\n\n\n数组长度为指数的最大值 1000，poly[i] = j表示指数 i 的系数为 j，接收 exponent 和 coefficient 输入的同时将对应指数的系数加入到 poly 数组中，所有非零系数的个数，然后从前往后输出所有系数不为 0 的指数和系数\n\n\n注意输出格式和输出的精度\n\n\n代码：\n#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;using namespace std;int main()&#123;    vector&lt;double&gt; coef(1001, 0); // 根据数据规模，创建浮点数组存储系数    int cnt = 0;                  // 判断最后有多少项    int m, n;                     // 获取每行有多少项    scanf(&quot;%d&quot;, &amp;m);    for (int j = 0; j &lt; m; j++)    &#123;        int e_temp;        double c_temp;        scanf(&quot;%d %lf&quot;, &amp;e_temp, &amp;c_temp); // 根据项数输入指数和系数        coef[e_temp] += c_temp;            // 用指数作为下标将系数相加    &#125;    scanf(&quot;%d&quot;, &amp;n);    for (int j = 0; j &lt; n; j++)    &#123;        int e_temp;        double c_temp;        scanf(&quot;%d %lf&quot;, &amp;e_temp, &amp;c_temp);        coef[e_temp] += c_temp;    &#125;    for (int i = 0; i &lt; coef.size(); i++)    &#123;        if (coef[i])        &#123; // 记录所有不为 0 的项            cnt++;        &#125;    &#125;    printf(&quot;%d&quot;, cnt);    for (int i = 1000; i &gt;= 0; i--)    &#123;        if (coef[i])        &#123; // 不为 0 便输出指数和系数，注意空格和小数点为 1 位            printf(&quot; %d %.1f&quot;, i, coef[i]);        &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1009\n题目：Product of Polynomials\nThis time, you are supposed to find A×B where A and B are two polynomials.\nInput Specification:\nEach input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:\n\nK N1 aN1 N2 aN2 … NK aNK\n\nwhere K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, ⋯, K) are the exponents and coefficients, respectively. It is given that 1≤K≤10, 0≤NK&lt;⋯&lt;N2&lt;N1≤1000.\nOutput Specification:\nFor each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place.\nSample Input:\n\n2 1 2.4 0 3.2\n2 2 1.5 1 0.5\n\nSample Output:\n\n3 3 3.6 2 6.0 1 1.6\n\n思路： 建立两个数组，一个保存第一行的多项式，一个在第二行读入时，直接循环第一个数组的内容进行处理存储\n\n\n因为是乘法，根据最大指数为 1000，那么乘积的最大指数就是 2000，所以 ans 数组的数据规模为 2001\n\n\n无需将两个多项式分别保存完再处理，在输入第二个多项式时直接循环与第一个多项式的每一项相乘即可（只算非零）\n\n\n代码：\n#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;using namespace std; int main()&#123;    vector&lt;double&gt; coef(1001, 0);    vector&lt;double&gt; ans(2001, 0); // 根据指数最大为 1000，相乘后最大的指数为 1000+1000    int cnt = 0;    int m, n;    scanf(&quot;%d&quot;, &amp;m);    for (int j = 0; j &lt; m; j++)    &#123;        int e_temp;        double c_temp;        scanf(&quot;%d %lf&quot;, &amp;e_temp, &amp;c_temp);        coef[e_temp] += c_temp;    &#125;    scanf(&quot;%d&quot;, &amp;n);    for (int j = 0; j &lt; n; j++)    &#123;        int e_temp;        double c_temp;        scanf(&quot;%d %lf&quot;, &amp;e_temp, &amp;c_temp);        for (int i = 0; i &lt; coef.size(); i++)        &#123; // 在第二行每输入一项，就与第一行的每项相乘，得到的值根据相同指数加到 ans 数组中            if (coef[i])            &#123;                ans[i + e_temp] += coef[i] * c_temp;            &#125;        &#125;    &#125;    for (int i = 0; i &lt; ans.size(); i++)    &#123;        if (ans[i])        &#123;            cnt++;        &#125;    &#125;    printf(&quot;%d&quot;, cnt);    for (int i = 2000; i &gt;= 0; i--)    &#123;        if (ans[i])        &#123;            printf(&quot; %d %.1f&quot;, i, ans[i]);        &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 查找元素\n 思想解释\n在一组给定的元素中查找目标元素，范围较小可直接遍历查找，或者使用某些数据类型自带的 find() 函数，查找最大最小值可以使用 [algorithm] 下的 max_elemen() 函数等\n 二分查找\n有些元素的数据范围较大，采用遍历消耗的时间难免过多，所以采用二分查找的方式能够用较小的时间复杂度来完成\n具体思路就是每次确定中值mid=(left+right)/2，用要查询的数 x 与 mid 进行比较，根据大小关系再与另一半进行比较，值得注意的是，有些数据范围实在是太大导致 left+right 的值就已经超过的 int 支持的数据范围，这时可以使用mid=left+(right-left)/2\n在 [algorithm] 下的模板函数为：binary_search(first,last,val)\n 类型练习\n 1011\n题目：World Cup Betting\nWith the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.\nChinese Football Lottery provided a “Triple Winning” game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results – namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner’s odd would be the product of the three odds times 65%.\nFor example, 3 games’ odds are given as the following:\n\nW    T     L\n1.1  2.5  1.7\n1.2  3.1  1.6\n4.1  1.2  1.1\n\nTo obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1×3.1×2.5×65%−1)×2=39.31 yuans (accurate up to 2 decimal places).\nInput Specification:\nEach input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L.\nOutput Specification:\nFor each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.\nSample Input:\n\n1.1 2.5 1.7\n1.2 3.1 1.6\n4.1 1.2 1.1\n\nSample Output:\n\nT T W 39.31\n\n思路： 每次输入时就与前一个值比较只获取最大值，利用输入时的顺序为下标输出字符，最好将每次最大值相乘，按公式输出\n代码：\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;int main()&#123;    char c[4] = &#123;&quot;WTL&quot;&#125;; // 还应存储一个 &#x27;\\0&#x27; 表示结束    double ans = 0.65;   // 答案初始为 0.65，无需输出时计算    for (int i = 0; i &lt; 3; i++)    &#123;        double maxvalue = 0.0;        int maxchar = 0;        for (int j = 0; j &lt; 3; j++)        &#123;            double temp;            scanf(&quot;%lf&quot;, &amp;temp);            if (maxvalue &lt;= temp)            &#123;                maxvalue = temp;                maxchar = j;            &#125;        &#125;        ans *= maxvalue;        printf(&quot;%c &quot;, c[maxchar]); // 输出符号    &#125;    printf(&quot;%.2f&quot;, (ans - 1) * 2);    system(&quot;pause&quot;);    return 0;&#125;\n 1006\n题目：Sign In and Sign Out\nAt the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.\nInput Specification:\nEach input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:\nID_number  Sign_in_time  Sign_out_time\nwhere times are given in the format HH: MM: SS , and ID_number is a string with no more than 15 characters.\nOutput Specification:\nFor each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.\nNote: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.\nSample Input:\n\n3\n\nCS301111 15:30:28 17:00:10\nSC3021234 08:00:00 11:25:25\nCS301133 21:45:00 21:58:40\nSample Output:\n\nSC3021234 CS301133\n\n思路： 将时间用 scanf() 读入转换为秒，最小的时间为开门人保存其 string 的 ID，最大为锁门人，因为是 string 型，用 iostream\n\n\n无需建立数组，最后只输出 ID，使用一个 string 型保存，其他用临时变量处理即可\n\n\n输入中的冒号符号和空格用 scanf 处理\n\n\n代码：\n#include &lt;iostream&gt;#include &lt;climits&gt;using namespace std; int main()&#123;    int n, max = INT_MIN, min = INT_MAX;    string unlock, lock;    scanf(&quot;%d&quot;, &amp;n);            // 读入人数    for (int i = 0; i &lt; n; i++) // 建立人数循环    &#123;        string Id;        cin &gt;&gt; Id; // 输入每个人的 ID        int h1, m1, s1, h2, m2, s2;        scanf(&quot;%d:%d:%d %d:%d:%d&quot;, &amp;h1, &amp;m1, &amp;s1, &amp;h2, &amp;m2, &amp;s2);        int in_temp = h1 * 3600 + m1 * 60 + s1; // 将所有的时间转换成秒        int out_temp = h2 * 3600 + m2 * 60 + s2;        if (min &gt; in_temp) // 最小的时间就是开锁人        &#123;            min = in_temp;            unlock = Id; // 保存 ID        &#125;        if (max &lt; out_temp) // 最大的时间就是锁门人        &#123;            max = out_temp;            lock = Id; // 保存 ID        &#125;    &#125;    cout &lt;&lt; unlock &lt;&lt; &quot; &quot; &lt;&lt; lock;    system(&quot;pause&quot;);    return 0;&#125; \n 1036\n题目：Boys vs Girls\nThis time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students.\nInput Specification:\nEach input file contains one test case. Each case contains a positive integer N, followed by N lines of student information. Each line contains a student’s name, gender, ID and grade, separated by a space, where name and ID are strings of no more than 10 characters with no space, gender is either F (female) or M (male), and grade is an integer between 0 and 100. It is guaranteed that all the grades are distinct.\nOutput Specification:\nFor each test case, output in 3 lines. The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade. The third line gives the difference gradeF−gradeM. If one such kind of student is missing, output Absent in the corresponding line, and output NA in the third line instead.\nSample Input 1:\n\n3\nJoe M Math990112 89\nMike M CS991301 100\nMary F EE990830 95\n\nSample Output 1:\n\nMary EE990830\nJoe Math990112\n6\n\nSample Input 2:\n\n1\nJean M AA980920 60\n\nSample Output 2:\n\nAbsent\nJean AA980920\nNA\n\n思路： 用 string 类型的 M 和 F 保存要求的学生的信息，F_max 和 M_min 处保存男生的最低分和女生的最高分\n\n\n输出姓名和编号时用一个字符串进行拼接即可\n\n\n如果成绩还为赋予的初始值说名没有符合条件的人，按条件进行更改输出\n\n\n最后输出的差要男女生的成绩同时被更改，判断大小关系（也可用绝对值输出）后输出\n\n\n代码：\n#include &lt;iostream&gt;using namespace std;int main()&#123;    int n, M_min = 101, F_max = -1; // 设置人数变量，同时根据范围确定最大最小值    string M, F;                    // 男女生输出的姓名和编号可以用一个字符串搞定    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++) // 根据人数构建循环处理每行数据    &#123;        string name_temp, Id_temp; // 临时字符串保存姓名和编号        char gender;        int grade;        cin &gt;&gt; name_temp &gt;&gt; gender &gt;&gt; Id_temp &gt;&gt; grade;        if (gender == &#x27;M&#x27; &amp;&amp; grade &lt; M_min) // 男生且成绩小于男生成绩的最小值        &#123;            M_min = grade;                 // 成绩覆盖            M = name_temp + &quot; &quot; + Id_temp; // 保存姓名和编号        &#125;        if (gender == &#x27;F&#x27; &amp;&amp; grade &gt; F_max) // 女生且成绩大于女生成绩的最大值        &#123;            F_max = grade;            F = name_temp + &quot; &quot; + Id_temp;        &#125;    &#125;    if (F_max != -1) // 如果成绩被改动说明有符合条件的人可以输出    &#123;        cout &lt;&lt; F &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;Absent\\n&quot;;    &#125;    if (M_min != 101)    &#123;        cout &lt;&lt; M &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;Absent\\n&quot;;    &#125;    if (M_min != 101 &amp;&amp; F_max != -1) // 如果男女生的成绩都有符合条件的人    &#123;        cout &lt;&lt; abs(M_min - F_max); // 用绝对值输出，防止大小颠倒    &#125;    else    &#123;        cout &lt;&lt; &quot;NA&quot;;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 图形输出\n 思想解释\n根据题目给出的规则输出图形，主要考察的是对规则的总结，主要的实现手段有两种\n\n\n根据规律直接进行输出\n\n\n根据规律对二维数组进行填充，然后直接输出整个二维数组，如杨辉三角形，注意不论形状为何，统一用行列的方式填入，用空格控制输出\n\n\n 类型练习\n 1031\n题目：Hello World for U\nGiven any string of N (≥5) characters, you are asked to form the characters into the shape of U . For example, helloworld can be printed as:\n\nh   d\ne    l\nl     r\nlowo\n\nThat is, the characters must be printed in the original order, starting top-down from the left vertical line with n1 characters, then left to right along the bottom line with n2 characters, and finally bottom-up along the vertical line with n3 characters. And more, we would like U to be as squared as possible – that is, it must be satisfied that:\nn1=n3=maxk∣k≤n2forall3≤n2≤Nwithn1+n2+n3−2=Nn1=n3=max {k | k≤n2 for all 3≤n2≤N} with n1+n2+n3−2=Nn1=n3=maxk∣k≤n2forall3≤n2≤Nwithn1+n2+n3−2=N\nInput Specification:\nEach input file contains one test case. Each case contains one string with no less than 5 and no more than 80 characters in a line. The string contains no white space.\nOutput Specification:\nFor each test case, print the input string in the shape of U as specified in the description.\nSample Input:\n\nhelloworld!\n\nSample Output:\n\nh      !\ne     d\nl       l\nlowor\n\n思路： 确定长和宽的值，根据规则直接输出或者填充到数组输出\n\n主要要求为：n1 == n3；n2 &gt;= n1；n1 为在满足上述条件的情况下的最大值\n根据条件 n=length+2 得出 n1 = n / 3，n2 = n / 3 + n % 3\n注意：字符数组的输入不要用 gets() 函数，可能造成编译无法通过的情况\n\n代码：\n#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;int main()&#123;    // 数组型    char str[81], map[30][30];     // 创建一个二维数组    memset(map, &#x27; &#x27;, sizeof(map)); // 全部初始化为空格    scanf(&quot;%s&quot;, str);    int length = strlen(str) + 2;    int row = length / 3;    int column = length - 2 * row;    for (int i = 0; i &lt; row - 1; i++)    &#123;        map[i][0] = str[i];        map[i][column - 1] = str[length - 3 - i];    &#125;    for (int i = 0; i &lt; column; i++)    &#123;        map[row - 1][i] = str[row - 1 + i];    &#125; // 对二维数组填充    for (int i = 0; i &lt; row; i++)    &#123;        for (int j = 0; j &lt; column; j++)        &#123;            printf(&quot;%c&quot;, map[i][j]);        &#125;        if (i != row - 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    printf(&quot;\\n&quot;);    // 直接输出型    int n = strlen(str);    int n1 = (n + 2) / 3, n3 = n1, n2 = (n + 2) - 2 * n1; // 确定 n1,n2,n3 的长度，n1 和 n3 一个就够    for (int i = 0; i &lt; n1 - 1; i++)    &#123; // 输出没有底层的所有        printf(&quot;%c&quot;, str[i]);        for (int j = 0; j &lt; n2 - 2; j++)        &#123;            printf(&quot; &quot;);        &#125;        printf(&quot;%c\\n&quot;, str[n - 1 - i]);    &#125;    for (int i = 0; i &lt; n2; i++)    &#123; // 输出底层        printf(&quot;%c&quot;, str[n1 - 1 + i]);    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1164\n题目：Good in C\nWhen your interviewer asks you to write “Hello World” using C, can you do as the following figure shows?\nInput Specification:\nEach input file contains one test case. For each case, the first part gives the 26 capital English letters A-Z, each in a 7×5 matrix of C’s and .'s. Then a sentence is given in a line, ended by a return. The sentence is formed by several words (no more than 10 continuous capital English letters each), and the words are separated by any characters other than capital English letters.\nIt is guaranteed that there is at least one word given.\nOutput Specification:\nFor each word, print the matrix form of each of its letters in a line, and the letters must be separated by exactly one column of space. There must be no extra space at the beginning or the end of the word.\nBetween two adjacent words, there must be a single empty line to separate them. There must be no extra line at the beginning or the end of the output.\nSample Input:\n..C...C.C.C...CCCCCCC...CCCCC.C...CCCCC.C...CCCCC..CCC.C...CC....C...C.CCC.CCCC.C...CCCCC.CCCCCC....CCCC.C....CCCCCC....CCCC.C....CCCC.C...CC....C.CCCC...CCCCC.C...CCCCCCC...CCCCCC..C..CCCCC....CC...C.CCC.C...CC..C.C.C..CC...C.C..C..C.C...CC....CCCCCC...CCC.CCC.C.CC...CCC..CC.C.CC..CCC...C.CCC.C...C.CCC.CCCC.C...CCCCC.C.....CCC.C...CC.C.CC..CC.CCC.CCCC.C...CCCCC.CC...C.C..C..C.C...C.CCC.C...CC.....CCC.....CC...C.CCC.CCCCC..C..C...C.CCC.C...C.C.C...C..C...CC.C.CCC.CCC...C.C.C...C...C.C.C...C.C.C...C..CCCCC....C...C...C...C...C....CCCCCHELLO~WORLD!\nSample Output:\nC... C CCCCC C.... C.... . CCC.C... C C.... C.... C.... C... CCCCCC CCCC. C.... C.... C... CC... C C.... C.... C.... C... CC... C CCCCC CCCCC CCCCC . CCC.C... C . CCC. CCCC. C.... CCCC.C... C C... C C... C C.... C... CC... C C... C CCCC. C.... C... CC. C. C C... C CC... C.... C... CCC. CC C... C C. C.. C.... C... CC... C C... C C.. C. C.... C... CC... C . CCC. C... C CCCCC CCCC.\n思路： 使用二维的字符串数组保存每个字母的七行，对目标单词不是大写字母的作为分割，将每一个单词的字母获取它的字母序号放入数组，对每个单词遍历输出每一行，使用标记记录是否有一个单词被输出，用来输出空行\n代码：\n#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;vector&gt;using namespace std;string let[26][7], str; // 保存图形样式，保存目标字符串vector&lt;int&gt; word;       // 保存每个符合条件的单词int main()&#123;    for (int i = 0; i &lt; 26; i++)    &#123;        for (int j = 0; j &lt; 7; j++)        &#123;            cin &gt;&gt; let[i][j];        &#125;    &#125;    cin.ignore(); // 目标字符串要获取整行，忽略上一个换行    getline(cin, str);    bool flag = false; // 标记是否有单词被输出    for (int i = 0; i &lt; str.length(); i++)    &#123;        if (isupper(str[i]) &amp;&amp; i == str.size() - 1) // 存在最后一个的情况        &#123;            word.push_back(str[i] - &#x27;A&#x27;);        &#125;        if (isupper(str[i]) &amp;&amp; i != str.size() - 1) // 用非大写字母或者结尾进行一次输出        &#123;            word.push_back(str[i] - &#x27;A&#x27;);        &#125;        else        &#123;            if (flag) // 判断之前是否有单词被输出            &#123;                cout &lt;&lt; endl                     &lt;&lt; endl;                flag = false;            &#125;            for (int j = 0; j &lt; 7; j++) // 每个单词输出 7 行            &#123;                for (int k = 0; k &lt; word.size(); k++) // 输出每个单词的每一行                &#123;                    if (k != 0) // 空格相隔                    &#123;                        cout &lt;&lt; &quot; &quot;;                    &#125;                    cout &lt;&lt; let[word[k]][j];                &#125;                if (j != 6) // 换行                &#123;                    cout &lt;&lt; endl;                &#125;            &#125;            word.clear(); // 清空保存数组进行下一次输出            flag = true;        &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 日期处理\n 思想解释\n主要解决的是平年和闰年造成的二月日期差异，还有大小月的不同，PAT 暂没有这样的试题\n 类型练习\n求日期差值：\n/*题目：以 6 位格式输入两个日期，求两个日期之间的天数，包括这两个日期（如果两个日期相邻那么就是两天）思路：书上是用循环模拟的方法写的，复杂度太高  先求出每个日期离开年过了多少天，如果年份相同，互减 +1 即可  年份不同，算出隔了多少年，在判断每年是闰年还是平年，得到相应的天数，最后减去较早年份已经过去的日子 +1*/#include &lt;iostream&gt;using namespace std; bool judgeYear(int year)&#123; // 判断是否闰年    return year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0);&#125;int countDate(int year, int month, int day)&#123; // 计算每个日期离开年过去的天数    int sum = 0;    switch (month)    &#123;    case 1:        sum = 0;        break;    case 2:        sum = 31;        break;    case 3:        sum = 59;        break;    case 4:        sum = 90;        break;    case 5:        sum = 120;        break;    case 6:        sum = 151;        break;    case 7:        sum = 181;        break;    case 8:        sum = 212;        break;    case 9:        sum = 243;        break;    case 10:        sum = 273;        break;    case 11:        sum = 304;        break;    case 12:        sum = 334;        break;    &#125;    sum += day;    if (judgeYear(year) &amp;&amp; month &gt; 2)    &#123;        sum++;    &#125;    return sum;&#125;int main()&#123;    int date1, date2;     cin &gt;&gt; date1 &gt;&gt; date2;     int year1, month1, day1;     int year2, month2, day2;     if (date1 &gt; date2)    &#123; // 始终让较早的日期在前        int t = date1;         date1 = date2;         date2 = t;     &#125;    year1 = date1 / 10000;     month1 = date1 % 10000 / 100;     day1 = date1 % 100;     year2 = date2 / 10000;     month2 = date2 % 10000 / 100;     day2 = date2 % 100;     // 获取每个日期的实际年月日    int difDay; // 记录相差天数    if (year1 == year2)    &#123; // 年份相同的情况        difDay = countDate(year2, month2, day2) - countDate(year1, month1, day1) + 1;     &#125;    else    &#123; // 年份不同        difDay = countDate(year2, month2, day2);         int difYear = year2 - year1;         while (difYear)        &#123; // 判断每一年的天数            judgeYear(year2 - difYear) ? difDay += 366 : difDay += 365;             difYear--;         &#125;        difDay -= countDate(year1, month1, day1) - 1; // 减去开始年份已经过去（在循环中也加上了）    &#125;    cout &lt;&lt; difDay &lt;&lt; endl;     system(&quot;pause&quot;);    return 0;&#125;\n 进制转换\n 思想解释\n主要是不同进制的输入输出，熟练使用 strtol() 函数和 _itoa() 函数\n 类型练习\n 1019\n题目：General Palindromic Number\nA number that will be the same when it is written forwards or backwards is known as a Palindromic Number. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers.\nAlthough palindromic numbers are most often considered in the decimal system, the concept of palindromicity can be applied to the natural numbers in any numeral system. Consider a number N&gt;0N&gt;0N&gt;0 in base b≥2b≥2b≥2, where it is written in standard notation with k+1k+1k+1 digits aia_iai​ as ∑i=0k(aibi)∑^k_{i=0}(a_ib^i)∑i=0k​(ai​bi). Here, as usual, 0≤ai&lt;b0≤a_i&lt;b0≤ai​&lt;b for all iii and aka_kak​ is nonzero. Then NNN is palindromic if and only if ai=ak−ia_i=a_{k−i}ai​=ak−i​ for all iii. Zero is written 0 in any base and is also palindromic by definition.\nGiven any positive decimal integer NNNand a base bbb, you are supposed to tell if NNNis a palindromic number in base bbb.\nInput Specification:\nEach input file contains one test case. Each case consists of two positive numbers NNNand b, where 0&lt;N≤1090&lt;N≤10^90&lt;N≤109 is the decimal number and 2≤b≤1092≤b≤10^92≤b≤109 is the base. The numbers are separated by a space.\nOutput Specification:\nFor each test case, first print in one line Yes if NNNis a palindromic number in base bbb, or No if not. Then in the next line, print NNN as the number in base bbbin the form “akak−1...a0a_k a_{k−1} ... a_0ak​ak−1​...a0​”. Notice that there must be no extra space at the end of output.\nSample Input 1:\n\n27 2\n\nSample Output 1:\n\nYes\n1 1 0 1 1\n\nSample Input 2:\n\n121 5\n\nSample Output 2:\n\nNo\n4 4 1\n\n思路： 构建一个数组，循环计算mod(N,k)，放到数组中，判断数组是否为回文即可\n\nwhile 循环的判断条件为 N!=0 或者 !(N&lt;k)采用第二种时还需把 N 的值放到数组作为最后一个余数，使用第一种\n\n代码：\n#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;using namespace std;int main()&#123;    vector&lt;int&gt; mod;    int N, k;    scanf(&quot;%d %d&quot;, &amp;N, &amp;k);    /*    while (!(N &lt; k)) // 相等时仍要继续计算，也可以使用 N!=0 作为判断条件    &#123;        mod.push_back(N % k);        N /= k;    &#125;    mod.push_back(N); // 将最后的 N 也放入数组    */    while (N)    &#123; // 更简洁的判断条件        mod.push_back(N % k);        N /= k;    &#125;    bool flag = true;    for (int i = 0; i &lt; mod.size() / 2; i++)    &#123; // 判读获取的余数数组是不是回文数        if (mod[i] != mod[mod.size() - 1 - i])        &#123;            flag = false;            break;        &#125;    &#125;    if (flag)    &#123;        printf(&quot;Yes\\n&quot;);    &#125;    else    &#123;        printf(&quot;No\\n&quot;);    &#125;    for (auto i = mod.end() - 1; i != mod.begin(); i--)    &#123; // 反向输出        printf(&quot;%d &quot;, *i);    &#125;    printf(&quot;%d&quot;, *mod.begin());    system(&quot;pause&quot;);    return 0;&#125;\n 1027\n题目：Colors in Mars\nPeople in Mars represent the colors in their computers in a similar way as the Earth people. That is, a color is represented by a 6-digit number, where the first 2 digits are for Red , the middle 2 digits for Green , and the last 2 digits for Blue . The only difference is that they use radix 13 (0-9 and A-C) instead of 16. Now given a color in three decimal numbers (each between 0 and 168), you are supposed to output their Mars RGB values.\nInput Specification:\nEach input file contains one test case which occupies a line containing the three decimal color values.\nOutput Specification:\nFor each test case you should output the Mars RGB value in the following format: first output # , then followed by a 6-digit number where all the English characters must be upper-cased. If a single color is only 1-digit long, you must print a 0 to its left.\nSample Input:\n\n15 43 71\n\nSample Output:\n\n#123456\n\n思路： 十三进制的数字包括 ABC，可以放到字符数组中，用下标的方式进行输出\n代码：\n#include &lt;iostream&gt;using namespace std; int main()&#123;    int t1, t2, t3;     char c[14] = &#123;&quot;0123456789ABC&quot;&#125;;     cin &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; t3;     cout &lt;&lt; &#x27;#&#x27;;     cout &lt;&lt; c[t1 / 13] &lt;&lt; c[t1 % 13];     cout &lt;&lt; c[t2 / 13] &lt;&lt; c[t2 % 13];     cout &lt;&lt; c[t3 / 13] &lt;&lt; c[t3 % 13];     system(&quot;pause&quot;);    return 0;&#125;\n 1058\n题目：A+B in Hogwarts\nIf you are a fan of Harry Potter, you would know the world of magic has its own currency system – as Hagrid explained it to Harry, “Seventeen silver Sickles to a Galleon and twenty-nine Knuts to a Sickle, it’s easy enough.” Your job is to write a program to compute A+B where A and B are given in the standard form of Galleon.Sickle.Knut (Galleon is an integer in [0,10710^7107], Sickle is an integer in [0,17), and Knut is an integer in [0, 29)).\nInput Specification:\nEach input file contains one test case which occupies a line with A and B in the standard form, separated by one space.\nOutput Specification:\nFor each test case you should output the sum of A and B in one line, with the same format as the input.\nSample Input:\n\n3.2.1 10.16.27\n\nSample Output:\n\n14.1.28\n\n思路： 处理读取后，按位相加，小位留余\n代码：\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;int main()&#123;    int a1, b1, c1, a2, b2, c2, a, b, c;    scanf(&quot;%d.%d.%d %d.%d.%d&quot;, &amp;a1, &amp;b1, &amp;c1, &amp;a2, &amp;b2, &amp;c2);    c = c1 + c2; // 由小位到大位，按位相加，小位留余    b = b1 + b2 + c / 29;    c = c % 29;    a = a1 + a2 + b / 17;    b = b % 17;    printf(&quot;%d.%d.%d&quot;, a, b, c);    /*    int yuan, jiao, fen;    scanf(&quot;%d.%d.%d&quot;, &amp;yuan, &amp;jiao, &amp;fen);    int t_y, t_j, t_f;    scanf(&quot;%d.%d.%d&quot;, &amp;t_y, &amp;t_j, &amp;t_f);    yuan += t_y;    jiao += t_j;    fen += t_f;    if (!(fen &lt; 29))    &#123;        jiao++;        fen -= 29;    &#125;    if (!(jiao &lt; 17))    &#123;        yuan++;        jiao -= 17;    &#125;    printf(&quot;%d.%d.%d&quot;, yuan, jiao, fen);    */    system(&quot;pause&quot;);    return 0;&#125;\n 字符串处理\n 思想解释\n注意细节和输出格式，字符可以直接进行加减，输出需要补零可以用 %02d\n字符数组表示数字时使用 -'0' （如果时字母使用 -'A' ) 的方式，含义是使用 ASCII 码求差值\n 类型练习\n 1061\n题目：Dating\nSherlock Holmes received a note with some strange strings: Let's date! 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm . It took him only a minute to figure out that those strange strings are actually referring to the coded time Thursday 14:04 – since the first common capital English letter (case sensitive) shared by the first two strings is the 4th capital letter D , representing the 4th day in a week; the second common character is the 5th capital letter E , representing the 14th hour (hence the hours from 0 to 23 in a day are represented by the numbers from 0 to 9 and the capital letters from A to N , respectively); and the English letter shared by the last two strings is s at the 4th position, representing the 4th minute. Now given two pairs of strings, you are supposed to help Sherlock decode the dating time.\nInput Specification:\nEach input file contains one test case. Each case gives 4 non-empty strings of no more than 60 characters without white space in 4 lines.\nOutput Specification:\nFor each test case, print the decoded time in one line, in the format DAY HH: MM , where DAY is a 3-character abbreviation for the days in a week – that is, MON for Monday, TUE for Tuesday, WED for Wednesday, THU for Thursday, FRI for Friday, SAT for Saturday, and SUN for Sunday. It is guaranteed that the result is unique for each case.\nSample Input:\n\n3485djDkxh4hhGE\n2984akDfkkkkggEdsb\ns&amp;hgsfdk\nd&amp;Hyscvnm\n\nSample Output:\n\nTHU 14:04\n\n思路： 按照题目所给的方法找到相等的字符后判断即可，如果输出的时间不足 2 位数要在前面添 0，即用 %02d 输出\n\n\n因为在一对字符串的同一位置出现的相同字符才符合条件，使用一个外部循环条件，减少循环次数，方便操作\n\n\n符合条件的同时还需判断是否符合逻辑条件，如：星期的字母不会超过 G、小时可以是 N 之前的字母也可以是数字\n\n\n对星期的输出可以把每一日的代表字符串放到数组中，通过当前字符减去 A 的值作为下标\n\n\n小时需要根据数字还是字母的类型进行不同的操作，如果是字母减去 A 后还应 +10\n\n\n代码：\n#include &lt;iostream&gt;#include &lt;cctype&gt;using namespace std; int main()&#123;    string a, b, c, d;     cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; // 输入字符串    char time[2]; // 记录星期和小时    int i = 0, j = 0; // 控制字符串遍历，减少循环次数    int m; // 记录分钟    while (i &lt; a.length() &amp;&amp; i &lt; a.length()) // 同时出现才算符合条件    &#123;        if (a[i] == b[i] &amp;&amp; (a[i] &gt;= &#x27;A&#x27; &amp;&amp; a[i] &lt;= &#x27;G&#x27;)) // 星期字母不会超过 G        &#123;            time[0] = a[i];             break; // 保留字符，跳出循环        &#125;        i++;     &#125;    i++;     while (i &lt; a.length() &amp;&amp; i &lt; a.length())    &#123;        if (a[i] == b[i] &amp;&amp; ((a[i] &gt;= &#x27;A&#x27; &amp;&amp; a[i] &lt;= &#x27;N&#x27;) || isdigit(a[i]))) // 数字或者 N 之前的字符        &#123;            time[1] = a[i];             break; // 保留并跳出        &#125;        i++;     &#125;    while (j &lt; c.length() &amp;&amp; j &lt; d.length())    &#123;        if (c[j] == d[j] &amp;&amp; isalpha(c[j])) // 分钟必须时字母        &#123;            m = j; // 只需保存位置            break;         &#125;        j++;     &#125;    string week[7] = &#123;&quot;MON &quot;, &quot;TUE &quot;, &quot;WED &quot;, &quot;THU &quot;, &quot;FRI &quot;, &quot;SAT &quot;, &quot;SUN &quot;&#125;;     printf(&quot;%s&quot;, week[time[0] - &#x27;A&#x27;].c_str()); // 注意输出格式，转换为只读指针    int h = isdigit(time[1]) ? time[1] - &#x27;0&#x27; : time[1] - &#x27;A&#x27; + 10; //0 也是字符型必须有单引号    printf(&quot;%02d:%02d&quot;, h, m); // 输出两位不足补零    system(&quot;pause&quot;);    return 0;&#125;\n 1073\n题目：Scientific Notation\nScientific notation is the way that scientists easily handle very large numbers or very small numbers. The notation matches the regular expression [±][1-9].[0-9]+E[±][0-9]+ which means that the integer portion has exactly one digit, there is at least one digit in the fractional portion, and the number and its exponent’s signs are always provided even when they are positive.\nNow given a real number A in scientific notation, you are supposed to print A in the conventional notation while keeping all the significant figures.\nInput Specification:\nEach input contains one test case. For each case, there is one line containing the real number A in scientific notation. The number is no more than 9999 bytes in length and the exponent’s absolute value is no more than 9999.\nOutput Specification:\nFor each test case, print in one line the input number A in the conventional notation, with all the significant figures kept, including trailing zeros.\nSample Input 1:\n\n+1.23400E-03\n\nSample Output 1:\n\n0.00123400\n\nSample Input 2:\n\n-1.2E+10\n\nSample Output 2:\n\n-12000000000\n\n思路： 将底数和指数分别作为字符串和整数进行保存，然后根据符号和指数位分情况判断\n\n\n先判断字符串的第一位是否为符号，如果是转换数必然是负数，先输出一个负号\n\n\n如果指数为负数，那么转换数是小数，直接输出&quot;0.&quot;，然后输出指数 -1 个 0，再将底数子串去小数点输出\n\n\n指数为正数，转换数是一个整数，先输出底数子串的第一位，略过小数点，同时判断输出越界和是否超过指数的大小\n\n\n如果子串已经全部输出，将指数的剩余大小补 0\n\n\n指数到达子串未全部输出，输出小数点后继续输出子串\n\n\n代码：\n#include &lt;iostream&gt;using namespace std;int main()&#123;    string str;    cin &gt;&gt; str;    int index = 0;    while (str[index] != &#x27;E&#x27;)    &#123;        index++;    &#125;    string f_str = str.substr(1, index - 1); // 从 &#x27;E&#x27; 进行分割，将指数前的字符去掉符号放到字符子串中    int e = stoi(str.substr(index + 1));     // 正负号也会进行判断    if (str[0] == &#x27;-&#x27;)                       // 如果是一个负数，直接输出符号    &#123;        cout &lt;&lt; &#x27;-&#x27;;    &#125;    if (e &lt; 0) // 如果指数是负数，说明结果是一个小数    &#123;        cout &lt;&lt; &quot;0.&quot;;        for (int i = 0; i &lt; abs(e) - 1; i++)        &#123;            cout &lt;&lt; &#x27;0&#x27;;        &#125;        for (int j = 0; j &lt; f_str.length(); j++)        &#123;            if (f_str[j] != &#x27;.&#x27;)            &#123;                cout &lt;&lt; f_str[j];            &#125;        &#125;    &#125;    else // 如果是正数    &#123;        cout &lt;&lt; f_str[0]; // 先输出小数点之前的一位        int j, cnt;        for (j = 2, cnt = 0; j &lt; f_str.length() &amp;&amp; cnt &lt; e; j++, cnt++)        &#123; // 略过小数点输出，同时判断长度并构造一个计数不超过指数            cout &lt;&lt; f_str[j];        &#125;        if (j == f_str.length()) // 如果字符串全部输出，说明未到指数，后面补零        &#123;            for (int k = 0; k &lt; e - cnt; k++)            &#123;                cout &lt;&lt; &#x27;0&#x27;;            &#125;        &#125;        else // 指数到了指数未到，输出一个小数点继续输出        &#123;            cout &lt;&lt; &#x27;.&#x27;;            for (j; j &lt; f_str.length(); j++)            &#123;                cout &lt;&lt; f_str[j];            &#125;        &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1001\n题目：A+B Format\nCalculate a+ba+ba+b and output the sum in standard format ——that is, the digits must be separated into groups of three by commas (unless there are less than four digits).\nInput Specification:\nEach input file contains one test case. Each case contains a pair of integers a and b where −106≤a,b≤106−10^6≤a, b≤10^6−106≤a,b≤106. The numbers are separated by a space.\nOutput Specification:\nFor each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.\nSample Input:\n\n-1000000  9\n\nSample Output:\n\n-999, 991\n\n思路： 将和值转换为字符串，通过下标判断逗号的输出\n\n\n判断条件可以从右往左看，当三位时输出一个逗号，也就是字符串的长度 mod3 的位置，在从左往右看，下标 i 从 0 开始，如果 (i + 1) % 3 == len % 3 成立就输出逗号，注意最后一位不输出\n\n\n第一位输出的可能是一个负号，如果是负号就直接 continue 进入下一次循环，无需判断\n\n\n代码：\n#include &lt;iostream&gt;using namespace std; int main()&#123;    int a, b;     cin &gt;&gt; a &gt;&gt; b;     string str = to_string(a + b);     int len = str.length();     for (int i = 0; i &lt; len; i++)    &#123;        cout &lt;&lt; str[i];         if (str[i] == &#x27;-&#x27;)        &#123;            continue; // 直接进入下一次循环，防止负号后出现 comma 的情况        &#125;        if ((i + 1) % 3 == len % 3 &amp;&amp; i + 1 != len)        &#123;            cout &lt;&lt; &#x27;, &#x27;;         &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1004\n题目：Spell It Right\nGiven a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.\nInput Specification:\nEach input file contains one test case. Each case occupies one line which contains an N (≤10100).\nOutput Specification:\nFor each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.\nSample Input:\n\n12345\n\nSample Output:\n\none five\n\n思路： 使用字符串输入，利用每个字符数组 -'0' 的方式求和，将 sum 转为字符数组，用其实际数字作下标输出英文数字的字符串数组\n代码：\n#include &lt;iostream&gt;using namespace std;int main()&#123;    string a;    cin &gt;&gt; a;    int sum = 0;    for (int i = 0; i &lt; a.length(); i++)    &#123;        sum += a[i] - &#x27;0&#x27;;// 将每一位相加（不 -0 计算的是数字存储的 ASCII 码）    &#125;    string s = to_string(sum);    string digit[10] = &#123;&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;&#125;;    // 将每个数字的读法放到数组中    cout &lt;&lt; digit[s[0] - &#x27;0&#x27;];    for (int i = 1; i &lt; s.length(); i++)    &#123;        cout &lt;&lt; &quot; &quot; &lt;&lt; digit[s[i] - &#x27;0&#x27;];    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1035\n题目：Password\nTo prepare for PAT, the judge sometimes has to generate random passwords for the users. The problem is that there are always some confusing passwords since it is hard to distinguish 1 (one) from l (L in lowercase), or 0 (zero) from O (o in uppercase). One solution is to replace 1 (one) by @ , 0 (zero) by % , l by L , and O by o . Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords.\nInput Specification:\nEach input file contains one test case. Each case contains a positive integer N (≤1000), followed by N lines of accounts. Each account consists of a user name and a password, both are strings of no more than 10 characters with no space.\nOutput Specification:\nFor each test case, first print the number M of accounts that have been modified, then print in the following M lines the modified accounts info, that is, the user names and the corresponding modified passwords. The accounts must be printed in the same order as they are read in. If no account is modified, print in one line There are N accounts and no account is modified where N is the total number of accounts. However, if N is one, you must print There is 1 account and no account is modified instead.\nSample Input 1:\n\n3\nTeam000002 Rlsp0dfa\nTeam000003 perfectpwd\nTeam000001 R1spOdfa\n\nSample Output 1:\n\n2\nTeam000002 RLsp%dfa\nTeam000001 R@spodfa\n\nSample Input 2:\n\n1\nteam110 abcdefg332\n\nSample Output 2:\n\nThere is 1 account and no account is modified\n\nSample Input 3:\n\n2\nteam110 abcdefg222\nteam220 abcdefg333\n\nSample Output 3:\n\nThere are 2 accounts and no account is modified\n\n思路： 循环进行判断，将符合条件的字符串放入字符数组，判断完分情况输出\n\n\n输入密码后循环判断每一个字符（switch()或if()），更改即可；同时设置一个变量进行判断是否被修改\n\n\n若修改放入动态数组，最后根据数组大小和 N 的值输出相应结果\n\n\n代码：\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; int main()&#123;    int n;     cin &gt;&gt; n;     vector&lt;string&gt; list;     for (int i = 0; i &lt; n; i++) // 建立人数循环    &#123;        string name, password;         cin &gt;&gt; name &gt;&gt; password;         int flag = 0;         for (int j = 0; j &lt; password.length(); j++)        &#123;            switch (password[j]) // 依次更换符合要求的值            &#123;            case &#x27;1&#x27;:                password[j] = &#x27;@&#x27;;                 flag = 1;                 break; // 这里的 break 不是跳出循环，而是不执行后面的判断            case &#x27;0&#x27;:                password[j] = &#x27;%&#x27;;                 flag = 1;                 break;             case &#x27;l&#x27;:                password[j] = &#x27;L&#x27;;                 flag = 1;                 break;             case &#x27;O&#x27;:                password[j] = &#x27;o&#x27;;                 flag = 1;                 break;             &#125;        &#125;        if (flag) // 被更改则放入数组        &#123;            string temp = name + &quot; &quot; + password;             list.push_back(temp);         &#125;    &#125;    if (list.size()) // 数组中有元素就输出被更改的元素    &#123;        cout &lt;&lt; list.size() &lt;&lt; endl;         for (int i = 0; i &lt; list.size(); i++)            cout &lt;&lt; list[i] &lt;&lt; endl;     &#125;    else if (n == 1)    &#123;        printf(&quot;There is 1 account and no account is modified&quot;);     &#125;    else    &#123;        printf(&quot;There are %d accounts and no account is modified&quot;, n);     &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1077\n题目：Kuchiguse\nThe Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speaker’s personality. Such a preference is called “Kuchiguse” and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle “nyan~” is often used as a stereotype for characters with a cat-like personality:\n\n\nItai nyan~ (It hurts, nyan~)\n\n\nNinjin wa iyada nyan~ (I hate carrots, nyan~)\n\n\nNow given a few lines spoken by the same character, can you find her Kuchiguse?\nInput Specification:\nEach input file contains one test case. For each case, the first line is an integer N (2≤N≤100). Following are N file lines of 0~256 (inclusive) characters in length, each representing a character’s spoken line. The spoken lines are case sensitive.\nOutput Specification:\nFor each test case, print in one line the kuchiguse of the character, i.e., the longest common suffix of all N lines. If there is no such suffix, write nai.\nSample Input 1:\n\n3\nItai nyan~\nNinjin wa iyadanyan~\nuhhh nyan~\n\nSample Output 1:\n\nnyan~\n\nSample Input 2:\n\n3\nItai!\nNinjinnwaiyada T_T\nT_T\n\nSample Output 2:\n\nnai\n\n思路： 每输入一个字符串，就把它逆序过来再比较\n\n\n首先 ans = s；后来每输入的一个字符串，都和 ans 比较，如果后面不相同的就把它截取掉，根据 ans 的长度判断输出\n\n\n输入数字后再获取整行字符时会直接获取数字后的换行符，可以使用 getchar() 截取，或使用 scanf(&quot;%d``\\n``&quot;, &amp;n); 输入数字\n\n\n代码：\n#include &lt;iostream&gt;#include  [algorithm] using namespace std;int main()&#123;    int n;    cin &gt;&gt; n;    getchar(); // 截获、n，不然下面读取字符串时第一个读取的是换行符    string ans;    for (int i = 0; i &lt; n; i++)    &#123;        string s;        getline(cin, s);        reverse(s.begin(), s.end()); // 反转后方便判断        if (i == 0)        &#123;            ans = s;            continue;        &#125;        else        &#123;            if (s.length() &lt; ans.length()) // 判断最短的            &#123;                swap(ans, s);            &#125;            int minlen = min(s.length(), ans.length());            for (int j = 0; j &lt; minlen; j++)            &#123;                if (ans[j] != s[j])                &#123;                    ans = ans.substr(0, j); // 将公共子串截取出来                    break;                &#125;            &#125;        &#125;    &#125;    reverse(ans.begin(), ans.end()); // 再翻转回初始状态    if (ans.length() == 0)    &#123;        ans = &quot;nai&quot;;    &#125;    cout &lt;&lt; ans;    system(&quot;pause&quot;);    return 0;&#125;\n 1082\n题目：Read Number in Chinese\nGiven an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output Fu first if it is negative. For example, -123456789 is read as Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu . Note: zero (ling ) must be handled correctly according to the Chinese tradition. For example, 100800 is yi Shi Wan ling ba Bai .\nInput Specification:\nEach input file contains one test case, which gives an integer with no more than 9 digits.\nOutput Specification:\nFor each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line.\nSample Input 1:\n\n-123456789\n\nSample Output 1:\n\nFu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu\n\nSample Input 2:\n\n100800\n\nSample Output 2:\n\nyi Shi Wan ling ba Bai\n\n思路： 同时设置 left 和 right 两个坐标，按四位一节进行输出\n\n先构建数字单词和位数单词数组，用下标控制读出来\n使用两个下标，确保间隔不超过四，始终指向同一小节\n循环嵌套，每次输出一个小节，同时注意单个小节的内位数（千、百、十）；每输出一小节判断其的外位数（万、亿）\n\n代码：\n#include &lt;iostream&gt;using namespace std; int main()&#123;    string num[10] = &#123;&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;, &quot;ba&quot;, &quot;jiu&quot;&#125;; // 数字单词    string wei[5] = &#123;&quot;Shi&quot;, &quot;Bai&quot;, &quot;Qian&quot;, &quot;Wan&quot;, &quot;Yi&quot;&#125;; // 位数单词    string str;     cin &gt;&gt; str; // 输入字符串    int left = 0, right = str.length() - 1; // 设置左右下标，四位一组输出    if (str[0] == &#x27;-&#x27;)    &#123;        cout &lt;&lt; &quot;Fu&quot;; // 符号单独处理        left++; // 从下标 1 开始    &#125;    while (left + 4 &lt;= right)    &#123;        right -= 4; // 始终让 left 和 right 在同一节    &#125;    while (left &lt; str.length()) // 没全部读出就始终循环    &#123;        bool zero = false;         bool isPrint = false;         while (left &lt;= right) // 单节处理        &#123;            if (left &gt; 0 &amp;&amp; str[left] == &#x27;0&#x27;)            &#123; // 标识零位                zero = true;             &#125;            else            &#123;                if (zero) // 先判断之前有无零位                &#123;                    cout &lt;&lt; &quot; ling&quot;;                     zero = false;                 &#125;                if (left &gt; 0) // 只要不是第一个数组就必须用空格分割                &#123;                    cout &lt;&lt; &quot; &quot;;                 &#125;                cout &lt;&lt; num[str[left] - &#x27;0&#x27;]; // 输出数字                isPrint = true; // 标志有输出，需要进行万或者亿的输出                if (left != right)            // 只要这一节没到最后一个字符就要输出千、百、十                &#123;                    cout &lt;&lt; &quot; &quot; &lt;&lt; wei[right - left - 1];                 &#125;            &#125;            left++; // 左下标后移        &#125;        if (isPrint &amp;&amp; right != str.length() - 1) // 有输出而且不是最后一节        &#123;            cout &lt;&lt; &quot; &quot; &lt;&lt; wei[(str.length() - right) / 4 + 2]; // 输出万或者亿        &#125;        right += 4; // 右坐标移动到下一节    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1040\n题目：Longest Symmetric String\nGiven a string, you are supposed to output the length of the longest symmetric sub-string. For example, given Is PAT&amp;TAP symmetric?, the longest symmetric sub-string is s PAT&amp;TAP s, hence you must output 11.\nInput Specification:\nEach input file contains one test case which gives a non-empty string of length no more than 1000.\nOutput Specification:\nFor each test case, simply print the maximum length in a line.\nSample Input:\n\nIs PAT&amp;TAP symmetric?\n\nSample Output:\n\n11\n\n思路： 使用每个字符或者两个字符中的空格作为对称轴进行双向遍历，更新最大长度即可\n代码：\n#include &lt;iostream&gt;using namespace std;int main()&#123;    string str;    getline(cin, str);    int maxlen = 0, j, k;    for (int i = 0; i &lt; str.size(); i++) // 以字符做对称轴    &#123;        for (j = i, k = i; j &gt;= 0 &amp;&amp; k &lt; str.size() &amp;&amp; str[j] == str[k]; j--, k++)            ;        if (k - j - 1 &gt; maxlen)        &#123;            maxlen = k - j - 1;        &#125;    &#125;    for (int i = 0; i &lt; str.size() - 1; i++) // 字符中间做对称轴    &#123;        for (j = i, k = i + 1; j &gt;= 0 &amp;&amp; k &lt; str.size() &amp;&amp; str[j] == str[k]; j--, k++)            ;        if (k - j - 1 &gt; maxlen)        &#123;            maxlen = k - j - 1;        &#125;    &#125;    cout &lt;&lt; maxlen;    return 0;&#125;\n 总结\n\n模拟类的题就是根据要求写代码即可，主要考察思路而不是算法，代码尽量简洁，善用数组和头文件\n使用函数赋值变量时注意其返回值，指针和迭代器要进行取值\n根据输入的第一个 N 创建循环，输入的数据尽量使用临时变量在循环中处理即可，减少时间复杂度\n根据题意总结公式，输出的格式几乎都可以使用下标找到规律\n字符串的处理要多变，如：翻转后方便处理，输出多个时直接相加\n输入一个数字后紧跟 getline()进行字符串的输出，会接受到数字后的换行符，可在中间加一个 getchar()进行换行符的截获或者是使用 scanf(&quot;%d\\n&quot;,&amp;n); 的方式输入数字\n\n","categories":["算法"],"tags":["C/C++"]},{"title":"PAT 甲级 - 算法初步","url":"/pat_level_a-elementary_algorithm/","content":"\n\n接上一篇 PAT 甲级 - 入门模拟 ，自我感觉这部分才是真正的算法入门，对基础的数据结构提供了很好的类型题进行匹配练习\n包括分类：排序 、 散列 、 贪心 、 二分 、 双指针 、 打表、递推\n\n 排序\n 思想解释\n排序题主要是获取排序后的结果而不是过程，大部分代码可以使用 sort() 函数进行直接处理，要熟练编写 cmp 排序规则（包括结构体形式的多变量规则）\n有些题需要获取排名，只需在已经排序好的数组或容器中遍历全部的数据，如果和上一个数据相同，则排名相同，否则排名加 1\n 类型练习\n 1062\n题目：Talent and Virtue\nAbout 900 years ago, a Chinese philosopher Sima Guang wrote a history book in which he talked about people’s talent and virtue. According to his theory, a man being outstanding in both talent and virtue must be a “sage（圣人）”; being less excellent but with one’s virtue outweighs talent can be called a “nobleman（君子）”; being good in neither is a “fool man（愚人）”; yet a fool man is better than a “small man（小人）” who prefers talent than virtue.\nNow given the grades of talent and virtue of a group of people, you are supposed to rank them according to Sima Guang’s theory.\nInput Specification:\nEach input file contains one test case. Each case first gives 3 positive integers in a line: N(≤105)N (≤105)N(≤105), the total number of people to be ranked; L(≥60)L (≥60)L(≥60), the lower bound of the qualified grades – that is, only the ones whose grades of talent and virtue are both not below this line will be ranked; and H(&lt;100)H(&lt;100)H(&lt;100), the higher line of qualification – that is, those with both grades not below this line are considered as the “sages”, and will be ranked in non-increasing order according to their total grades. Those with talent grades below H but virtue grades not are cosidered as the “noblemen”, and are also ranked in non-increasing order according to their total grades, but they are listed after the “sages”. Those with both grades below H, but with virtue not lower than talent are considered as the “fool men”. They are ranked in the same way but after the “noblemen”. The rest of people whose grades both pass the L line are ranked after the “fool men”.\nThen N lines follow, each gives the information of a person in the format:\nID_Number Virtue_Grade Talent_Grade\nwhere ID_Number is an 8-digit number, and both grades are integers in [0,100][0, 100][0,100]. All the numbers are separated by a space.\nOutput Specification:\nThe first line of output must give M(≤N)M(≤N)M(≤N), the total number of people that are actually ranked. Then M lines follow, each gives the information of a person in the same format as the input, according to the ranking rules. If there is a tie of the total grade, they must be ranked with respect to their virtue grades in non-increasing order. If there is still a tie, then output in increasing order of their ID’s.\nSample Input:\n\n14 60 80\n10000001 64 90\n10000002 90 60\n10000011 85 80\n10000003 85 80\n10000004 80 85\n10000005 82 77\n10000006 83 76\n10000007 90 78\n10000008 75 79\n10000009 59 90\n10000010 88 45\n10000012 80 100\n10000013 90 99\n10000014 66 60\n\nSample Output:\n\n12\n10000013 90 99\n10000012 80 100\n10000003 85 80\n10000011 85 80\n10000004 80 85\n10000007 90 78\n10000006 83 76\n10000005 82 77\n10000002 90 60\n10000014 66 60\n10000008 75 79\n10000001 64 90\n\n思路： 使用结构体对每个学生的信息进行存储，根据题意编写排序规则\n\n\n存储学生信息的结构体除了基本信息外还应包含总成绩 (total) 与类别 (rank)\n\n\n编写排序规则，升序用小于号 &quot;&lt;&quot;，降序反之\n\n\n使用动态容器 vector 创建一个结构体数组，处理时将及格的放入数组，最后输出 size\n\n\n在循环中创建一个临时结构体变量进行数据的处理，符合哪种条件就将 rank 置于相应的等级\n\n\n需要注意读题， not lower than就代表 &gt;=\n\n\n代码：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std; struct Student&#123;    int Id, virtue, talent, total;    int rank; // 表示类别，1~4&#125;; bool cmp(Student a, Student b)&#123; // 排序规则    if (a.rank != b.rank)    &#123; // 类别不同，按类别从小到大        return a.rank &lt; b.rank;    &#125;    else if (a.total != b.total)    &#123;        return a.total &gt; b.total;    &#125;    else if (a.virtue != b.virtue)    &#123;        return a.virtue &gt; b.virtue;    &#125;    else    &#123; // 全部相同，按学号        return a.Id &lt; b.Id;    &#125;&#125;int main()&#123;    int n, low, height;    cin &gt;&gt; n &gt;&gt; low &gt;&gt; height;    vector&lt;Student&gt; stu; // 建立一个结构体的动态数组    for (int i = 0; i &lt; n; i++)    &#123;        Student temp; // 临时结构体变量        cin &gt;&gt; temp.Id &gt;&gt; temp.virtue &gt;&gt; temp.talent;        temp.total = temp.virtue + temp.talent; // 对每一个数据都计算它的总成绩        if (temp.virtue &lt; low || temp.talent &lt; low)        &#123;            continue; // 如果不符合条件直接处理下一个        &#125;        else if (temp.virtue &gt;= height &amp;&amp; temp.talent &gt;= height) // 这里可以是等于        &#123;            temp.rank = 1;            stu.push_back(temp);        &#125;        else if (temp.virtue &gt;= height &amp;&amp; temp.talent &lt; height)        &#123;            temp.rank = 2;            stu.push_back(temp);        &#125;        else if (temp.virtue &lt; height &amp;&amp; temp.talent &lt; height &amp;&amp; temp.virtue &gt;= temp.talent) // 不小于        &#123;            temp.rank = 3;            stu.push_back(temp);        &#125;        else        &#123;            temp.rank = 4;            stu.push_back(temp);        &#125;    &#125;    sort(stu.begin(), stu.end(), cmp); // 根据规则排序    cout &lt;&lt; stu.size() &lt;&lt; endl;        // 输出符合条件的人数    for (int i = 0; i &lt; stu.size(); i++)    &#123; // 按规则循环输出        cout &lt;&lt; stu[i].Id &lt;&lt; &quot; &quot; &lt;&lt; stu[i].virtue &lt;&lt; &quot; &quot; &lt;&lt; stu[i].talent &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1012\n题目：The Best Rank\nTo evaluate the performance of our first year CS majored students, we consider their grades of three courses only: C - C Programming Language, M - Mathematics (Calculus or Linear Algrbra), and E - English. At the mean time, we encourage students by emphasizing on their best ranks – that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student.\nFor example, The grades of C, M, E and A - Average of 4 students are given as the following:\nStudentID   C  M  E  A 310101     98 85 88 90 310102     70 95 88 84 310103     82 87 94 88 310104     91 91 91 91\nThen the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average.\nInput Specification:\nEach input file contains one test case. Each case starts with a line containing 2 numbers N and M (≤2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then N lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of C , M and E . Then there are M lines, each containing a student ID.\nOutput Specification:\nFor each of the M students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space.\nThe priorities of the ranking methods are ordered as A &gt; C &gt; M &gt; E . Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority.\nIf a student is not on the grading list, simply output N/A .\nSample Input:\n\n5 6\n310101 98 85 88\n310102 70 95 88\n310103 82 87 94\n310104 91 91 91\n310105 85 90 90\n310101\n310102\n310103\n310104\n310105\n999999\n\nSample Output:\n\n1 C\n1 M\n1 E\n1 A\n3 A\nN/A\n\n思路： 编写排序规则对每一科进行排序将排名放到结构体相应位置，使用 Map 集合创建索引，进行查询\n\n\n使用结构体对每个学生进行存储，成绩和排名用数组的方式创建\n\n\n循环输入，平均分要四舍五入，使用 answer+0.5的方式实现\n\n\n对每一科进行排序，编写循环式排序规则时，下标变量必须提前定义，处理并列排名的情况\n\n\n将最后一轮排序（数据全部处理完）后的顺序，以 ID 为键，下标为值的方式放入 Map 集合方便查询 (unordered_map 时间更短）\n\n\n对每一个被查询学生查找排名最小的一项，返回其值并获得课程下标，按格式输出\n\n\n代码：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std; struct Student // 学生结构体&#123;    string Id;    int grades[4], ranks[4];           // 对应的成绩和排名&#125; stu[2000]; // 不会超过 2000 人char course[5] = &#123;&#x27;A&#x27;, &#x27;C&#x27;, &#x27;M&#x27;, &#x27;E&#x27;&#125;; // 对应的课程，方便输出（这里的构造顺序要和处理时的顺序必须一致，顺序用题目给出的优先级即可）int now, r; // 表示课程和排名的处理bool cmp(Student a, Student b)&#123;    return a.grades[now] &gt; b.grades[now];&#125;int main()&#123;    int n, m;    cin &gt;&gt; n &gt;&gt; m;    unordered_map&lt;string, int&gt; Map; // 用于存储 ID 对应的下标，方便查询    for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; stu[i].Id &gt;&gt; stu[i].grades[1] &gt;&gt; stu[i].grades[2] &gt;&gt; stu[i].grades[3];        stu[i].grades[0] = (stu[i].grades[1] + stu[i].grades[2] + stu[i].grades[3]) / 3 + 0.5; // 平均值四舍五入    &#125;    for (now = 0; now &lt; 4; now++) // 按每科成绩进行排序    &#123;        sort(stu, stu + n, cmp);        for (int i = 0; i &lt; n; i++)        &#123;            if (stu[i].grades[now] != stu[i - 1].grades[now] || i == 0)            &#123;                r = i + 1; // 处理排名并列的情况            &#125;            stu[i].ranks[now] = r;        &#125;    &#125;    for (int i = 0; i &lt; n; i++)    &#123;        Map[stu[i].Id] = i; // 数据处理完成后将 ID 和下标对应存储，方便查询    &#125;    while (m--)    &#123;        string query;        cin &gt;&gt; query;        if (!Map.count(query)) // 没查询到元素        &#123;            cout &lt;&lt; &quot;N/A\\n&quot;;        &#125;        else        &#123;            int index = Map[query], minRank = 2001, cour; // 查询到了，获取其下标            for (int i = 0; i &lt; 4; i++)            &#123;                if (stu[index].ranks[i] &lt; minRank)                &#123;                    minRank = stu[index].ranks[i]; // 寻找这个学生的最小排名                    cour = i;                      // 获取最小排名的课程下标                &#125;            &#125;            cout &lt;&lt; minRank &lt;&lt; &quot; &quot; &lt;&lt; course[cour] &lt;&lt; endl;        &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1016\n题目：Phone Bills\nA long-distance telephone company charges its customers by the following rules:\n\nMaking a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records.\n\nInput Specification:\nEach input file contains one test case. Each case has two parts: the rate structure, and the phone call records.\nThe rate structure consists of a line with 24 non-negative integers denoting the toll (cents/minute) from 00:00−01:0000:00 - 01:0000:00−01:00, the toll from 01:00−02:0001:00 - 02:0001:00−02:00, and so on for each hour in the day.\nThe next line contains a positive number N(≤1000)N (≤1000)N(≤1000), followed by N lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date (MM:dd:HH:mm), and the word on-line or off-line.\nFor each test case, all dates will be within a single month. Each on-line record is paired with the chronologically next record for the same customer provided it is an off-line record. Any on-line records that are not paired with an off-line record are ignored, as are off-line records not paired with an on-line record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock.\nOutput Specification:\nFor each test case, you must print a phone bill for each customer.\nBills must be printed in alphabetical order of customers’ names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date (dd:HH:mm), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample.\nSample Input:\n\n10 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 10\n10\nCYLL 01:01:06:01 on-line\nCYLL 01:28:16:05 off-line\nCYJJ 01:01:07:00 off-line\nCYLL 01:01:08:03 off-line\nCYJJ 01:01:05:59 on-line\naaa 01:01:01:03 on-line\naaa 01:02:00:01 on-line\nCYLL 01:28:15:41 on-line\naaa 01:05:02:24 on-line\naaa 01:04:23:59 off-line\n\nSample Output:\n\nCYJJ 01\n01:05:59 01:07:00 61 $12.10\nTotal amount: $12.10\nCYLL 01\n01:06:01 01:08:03 122 $24.40\n28:15:41 28:16:05 24 $3.85\nTotal amount: $28.25\naaa 01\n02:00:01 04:23:59 4318 $638.80\nTotal amount: $638.80\n\n思路： 使用 Map 集合对名字自动排序，集合值为通话记录结构体组成的动态数组\n\n\n使用结构体存储通话记录，定义一个 time 用来记录开年零点到记录的时间（分钟为单位）方便后续比较和处理\n\n\n使用 Map 集合存储姓名对应的结构体数组，Map 自动排序，处理时遍历取出即可\n\n\n对取出的数组中对所有的通话记录进行排序，判断每两条记录的状态进行话费的计算\n\n\n代码：\n#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct Record // 结构体记录每条通话记录的信息，名字是公共的所以无需放入&#123;    string status;    int month, day, hour, minute, time; //time 表示的是开年零点到现在的时间（分钟为单位）&#125;;bool cmp(Record a, Record b) // 定义一个时间的排序规则&#123;    return a.time &lt; b.time;&#125;int main()&#123;    double rate[24]; // 输入收费标准，时间也是从 0 开始，无需进行下标的增减    for (int i = 0; i &lt; 24; i++)    &#123;        cin &gt;&gt; rate[i];    &#125;    int n;    cin &gt;&gt; n;    getchar();                          // 后边输入字符串，截获换行符    map&lt;string, vector&lt;Record&gt;&gt; custom; // 用名字作为键值，直接对其进行排序    for (int i = 0; i &lt; n; i++)    &#123;        Record temp;        string temp_name; // 作为键放入 Map，临时变量即可        cin &gt;&gt; temp_name;        //cin&gt;&gt; temp.month &gt;&gt; temp.day &gt;&gt; temp.hour &gt;&gt; temp.minute;        // 这种输出对有 &quot;:&quot; 间隔的数据无法处理，可以加一个 char c 截获，或使用下面 scanf 的方式输入        scanf(&quot;%d:%d:%d:%d&quot;, &amp;temp.month, &amp;temp.day, &amp;temp.hour, &amp;temp.minute);        cin &gt;&gt; temp.status;        temp.time = temp.day * 1440 + temp.hour * 60 + temp.minute; // 统一转换成分钟方便运算        custom[temp_name].push_back(temp);                          // 以姓名为键，记录数组为值放入集合    &#125;    for (auto it : custom)    &#123;        auto temp_V = it.second;                 // 将每个人的通话记录数组拿出来，对每个数组进行处理        sort(temp_V.begin(), temp_V.end(), cmp); // 对所有的通话记录进行排序        double total_bill = 0;        for (int i = 0; i &lt; temp_V.size();) // 分组判断，不直接递增        &#123;            if (i + 1 &lt; temp_V.size() &amp;&amp; temp_V[i].status &gt; temp_V[i + 1].status) //on 按字典序高于 off，一组符合规则的数据            &#123;                if (!total_bill) // 使用非的方式只输出一次姓名，后续 total 有值便为 0                &#123;                    cout &lt;&lt; it.first;                    printf(&quot; %02d\\n&quot;, temp_V[i].month);                &#125;                double per_bill = 0;                int time1 = temp_V[i].time, time2 = temp_V[i + 1].time;                for (int j = time1; j &lt; time2; j++) // 模拟时间                &#123;                    per_bill += rate[j % 1440 / 60]; // 每分钟的单价相加                &#125;                printf(&quot;%02d:%02d:%02d &quot;, temp_V[i].day, temp_V[i].hour, temp_V[i].minute);                printf(&quot;%02d:%02d:%02d &quot;, temp_V[i + 1].day, temp_V[i + 1].hour, temp_V[i + 1].minute);                printf(&quot;%d $%.2f\\n&quot;, temp_V[i + 1].time - temp_V[i].time, per_bill / 100);                total_bill += per_bill;                i += 2; // 一组成功下一组            &#125;            else            &#123;                i++; // 一组不成功，以结束时间作为下一组的开始时间            &#125;        &#125;        if (total_bill) // 这个是在人物之外，还需判断一次，防止有人存在的账单都不符合条件但还是输出了 total_bill        &#123;            printf(&quot;Total amount: $%.2f\\n&quot;, total_bill / 100); // 账单以时间为单位        &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1025\n题目：PAT Ranking\nProgramming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains a positive number N(≤100)N (≤100)N(≤100), the number of test locations. Then N ranklists follow, each starts with a line containing a positive integer K(≤300)K (≤300)K(≤300), the number of testees, and then K lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space.\nOutput Specification:\nFor each test case, first print in one line the total number of testees. Then print the final ranklist in the following format:\nregistration_number final_rank location_number local_rank\nThe locations are numbered from 1 to N. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers.\nSample Input:\n\n2\n5\n1234567890001 95\n1234567890005 100\n1234567890003 95\n1234567890002 77\n1234567890004 85\n4\n1234567890013 65\n1234567890011 25\n1234567890014 100\n1234567890012 85\n\nSample Output:\n\n9\n1234567890005 1 1 1\n1234567890014 1 2 1\n1234567890001 3 1 2\n1234567890003 3 1 2\n1234567890004 5 1 4\n1234567890012 5 2 2\n1234567890002 7 1 5\n1234567890013 8 2 3\n1234567890011 9 2 4\n\n思路： 结构体 + 动态数组存储，分情况处理排名，考场内排名的处理用临时数组每输入完一个考场处理一次的形式\n代码：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std; struct Student&#123;    string num;    int score, ranks[2], room; //ranks[0] 代表总排名，1 代表考场排名&#125;; bool cmp(Student a, Student b) // 排序规则&#123;    return a.score == b.score ? a.num &lt; b.num : a.score &gt; b.score;&#125;int r; // 处理并列排名int main()&#123;    int n, m;    cin &gt;&gt; n;    vector&lt;Student&gt; stu; // 所有成员的结构体动态数组    for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; m;        getchar(); // 捕捉换行符        Student temp_stu[m];        for (int j = 0; j &lt; m; j++)        &#123;            cin &gt;&gt; temp_stu[j].num &gt;&gt; temp_stu[j].score;            temp_stu[j].room = i + 1; // 考场号就等于组数 +1        &#125;        sort(temp_stu, temp_stu + m, cmp); // 对一个考场的所有成员进行排序        for (int k = 0; k &lt; m; k++)        &#123;            if (k == 0 || temp_stu[k].score != temp_stu[k - 1].score)            &#123;                r = k + 1;            &#125;            temp_stu[k].ranks[1] = r;   // 赋值考场排名            stu.push_back(temp_stu[k]); // 放入总数组        &#125;    &#125;    sort(stu.begin(), stu.end(), cmp); // 公共排名处理    for (int i = 0; i &lt; stu.size(); i++)    &#123;        if (i == 0 || stu[i].score != stu[i - 1].score)        &#123;            r = i + 1;        &#125;        stu[i].ranks[0] = r;    &#125;    cout &lt;&lt; stu.size() &lt;&lt; endl;    for (int i = 0; i &lt; stu.size(); i++)    &#123;        cout &lt;&lt; stu[i].num &lt;&lt; &quot; &quot; &lt;&lt; stu[i].ranks[0] &lt;&lt; &quot; &quot; &lt;&lt; stu[i].room &lt;&lt; &quot; &quot; &lt;&lt; stu[i].ranks[1] &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1028\n题目：List Sorting\nExcel can sort records according to any column. Now you are supposed to imitate this function.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains two integers N(≤105)N (≤10^5)N(≤105) and C, where N is the number of records and C is the column that you are supposed to sort the records with. Then N lines follow, each contains a record of a student. A student’s record consists of his or her distinct ID (a 6-digit number), name (a string with no more than 8 characters without space), and grade (an integer between 0 and 100, inclusive).\nOutput Specification:\nFor each test case, output the sorting result in N lines. That is, if C=1C = 1C=1 then the records must be sorted in increasing order according to ID’s; if C=2C = 2C=2 then the records must be sorted in non-decreasing order according to names; and if C=3C = 3C=3 then the records must be sorted in non-decreasing order according to grades. If there are several students who have the same name or grade, they must be sorted according to their ID’s in increasing order.\nSample Input 1:\n\n3 1\n000007 James 85\n000010 Amy 90\n000001 Zoe 60\n\nSample Output 1:\n\n000001 Zoe 60\n000007 James 85\n000010 Amy 90\n\n思路： 设置变量 C 在排序规则之外，根据 C 的值返回相应的规则；注意 non-decreasing 表示非降序（≠升序）比较运算符要用 &lt;=\n代码：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;struct Student&#123;    string Id, name;    int score;&#125;;int c;bool cmp(Student a, Student b)&#123;    if (c == 1)    &#123;        return a.Id &lt; b.Id;    &#125;    else if (c == 2)    &#123;        return a.name == b.name ? a.Id &lt; b.Id : a.name &lt;= b.name;    &#125;    else if (c == 3)    &#123;        return a.score == b.score ? a.Id &lt; b.Id : a.score &lt;= b.score;    &#125;    return 0;&#125;int main()&#123;    int n;    vector&lt;Student&gt; stu;    scanf(&quot;%d%d&quot;, &amp;n, &amp;c);    for (int i = 0; i &lt; n; i++)    &#123;        Student temp;        cin &gt;&gt; temp.Id &gt;&gt; temp.name &gt;&gt; temp.score;        stu.push_back(temp);    &#125;    sort(stu.begin(), stu.end(), cmp);    for (int i = 0; i &lt; stu.size(); i++)    &#123;        printf(&quot;%s %s %d\\n&quot;, stu[i].Id.c_str(), stu[i].name.c_str(), stu[i].score);    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1055\n题目：The World’s Richest\nForbes magazine publishes every year its list of billionaires based on the annual ranking of the world’s wealthiest people. Now you are supposed to simulate this job, but concentrate only on the people in a certain range of ages. That is, given the net worths of N people, you must find the M richest people in a given range of their ages.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains 2 positive integers: N(≤105)N (≤10^5)N(≤105) - the total number of people, and K(≤103)K (≤10^3)K(≤103) - the number of queries. Then N lines follow, each contains the name (string of no more than 8 characters without space), age (integer in (0,200](0, 200](0,200]), and the net worth (integer in [−106,106][−106, 106][−106,106]) of a person. Finally there are K lines of queries, each contains three positive integers: M(≤100)M (≤100)M(≤100) - the maximum number of outputs, and [Amin , Amax ] which are the range of ages. All the numbers in a line are separated by a space.\nOutput Specification:\nFor each query, first print in a line Case #X: where X is the query number starting from 1. Then output the M richest people with their ages in the range [Amin , Amax ]. Each person’s information occupies a line, in the format\nName   Age   Net_Worth\nThe outputs must be in non-increasing order of the net worths. In case there are equal worths, it must be in non-decreasing order of the ages. If both worths and ages are the same, then the output must be in non-decreasing alphabetical order of the names. It is guaranteed that there is no two persons share all the same of the three pieces of information. In case no one is found, output None .\nSample Input:\n\n12 4\nZoe_Bill 35 2333\nBob_Volk 24 5888\nAnny_Cin 95 999999\nWilliams 30 -22\nCindy 76 76000\nAlice 18 88888\nJoe_Mike 32 3222\nMichael 5 300000\nRosemary 40 5888\nDobby 24 5888\nBilly 24 5888\nNobody 5 0\n4 15 45\n4 30 35\n4 5 95\n1 45 50\n\nSample Output:\n\nCase #1:\nAlice 18 88888\nBilly 24 5888\nBob_Volk 24 5888\nDobby 24 5888\nCase #2:\nJoe_Mike 32 3222\nZoe_Bill 35 2333\nWilliams 30 -22\nCase #3:\nAnny_Cin 95 999999\nMichael 5 300000\nAlice 18 88888\nCindy 76 76000\nCase #4:\nNone\n\n思路： 使用多个结构体动态数组，挑选数据后只排序一次，减少复杂度\n\n\n结构体的字符串使用字符数组，配合 scanf() 减少复杂度\n\n\n输入数据后按规则进行排序，如果年龄相同只保存 100 人，减少遍历长度\n\n\n代码：\n#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std; struct Person&#123;    char name[10]; // 使用字符数组，配合 scanf() 减少复杂度    int age, money;&#125;; bool cmp(Person a, Person b)&#123;    if (a.money != b.money)    &#123;        return a.money &gt;= b.money;    &#125;    else if (a.age != b.age)    &#123;        return a.age &lt;= b.age;    &#125;    else    &#123;        return strcmp(a.name, b.name) &lt;= 0; // 字符数组的排序    &#125;&#125;int main()&#123;    int n, k;    scanf(&quot;%d %d&quot;, &amp;n, &amp;k);    vector&lt;Person&gt; temp_in(n); // 输入数组    for (int i = 0; i &lt; n; i++)    &#123;        scanf(&quot;%s %d %d&quot;, &amp;temp_in[i].name, &amp;temp_in[i].age, &amp;temp_in[i].money);    &#125;    sort(temp_in.begin(), temp_in.end(), cmp); // 排序    vector&lt;int&gt; book(201, 0);    vector&lt;Person&gt; people;    for (int i = 0; i &lt; n; i++)    &#123;        if (book[temp_in[i].age] &lt; 100) // 每个年龄都不超过 100 人        &#123;            people.push_back(temp_in[i]); // 缩小数据放到新数组            book[temp_in[i].age]++;        &#125;    &#125;    int m, Amin, Amax; // 将循环输入的变量放到循环外减少语句量    for (int i = 0; i &lt; k; i++)    &#123;        scanf(&quot;%d %d %d&quot;, &amp;m, &amp;Amin, &amp;Amax);        vector&lt;Person&gt; temp_out;        for (int j = 0; j &lt; people.size(); j++)        &#123;            if (people[j].age &gt;= Amin &amp;&amp; people[j].age &lt;= Amax)            &#123;                temp_out.push_back(people[j]); // 将符合条件的放入输出数组            &#125;        &#125;        printf(&quot;Case #%d:\\n&quot;, i + 1);        bool flag = false;        for (int l = 0; l &lt; m &amp;&amp; l &lt; temp_out.size(); l++) // 有不足 m 的情况，加一个大小的判断条件        &#123;            printf(&quot;%s %d %d\\n&quot;, temp_out[l].name, temp_out[l].age, temp_out[l].money);            flag = true;        &#125;        if (!flag)        &#123;            printf(&quot;None\\n&quot;);        &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1075\n题目：PAT Judge\nThe ranklist of PAT is generated from the status list, which shows the scores of the submissions. This time you are supposed to generate the ranklist for PAT.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains 3 positive integers, N(≤104)N (≤10^4)N(≤104), the total number of users, K(≤5)K (≤5)K(≤5), the total number of problems, and M(≤105)M (≤10^5)M(≤105), the total number of submissions. It is then assumed that the user id’s are 5-digit numbers from 00001 to N, and the problem id’s are from 1 to K. The next line contains K positive integers p[i] (i=1, …, K), where p[i] corresponds to the full mark of the i-th problem. Then M lines follow, each gives the information of a submission in the following format:\nuser_id   problem_id   partial_score_obtained\nwhere partial_score_obtained is either −1 if the submission cannot even pass the compiler, or is an integer in the range [0, p[problem_id]]. All the numbers in a line are separated by a space.\nOutput Specification:\nFor each test case, you are supposed to output the ranklist in the following format:\nrank   user_id   total_score   s[1] ... s[K]\nwhere rank is calculated according to the total_score, and all the users with the same total_score obtain the same rank; and s[i] is the partial score obtained for the i-th problem. If a user has never submitted a solution for a problem, then “-” must be printed at the corresponding position. If a user has submitted several solutions to solve one problem, then the highest score will be counted.\nThe ranklist must be printed in non-decreasing order of the ranks. For those who have the same rank, users must be sorted in nonincreasing order according to the number of perfectly solved problems. And if there is still a tie, then they must be printed in increasing order of their id’s. For those who has never submitted any solution that can pass the compiler, or has never submitted any solution, they must NOT be shown on the ranklist. It is guaranteed that at least one user can be shown on the ranklist.\nSample Input:\n\n7 4 20\n20 25 25 30\n00002 2 12\n00007 4 17\n00005 1 19\n00007 2 25\n00005 1 20\n00002 2 2\n00005 1 15\n00001 1 18\n00004 3 25\n00002 2 25\n00005 3 22\n00006 4 -1\n00001 2 18\n00002 1 20\n00004 1 15\n00002 4 18\n00001 3 4\n00001 4 2\n00005 2 -1\n00004 2 0\n\nSample Output:\n\n1 00002 63 20 25 - 18\n2 00005 42 20 0 22 -\n2 00007 42 - 25 - 17\n2 00001 42 18 18 4 2\n5 00004 40 15 0 25 -\n\n思路： 创建一个 N 人的结构体数组，输入时直接以 ID 作为下标进行输入\n\n\n结构体进行存储，需要自行添加的变量有： isShow只要有一条通过编译，置为 true 表示可以输出； passnum表示满分题目数量\n\n\n输入记录时会有一个人重复提交的情况，每次比对相同 ID 是不现实的，直接创建一个数据规模为 N+1N+1N+1 的结构体数组，以 ID 作为下标进行记录提交处理\n\n\n输入的成绩不止未通过和有成绩两种状态，还有未提交的情况，将成绩的初始值置为 -2 表示未提交\n\n\n记录输入完成根据有效成绩，计算 total_score 和 passnum\n\n\n进行排序后为每名同学赋值 rank，然后判断 isShow 的值循环输出\n\n\n代码：\n#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int n, k, m; // 总人数，问题数和提交记录的数量struct Record&#123;    int rank, Id, passnum = 0;              //passnum 表示完美通过的数量    int score[6] = &#123;0, -2, -2, -2, -2, -2&#125;; //-2== 没有提交过；-1== 没通过编译    bool isShow = false;                    // 若没有一条能够通过编译不显示&#125;;bool cmp(Record a, Record b)&#123;    if (a.score[0] != b.score[0])    &#123;        return a.score[0] &gt;= b.score[0];    &#125;    else if (a.passnum != b.passnum)    &#123;        return a.passnum &gt;= b.passnum;    &#125;    else    &#123;        return a.Id &lt; b.Id;    &#125;&#125;int main()&#123;    scanf(&quot;%d %d %d&quot;, &amp;n, &amp;k, &amp;m);    vector&lt;Record&gt; v(n + 1);     // 输入记录的时候遍历寻找是哪个人进行提交是不现实的，直接用 ID 作为下标    int full_score[k];           // 保存每道题目的成绩上限    for (int i = 1; i &lt;= k; i++) // 题号从 1 开始    &#123;        scanf(&quot;%d&quot;, &amp;full_score[i]); // 输入每一题的满分    &#125;    int Id, pro_num, score_obt;    for (int i = 0; i &lt; m; i++)    &#123;        scanf(&quot;%d %d %d&quot;, &amp;Id, &amp;pro_num, &amp;score_obt);        v[Id].Id = Id;        v[Id].score[pro_num] = max(v[Id].score[pro_num], score_obt); // 多次提交保留最大值        if (score_obt != -1)                                         // 只要有成绩就置为可以输出        &#123;            v[Id].isShow = true;        &#125;    &#125; // 输入处理完成    for (int i = 1; i &lt;= n; i++) // 学生的序号一直到 n    &#123;        for (int j = 1; j &lt;= k; j++) // 题目的序号一直到 k        &#123;            if (v[i].score[j] != -2 &amp;&amp; v[i].score[j] != -1)            &#123;                v[i].score[0] += v[i].score[j]; // 相加有效成绩            &#125;            if (v[i].score[j] == full_score[j])            &#123;                v[i].passnum++; // 记录满分数量            &#125;        &#125;    &#125;    sort(v.begin() + 1, v.end(), cmp); //0 恒为空值    for (int i = 1; i &lt;= n; i++)       // 赋予排名    &#123;        v[i].rank = i;        if (i != 1 &amp;&amp; v[i].score[0] == v[i - 1].score[0])        &#123;            v[i].rank = v[i - 1].rank;        &#125;    &#125; // 处理完成    for (int i = 1; i &lt;= n; i++)    &#123;        if (v[i].isShow) // 判断有无输出条件按格式输出        &#123;            printf(&quot;%d %05d %d&quot;, v[i].rank, v[i].Id, v[i].score[0]);            for (int j = 1; j &lt;= k; j++)            &#123;                if (v[i].score[j] != -1 &amp;&amp; v[i].score[j] != -2)                    printf(&quot; %d&quot;, v[i].score[j]);                else if (v[i].score[j] == -2)                    printf(&quot; -&quot;);                else                    printf(&quot; 0&quot;);            &#125;            printf(&quot;\\n&quot;);        &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1083\n题目：List Grades\nGiven a list of N student records with name, ID and grade. You are supposed to sort the records with respect to the grade in non-increasing order, and output those student records of which the grades are in a given interval.\nInput Specification:\nEach input file contains one test case. Each case is given in the following format:\nNname[1] ID[1] grade[1]name[2] ID[2] grade[2]... ...name[N] ID[N] grade[N]grade1 grade2\nwhere name[i] and ID[i] are strings of no more than 10 characters with no space, grade[i] is an integer in [0,100][0, 100][0,100], grade1 and grade2 are the boundaries of the grade’s interval. It is guaranteed that all the grades are distinct.\nOutput Specification:\nFor each test case you should output the student records of which the grades are in the given interval [grade1 , grade2 ] and are in non-increasing order. Each student record occupies a line with the student’s name and ID, separated by one space. If there is no student’s grade in that interval, output NONE instead.\nSample Input 1:\n\n4\nTom CS000001 59\nJoe Math990112 89\nMike CS991301 100\nMary EE990830 95\n60 100\n\nSample Output 1:\n\nMike CS991301\nMary EE990830\nJoe Math990112\n\nSample Input 2:\n\n2\nJean AA980920 60\nAnn CS01 80\n90 95\n\nSample Output 2:\n\nNONE\n\n思路： 输入完成后根据区间判断，记录符合范围的个数，不符合将值改为 -1，排序输出\n代码：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std; struct Student&#123;    string name, Id;    int score;&#125;; bool cmp(Student a, Student b)&#123;    return a.score &gt; b.score;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    vector&lt;Student&gt; stu;    Student temp;    for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; temp.name &gt;&gt; temp.Id &gt;&gt; temp.score;        stu.push_back(temp);    &#125;    int low, height;    int count = 0;    cin &gt;&gt; low &gt;&gt; height;    for (int i = 0; i &lt; stu.size(); i++)    &#123;        if (stu[i].score &lt; low || stu[i].score &gt; height)        &#123;            stu[i].score = -1;        &#125;        else        &#123;            count++;        &#125;    &#125;    if (count)    &#123;        sort(stu.begin(), stu.end(), cmp);        for (int i = 0; i &lt; count; i++)        &#123;            cout &lt;&lt; stu[i].name &lt;&lt; &quot; &quot; &lt;&lt; stu[i].Id &lt;&lt; endl;        &#125;    &#125;    else    &#123;        cout &lt;&lt; &quot;NONE\\n&quot;;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1080\n题目：Graduate Admission\nIt is said that in 2011, there are about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure.\nEach applicant will have to provide two grades: the national entrance exam grade GEG_EGE​, and the interview grade GIG_IGI​. The final grade of an applicant is (GE+GI)/2(G_E+G_I)/2(GE​+GI​)/2. The admission rules are:\n\n\nThe applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list.\n\n\nIf there is a tied final grade, the applicants will be ranked according to their national entrance exam grade GEG_EGE​. If still tied, their ranks must be the same.\n\n\nEach applicant may have K choices and the admission will be done according to his/her choices: if according to the rank list, it is one’s turn to be admitted; and if the quota of one’s most preferred shcool is not exceeded, then one will be admitted to this school, or one’s other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected.\n\n\nIf there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, even if its quota will be exceeded.\n\n\nInput Specification:\nEach input file contains one test case.Each case starts with a line containing three positive integers: N(≤40,000)N (≤40,000)N(≤40,000), the total number of applicants; M(≤100)M (≤100)M(≤100), the total number of graduate schools; and K(≤5)K(≤5)K(≤5), the number of choices an applicant may have.\nIn the next line, separated by a space, there are M positive integers. The i-th integer is the quota of the i-th graduate school respectively.\nThen N lines follow, each contains 2+K integers separated by a space. The first 2 integers are the applicant’s GEG_EGE​ and GIG_IGI​, respectively. The next K integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to M−1, and the applicants are numbered from 0 to N−1.\nOutput Specification:\nFor each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants’ numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly.\nSample Input:\n\n11 6 3\n2 1 2 2 2 3\n100 100 0 1 2\n60 60 2 3 5\n100 90 0 3 4\n90 100 1 2 0\n90 90 5 1 3\n80 90 1 0 2\n80 80 0 1 2\n80 70 1 3 2\n70 80 1 2 3\n100 100 0 2 4\n\nSample Output:\n\n0 10\n3\n5 6 7\n2 8\n1 4\n\n思路： 同时建立学生学校两个结构体分别进行处理\n\n\n学校结构体创建一个 last 变量，方便比对招满后最后一人的排名是否有与之并列的存在\n\n\n学生结构体创建 ID 变量和 rank 保存原始编号和排名\n\n\n按成绩排序分配排名后，对每个学生进行处理，遍历每个学生的志愿，判断是否达到入校条件\n\n\n对每个学校的招入名单排序输出\n\n\n代码：\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct School&#123;    int quota, last;   //last 为录取的最后一个学生用来判断同排名    vector&lt;int&gt; admit; // 被录取的学生放到该数组&#125; school[100];struct Applicant&#123;    int Id, rnk, Ge, Gi, G; // 学生 ID 要单独保存    int choice[5];&#125; alct[40000];int N, M, K;bool cmp(Applicant a, Applicant b)&#123;    if (a.G != b.G)    &#123;        return a.G &gt; b.G;    &#125;    return a.Ge &gt; b.Ge;&#125;int main()&#123;    cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;    for (int i = 0; i &lt; M; i++)    &#123;        cin &gt;&gt; school[i].quota; // 输入每个学校的招生人数    &#125;    for (int i = 0; i &lt; N; i++)    &#123;        cin &gt;&gt; alct[i].Ge &gt;&gt; alct[i].Gi;        for (int j = 0; j &lt; K; j++)        &#123;            cin &gt;&gt; alct[i].choice[j];        &#125;        alct[i].G = alct[i].Ge + alct[i].Gi; // 相加即可        alct[i].Id = i;                      // 将编号保存，排序后仍使用原始编号    &#125;    sort(alct, alct + N, cmp); // 将学生按成绩排名    for (int i = 0; i &lt; N; i++)    &#123;        if (i == 0 || alct[i].G != alct[i - 1].G || alct[i].Ge != alct[i - 1].Ge)        &#123; // 分配名次            alct[i].rnk = i + 1;        &#125;        else        &#123;            alct[i].rnk = alct[i - 1].rnk;        &#125;    &#125;    for (int i = 0; i &lt; N; i++)    &#123;        for (int j = 0; j &lt; K; j++)        &#123;            int k = alct[i].choice[j]; // 遍历所有志愿            if (school[k].admit.size() &lt; school[k].quota || alct[i].rnk == alct[school[k].last].rnk)            &#123;                                          // 人数没招满或与招到最后一人的排名相等                school[k].admit.push_back(alct[i].Id); //ID 放入数组                school[k].last = i;                    // 覆盖最后值                break;            &#125;        &#125;    &#125;    for (int i = 0; i &lt; M; i++)    &#123;        sort(school[i].admit.begin(), school[i].admit.end()); // 对每个学校照到的学生按序号排序        for (int j = 0; j &lt; school[i].admit.size(); j++)        &#123;            if (j)            &#123; // 不是第一个就输出空格                cout &lt;&lt; &quot; &quot;;            &#125;            cout &lt;&lt; school[i].admit[j];        &#125;        cout &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1095\n题目：Cars on Campus\nZhejiang University has 8 campuses and a lot of gates. From each gate we can collect the in/out times and the plate numbers of the cars crossing the gate. Now with all the information available, you are supposed to tell, at any specific time point, the number of cars parking on campus, and at the end of the day find the cars that have parked for the longest time period.\nInput Specification:\nEach input file contains one test case. Each case starts with two positive integers N(≤104)N(≤10^4)N(≤104), the number of records, and K(≤8×104)K (≤8×10^4)K(≤8×104) the number of queries. Then N lines follow, each gives a record in the format:\nplate_number   hh:mm:ss   status\nwhere plate_number is a string of 7 English capital letters or 1-digit numbers; hh:mm:ss represents the time point in a day by hour:minute:second, with the earliest time being 00:00:00 and the latest 23:59:59 ; and status is either in or out .\nNote that all times will be within a single day. Each in record is paired with the chronologically next record for the same car provided it is an out record. Any in records that are not paired with an out record are ignored, as are out records not paired with an in record. It is guaranteed that at least one car is well paired in the input, and no car is both in and out at the same moment. Times are recorded using a 24-hour clock.\nThen K lines of queries follow, each gives a time point in the format hh:mm:ss . Note: the queries are given in ascending order of the times.\nOutput Specification:\nFor each query, output in a line the total number of cars parking on campus. The last line of output is supposed to give the plate number of the car that has parked for the longest time period, and the corresponding time length. If such a car is not unique, then output all of their plate numbers in a line in alphabetical order, separated by a space.\nSample Input:\n\n16 7\nJH007BD 18:00:01 in\nZD00001 11:30:08 out\nDB8888A 13:00:00 out\nZA3Q625 23:59:50 out\nZA133CH 10:23:00 in\nZD00001 04:09:59 in\nJH007BD 05:09:59 in\nZA3Q625 11:42:01 out\nJH007BD 05:10:33 in\nZA3Q625 06:30:50 in\nJH007BD 12:23:42 out\nZA3Q625 23:55:00 in\nJH007BD 12:24:23 out\nZA133CH 17:11:22 out\nJH007BD 18:07:01 out\nDB8888A 06:30:50 in\n05:10:00\n06:30:50\n11:00:00\n12:23:42\n14:00:00\n18:00:00\n23:59:00\n\nSample Output:\n\n1\n4\n5\n2\n1\n0\n1\nJH007BD ZD00001 07:20:09\n\n思路： 使用 MAP 集合存储数据，车牌号为键，结构体数组为值\n\n\n使用结构体对出入记录进行存储，同时计算记录是在一天中的第几秒\n\n\n遍历集合，将每个车牌对应的记录数组进行排序，进行出入配对，将当前时间点放入出入数组中，并累积一个车牌号停车的时长\n\n\n遍历一天中的 86400 秒，将每秒的停车数量记录下来，公式：时间点前的所有进减去所有出\n\n\n比较所有时长取出停车时间最长的，并列也放入数组，然后对车牌号排序\n\n\n代码：\n#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std; struct Record&#123;    string p_num, statu;    int hour, mintue, second, time; // 存储当前时间点在一天中是第多少秒&#125;; unordered_map&lt;string, vector&lt;Record&gt;&gt; msvr; // 记录集合unordered_map&lt;string, int&gt; msi; // 停靠时间集合int N, K; int in_school[86400] = &#123;0&#125;; // 在这一秒有多少车辆进入int out_school[86400] = &#123;0&#125;; // 在这一秒有多少车辆出去bool cmp(Record a, Record b)&#123;    return a.time &lt; b.time; // 时间从早到晚排序&#125;int main()&#123;    cin &gt;&gt; N &gt;&gt; K;    for (int i = 0; i &lt; N; i++)    &#123;        Record temp;        cin &gt;&gt; temp.p_num;        scanf(&quot;%d:%d:%d&quot;, &amp;temp.hour, &amp;temp.mintue, &amp;temp.second);        cin &gt;&gt; temp.statu;        temp.time = temp.hour * 3600 + temp.mintue * 60 + temp.second;        msvr[temp.p_num].push_back(temp); // 将每次输入的记录放到车牌号对应的数组中    &#125;    for (auto it : msvr) // 遍历集合    &#123;        auto v = it.second; // 将每个车牌号对应的数组取出        sort(v.begin(), v.end(), cmp);        for (int i = 0; i &lt; v.size();)        &#123;            if (v[i].statu == &quot;in&quot;) // 进行配对处理            &#123;                if (i + 1 &lt; v.size() &amp;&amp; v[i + 1].statu == &quot;out&quot;)                &#123;                    in_school[v[i].time]++; // 将 in 的状态放到对应的时间点                    out_school[v[i + 1].time]++;                    msi[it.first] += v[i + 1].time - v[i].time; // 统计停车时长                    i += 2;                                     // 下一组                &#125;                else                &#123;                    i++;                &#125;            &#125;            else            &#123;                i++;            &#125;        &#125;    &#125;    int car_cnt[86400];    int t = 0;    for (int i = 0; i &lt; 86400; i++)    &#123;        t += in_school[i];        t -= out_school[i];        car_cnt[i] = t; // 每个时间的车辆 == 之前所有的进 - 所有的出    &#125;    int t_h, t_m, t_s;     for (int i = 0; i &lt; K; i++)    &#123;        scanf(&quot;%d:%d:%d&quot;, &amp;t_h, &amp;t_m, &amp;t_s);         printf(&quot;%d\\n&quot;, car_cnt[t_h * 3600 + t_m * 60 + t_s]);     &#125;    int max_time = 0;     vector&lt;string&gt; maxcars; // 存储并列的最久车辆，保存车牌号    for (auto it : msi)    &#123;        if (it.second &gt; max_time)        &#123;            max_time = it.second;             maxcars = &#123;it.first&#125;; // 现在是唯一的答案，直接赋值（不使用放入，因为每次赋值都要清空前面所有的）        &#125;        else if (it.second == max_time)        &#123;            maxcars.push_back(it.first); // 现在是并列的答案，放入        &#125;    &#125;    sort(maxcars.begin(), maxcars.end()); // 根据字符排序    for (string each : maxcars)    &#123;        cout &lt;&lt; each &lt;&lt; &quot; &quot;;     &#125;    printf(&quot;%02d:%02d:%02d&quot;, max_time / 3600, max_time / 60 % 60, max_time % 60);     system(&quot;pause&quot;);    return 0;&#125;\n 总结\n\n如果需要对排序进行查询，一定要数据全部处理完成后再放入 MAP 集合或其他容器中，不然会导致下标混乱，如 T1012\n排序型算法要处理的数据难免过大，可以采用以下方式缩小复杂度：\n\n将局部变量定义在循环外，尽量缩小循环内的执行语句量\n输入输出函数使用 scanf() 和 printf()，字符串可以使用字符数组，排序使用 strcmp() 函数\n局部多次排序可以使用单次排序，尤其对大型数据的小型查询，如 T1028\n\n\n循环中进行比较的动态数组，不要直接放入，存在每次比较过后要清空之前数据的可能，直接赋值，如 T095\n\n 散列\n 思想解释\n将元素通过某种方式转换为整数使其尽量唯一的表示这个元素的特质\n如：求在长度为 N 的数组中，求 M 个数有没有出现过，就可以设置一个 judge[] 以 Ni 作为下标，将值置为 true，查询时只需判断 Mi 作为下标时值是否为 true 即可\n将直接输入的数作为数组下标直接表示这个数的特质的方式经常使用\n 类型练习\n 1084\n题目：Broken Keyboard\nOn a broken keyboard, some of the keys are worn out. So when you type some sentences, the characters corresponding to those keys will not appear on screen.\nNow given a string that you are supposed to type, and the string that you actually type out, please list those keys which are for sure worn out.\nInput Specification:\nEach input file contains one test case. For each case, the 1st line contains the original string, and the 2nd line contains the typed-out string. Each string contains no more than 80 characters which are either English letters [A−Z][A-Z][A−Z] (case insensitive), digital numbers [0−9][0-9][0−9], or _ (representing the space). It is guaranteed that both strings are non-empty.\nOutput Specification:\nFor each test case, print in one line the keys that are worn out, in the order of being detected. The English letters must be capitalized. Each worn out key must be printed once only. It is guaranteed that there is at least one worn out key.\nSample Input:\n\n7_This_is_a_test\n_hs_s_a_es\n\nSample Output:\n\n7TI\n\n思路：\n\n\n字符串写法：遍历预想字符串的每个字符去实际字符串中查找，如果本身和它大写形式查找的返回值都是string::npos，保留其大写形式\n\n\n散列写法：设立一个标记数组（字符会自动转为 ASCII 码作为数字下标），遍历预想字符串，如果不相同且没被标记过，放入数组\n\n\n代码：\n#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    /* 字符串写法    string s1, s2, ans;    cin &gt;&gt; s1 &gt;&gt; s2;    for (int i = 0; i &lt; s1.length(); i++) // 遍历字符串 1 中的每个字符去字符串 2 中查找        if (s2.find(s1[i]) == string::npos &amp;&amp; ans.find(toupper(s1[i])) == string::npos)        &#123; // 查找字符和字符的大写，查找失败返回 string::npos            ans += toupper(s1[i]);        &#125;    cout &lt;&lt; ans;    */    int flag[128] = &#123;0&#125;;    vector&lt;char&gt; vc;    string s1, s2;    cin &gt;&gt; s1 &gt;&gt; s2;    int i = 0, j = 0;    while (i &lt; s1.length()) // 遍历全部的预想结果    &#123;        if (s1[i] != s2[j])        &#123;            if (!flag[s1[i]]) // 还没有标记过            &#123;                flag[tolower(s1[i])] = 1;                flag[toupper(s1[i])] = 1;     // 将大小写全部标记成 1                vc.push_back(toupper(s1[i])); // 放入大写形式            &#125;            i++;        &#125;        else        &#123;            i++;            j++;        &#125;    &#125;    for (char i : vc)    &#123;        cout &lt;&lt; i;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1092\n题目：To Buy or Not to Buy\nEva would like to make a string of beads with her favorite colors so she went to a small shop to buy some beads. There were many colorful strings of beads. However the owner of the shop would only sell the strings in whole pieces. Hence Eva must check whether a string in the shop contains all the beads she needs. She now comes to you for help: if the answer is Yes , please tell her the number of extra beads she has to buy; or if the answer is No , please tell her the number of beads missing from the string.\nFor the sake of simplicity, let’s use the characters in the ranges [0−9][0-9][0−9], [a−z][a-z][a−z], and [A−Z][A-Z][A−Z] to represent the colors. For example, the 3rd string in Figure 1 is the one that Eva would like to make. Then the 1st string is okay since it contains all the necessary beads with 8 extra ones; yet the 2nd one is not since there is no black bead and one less red bead.\nInput Specification:\nEach input file contains one test case. Each case gives in two lines the strings of no more than 1000 beads which belong to the shop owner and Eva, respectively.\nOutput Specification:\nFor each test case, print your answer in one line. If the answer is Yes , then also output the number of extra beads Eva has to buy; or if the answer is No , then also output the number of beads missing from the string. There must be exactly 1 space between the answer and the number.\nSample Input 1:\n\nppRYYGrrYBR2258\nYrR8RrY\n\nSample Output 1:\n\nYes 8\n\nSample Input 2:\n\nppRYYGrrYB225\nYrR8RrY\n\nSample Output 2:\n\nNo 2\n\n思路： 使用数组或集合对每个颜色的个数进行记录，减去需要购买的值（且个数不为 0），不存在将 lack++；根据 lack 进行输出\n代码：\n#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std; int main()&#123;    unordered_map&lt;char, int&gt; mci;    string str1, str2;    cin &gt;&gt; str1 &gt;&gt; str2;    /* 数组下标标记法    int book[256];    for (int i = 0; i &lt; str1.length(); i++)        book[str1[i]]++;    int result = 0;    for (int i = 0; i &lt; str2.length(); i++)    &#123;        if (book[str2[i]] &gt; 0)            book[str2[i]]--;        else            result++;    &#125;    */    // 集合标记    for (int i = 0; i &lt; str1.length(); i++)    &#123;        if (mci.count(str1[i]))        &#123;            mci[str1[i]]++;        &#125;        else        &#123;            mci[str1[i]] = 1;        &#125;    &#125;    int lack = 0;    for (int i = 0; i &lt; str2.length(); i++)    &#123;        if (mci.count(str2[i]) &amp;&amp; mci[str2[i]] != 0)        &#123;            mci[str2[i]]--;        &#125;        else        &#123;            lack++;        &#125;    &#125;    if (!lack)    &#123;        cout &lt;&lt; &quot;Yes &quot; &lt;&lt; str1.length() - str2.length();    &#125;    else    &#123;        cout &lt;&lt; &quot;No &quot; &lt;&lt; lack;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1041\n题目：Be Unique\nBeing unique is so important to people on Mars that even their lottery is designed in a unique way. The rule of winning is simple: one bets on a number chosen from [1,104][1,10^4][1,104]. The first one who bets on a unique number wins. For example, if there are 7 people betting on {5 31 5 88 67 88 17}, then the second one who bets on 31 wins.\nInput Specification:\nEach input file contains one test case. Each case contains a line which begins with a positive integer N(≤105)N (≤10^5)N(≤105) and then followed by N bets. The numbers are separated by a space.\nOutput Specification:\nFor each test case, print the winning number in a line. If there is no winner, print None instead.\nSample Input 1:\n\n7 5 31 5 88 67 88 17\n\nSample Output 1:\n\n31\n\nSample Input 2:\n\n5 888 666 666 888 888\n\nSample Output 2:\n\nNone\n\n思路： 使用两个数组分别记录个数和输入顺序\n代码：\n#include &lt;iostream&gt;using namespace std;int flag[100001] = &#123;0&#125;, num[100000]; //flag 进行个数统计，num 记录输入顺序int main()&#123;    int n;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; num[i];        flag[num[i]]++; // 将输入的数作为下标自增    &#125;    bool f = true; // 判断是否有符合条件的值输出    for (int i = 0; i &lt; n; i++)    &#123;        if (flag[num[i]] == 1)        &#123;            cout &lt;&lt; num[i];            f = false; // 有输出            break;        &#125;    &#125;    if (f)    &#123;        cout &lt;&lt; &quot;None&quot;;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1050\n题目：String Subtraction\nGiven two strings S1 and S2, S=S1−S2S=S1−S2S=S1−S2 is defined to be the remaining string after taking all the characters in S2 from S1. Your task is simply to calculate S1−S2S1−S2S1−S2 for any given strings. However, it might not be that simple to do it fast.\nInput Specification:\nEach input file contains one test case. Each case consists of two lines which gives S1 and S2, respectively. The string lengths of both strings are no more than 10410^4104. It is guaranteed that all the characters are visible ASCII codes and white space, and a new line character signals the end of a string.\nOutput Specification:\nFor each test case, print S1−S2S1−S2S1−S2 in one line.\nSample Input:\n\nThey are students.\naeiou\n\nSample Output:\n\nThy r stdnts.\n\n思路： 使用数组以字符的 ASCII 码为下标标记 S1 中每个出现的字符值为 1，S2 出现的字符置为 0，遍历 S1 只输出标记数组值为 1 的字符\n代码：\n#include &lt;iostream&gt;using namespace std; int flag[256] = &#123;0&#125;; int main()&#123;    string str1, str2;     getline(cin, str1);     getline(cin, str2);     for (int i = 0; i &lt; str1.length(); i++)    &#123;        flag[str1[i]] = 1;     &#125;    for (int i = 0; i &lt; str2.length(); i++)    &#123;        flag[str2[i]] = 0;     &#125;    for (int i = 0; i &lt; str1.length(); i++)    &#123;        if (flag[str1[i]])        &#123;            cout &lt;&lt; str1[i];         &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1048\n题目：Find Coins\nEva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she could only use exactly two coins to pay the exact amount. Since she has as many as 10510^5105 coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find two coins to pay for it.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains 2 positive numbers: N(≤105N (≤10^5N(≤105, the total number of coins) and M(≤103M(≤10^3M(≤103, the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers no more than 500. All the numbers in a line are separated by a space.\nOutput Specification:\nFor each test case, print in one line the two face values V1 and V2 (separated by a space) such that V1+V2=MV1+V2=MV1+V2=M and V1≤V2V1≤V2V1≤V2. If such a solution is not unique, output the one with the smallest V1. If there is no solution, output No Solution instead.\nSample Input 1:\n\n8 15\n1 2 8 7 2 4 11 15\n\nSample Output 1:\n\n4 11\n\nSample Input 2:\n\n7 14\n1 8 7 2 4 11 15\n\nSample Output 2:\n\nNo Solution\n\n思路： 使用数组标记每个面值出现的次数，然后从 1 到 bill 对每一个面值进行遍历（规则就是从小到大），判断输出\n代码：\n#include &lt;iostream&gt;using namespace std;int flag[1001] = &#123;0&#125;; // 用来统计每个面值出现了几次int main()&#123;    int n, m, temp;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; temp;        flag[temp]++;    &#125;    for (int i = 1; i &lt; m; i++) // 对每个面值的硬币从小到大判断（保证输出规则）    &#123;        if (flag[i]) // 当前面值存在        &#123;            flag[i]--;       // 存在就 -1，防止出现一个数出现了一次但它的二倍等于 bill            if (flag[m - i]) // 符合相加条件的硬币也存在            &#123;                cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; m - i; // 输出                system(&quot;pause&quot;);                return 0;            &#125;            flag[i]++;        &#125;    &#125;    cout &lt;&lt; &quot;No Solution&quot;;    system(&quot;pause&quot;);    return 0;&#125;\n 贪心\n 思想解释\n总是做出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择\n 类型练习\n 1070\n题目：Mooncake\nMooncake is a Chinese bakery product traditionally eaten during the Mid-Autumn Festival. Many types of fillings and crusts can be found in traditional mooncakes according to the region’s culture. Now given the inventory amounts and the prices of all kinds of the mooncakes, together with the maximum total demand of the market, you are supposed to tell the maximum profit that can be made.\nNote: partial inventory storage can be taken. The sample shows the following situation: given three kinds of mooncakes with inventory amounts being 180, 150, and 100 thousand tons, and the prices being 7.5, 7.2, and 4.5 billion yuans. If the market demand can be at most 200 thousand tons, the best we can do is to sell 150 thousand tons of the second kind of mooncake, and 50 thousand tons of the third kind. Hence the total profit is 7.2+4.5/2=9.457.2 + 4.5/2 = 9.457.2+4.5/2=9.45 (billion yuans).\nInput Specification:\nEach input file contains one test case. For each case, the first line contains 2 positive integers N(≤1000)N(≤1000)N(≤1000), the number of different kinds of mooncakes, and D(≤500D(≤500D(≤500 thousand tons), the maximum total demand of the market. Then the second line gives the positive inventory amounts (in thousand tons), and the third line gives the positive prices (in billion yuans) of N kinds of mooncakes. All the numbers in a line are separated by a space.\nOutput Specification:\nFor each test case, print the maximum profit (in billion yuans) in one line, accurate up to 2 decimal places.\nSample Input:\n\n3 200\n180 150 100\n7.5 7.2 4.5\n\nSample Output:\n\n9.45\n\n思路： 使用结构体放入数组，根据单价排序，循环判断需求量计算收益\n代码：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std; struct Mooncake&#123;    double quality, single_price, total_price; // 全国用 double 型，防止精确度不够&#125;; int N, D; bool cmp(Mooncake a, Mooncake b) // 按单价排序&#123;    return a.single_price &gt; b.single_price;&#125;int main()&#123;    cin &gt;&gt; N &gt;&gt; D;     vector&lt;Mooncake&gt; mc(N);     for (int i = 0; i &lt; N; i++)    &#123;        cin &gt;&gt; mc[i].quality;     &#125;    for (int i = 0; i &lt; N; i++)    &#123;        cin &gt;&gt; mc[i].total_price;         mc[i].single_price = mc[i].total_price / mc[i].quality;     &#125;    sort(mc.begin(), mc.end(), cmp); // 输入后按照单价进行排序    double profit = 0.0;     int i = 0;     while (D &amp;&amp; i &lt; mc.size()) // 注意可能存在所有种类的总量不够需求量的情况    &#123;        if (D &gt; mc[i].quality)        &#123;            profit += mc[i].total_price; // 需求量仍超过当前种类的质量        &#125;        else        &#123;            profit += D * mc[i].single_price; // 不足将剩余量乘单价            break;         &#125;        D -= mc[i].quality; // 去掉已经购买的        i++; // 判断下一组    &#125;    printf(&quot;%.2f&quot;, profit);     system(&quot;pause&quot;);    return 0;&#125;\n 1033\n题目：To Fill or Not to Fill\nWith highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains 4 positive numbers: Cmax(≤100)Cmax (≤ 100)Cmax(≤100), the maximum capacity of the tank; D(≤30000)D(≤30000)D(≤30000), the distance between Hangzhou and the destination city; Davg(≤20)Davg (≤20)Davg(≤20), the average distance per unit gas that the car can run; and N(≤500)N(≤ 500)N(≤500), the total number of gas stations. Then N lines follow, each contains a pair of non-negative numbers: Pi, the unit gas price, and Di(≤D)D_i(≤D)Di​(≤D), the distance between this station and Hangzhou, for i=1,⋯,Ni=1,⋯,Ni=1,⋯,N. All the numbers in a line are separated by a space.\nOutput Specification:\nFor each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print The maximum travel distance = X where X is the maximum possible distance the car can run, accurate up to 2 decimal places.\nSample Input 1:\n\n50 1300 12 8\n6.00 1250\n7.00 600\n7.00 150\n7.10 0\n7.20 200\n7.50 400\n7.30 1000\n6.85 300\n\nSample Output 1:\n\n749.17\n\nSample Input 2:\n\n50 1300 12 2\n7.10 0\n7.00 600\n\nSample Output 2:\n\nThe maximum travel distance = 1200.00\n\n思路： 将终点也作为加油站的形式进行存储，对所有的加油站按照距离进行排序，每次从起点判断满油状态下可以到达的加油站中油价最便宜的一个，根据价格进行不同的处理\n代码：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;struct station // 加油站的结构体&#123;    double price, distance;&#125;;double Cmax, D, Davg;int N;station sta[501];bool cmp(station a, station b) // 将所有加油站按距离排序&#123;    return a.distance &lt; b.distance;&#125;int main()&#123;    cin &gt;&gt; Cmax &gt;&gt; D &gt;&gt; Davg &gt;&gt; N;    for (int i = 0; i &lt; N; i++)    &#123;        cin &gt;&gt; sta[i].price &gt;&gt; sta[i].distance;    &#125;    sta[N].price = 0;    sta[N].distance = D;     // 将终点作为加油站的形式方便循环处理    sort(sta, sta + N, cmp); // 按距离排序    if (sta[0].distance != 0) // 如果起点位置没有加油站    &#123;        cout &lt;&lt; &quot;The maximum travel distance = 0.00&quot;;    &#125;    else    &#123;        int now = 0;        double ans = 0, nowTank = 0, max_dis = Cmax * Davg;        while (now &lt; N) // 循环模拟每一个站        &#123;            int k = -1;            double minP = INT_MAX;            for (int i = now + 1; i &lt;= N &amp;&amp; sta[i].distance - sta[now].distance &lt;= max_dis; i++)            &#123; // 循环判断满油状态下的最长距离中油价最便宜的一个站                if (sta[i].price &lt; minP)                &#123;                    minP = sta[i].price;                    k = i;                    if (minP &lt; sta[now].price)                    &#123;                        break;                    &#125;                &#125;            &#125;            if (k == -1) // 没找到跳出            &#123;                break;            &#125;            double need = (sta[k].distance - sta[now].distance) / Davg; // 到最便宜站需要加的油            if (minP &lt;= sta[now].price)                                 // 又可以到达价格小于当前的站            &#123;                if (nowTank &lt; need) // 当前油箱无法到达                &#123;                    ans += (need - nowTank) * sta[now].price;                    nowTank = 0;                &#125;                else                &#123;                    nowTank -= need;                &#125;            &#125;            else            &#123;                ans += (Cmax - nowTank) * sta[now].price;                nowTank = Cmax - need;            &#125;            now = k;        &#125;        if (now == N)        &#123;            printf(&quot;%.2f&quot;, ans);        &#125;        else        &#123;            printf(&quot;The maximum travel distance = %.2f&quot;, sta[now].distance + max_dis);        &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125; \n 1037\n题目：Magic Coupon\nThe magic shop in Mars is offering some magic coupons. Each coupon has an integer N printed on it, meaning that when you use this coupon with a product, you may get N times the value of that product back! What is more, the shop also offers some bonus product for free. However, if you apply a coupon with a positive N to this bonus product, you will have to pay the shop N times the value of the bonus product… but hey, magically, they have some coupons with negative N’s!\nFor example, given a set of coupons {1 2 4 −1}, and a set of product values {7 6 −2 −3} (in Mars dollars M$) where a negative value corresponds to a bonus product. You can apply coupon 3 (with N being 4) to product 1 (with value M$7) to get M$28 back; coupon 2 to product 2 to get M$12 back; and coupon 4 to product 4 to get M$3 back. On the other hand, if you apply coupon 3 to product 4, you will have to pay M$12 to the shop.\nEach coupon and each product may be selected at most once. Your task is to get as much money back as possible.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains the number of coupons NC, followed by a line with NC coupon integers. Then the next line contains the number of products NP, followed by a line with NP product values. Here 1≤NC,NP≤1051≤N_C, N_P≤10^51≤NC​,NP​≤105, and it is guaranteed that all the numbers will not exceed 2302^{30}230.\nOutput Specification:\nFor each test case, simply print in a line the maximum amount of money you can get back.\nSample Input:\n\n4\n1 2 4 -1\n4\n7 6 -2 -3\n\nSample Output:\n\n43\n\n思路： 将两组数据放入两个数组，将数据从小到大排序，负数从小到大分别相乘，正数从大到小分别相乘，0 不做处理\n代码：\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std; int main()&#123;    int n, m;     cin &gt;&gt; n;     vector&lt;int&gt; coupon(n);     for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; coupon[i];     &#125;    cin &gt;&gt; m;     vector&lt;int&gt; product(m);     for (int i = 0; i &lt; m; i++)    &#123;        cin &gt;&gt; product[i];     &#125;    sort(coupon.begin(), coupon.end());     sort(product.begin(), product.end()); // 将数组从小到大排序    int i = 0, j = 0, ans = 0;     while (i &lt; n &amp;&amp; j &lt; m &amp;&amp; coupon[i] &lt; 0 &amp;&amp; product[j] &lt; 0) // 处理负数    &#123;        ans += coupon[i] * product[j];         i++;         j++;     &#125;    i = n - 1;     j = m - 1;     while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; coupon[i] &gt; 0 &amp;&amp; product[j] &gt; 0) // 处理正数    &#123;        ans += coupon[i] * product[j];         i--;         j--;     &#125;    cout &lt;&lt; ans;     system(&quot;pause&quot;);    return 0;&#125;\n 1067\n题目：Sort with Swap(0, i)\nGiven any permutation of the numbers {0, 1, 2,…, N−1}, it is easy to sort them in increasing order. But what if Swap(0, *) is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way:\nSwap(0, 1) =&gt; &#123;4, 1, 2, 0, 3&#125;Swap(0, 3) =&gt; &#123;4, 1, 2, 3, 0&#125;Swap(0, 4) =&gt; &#123;0, 1, 2, 3, 4&#125;\nNow you are asked to find the minimum number of swaps need to sort the given permutation of the first N nonnegative integers.\nInput Specification:\nEach input file contains one test case, which gives a positive N(≤105)N(≤10^5)N(≤105) followed by a permutation sequence of {0, 1, …, N−1}. All the numbers in a line are separated by a space.\nOutput Specification:\nFor each case, simply print in a line the minimum number of swaps need to sort the given permutation.\nSample Input:\n\n10\n3 5 7 2 6 4 9 0 8 1\n\nSample Output:\n\n9\n\n思路： 使用数字作为下标顺序，作为位置的方式存储数组，当每个位置上数字与位置相同表示交换完毕（这样无需进行下标查找）\n\n\n遍历位置与数字是否对应，当不对应且 0 未处于排列首位时交换 0 与本该在 0 的位置上的数字 swap(per[0], per[per[0]]); \n\n\n当 0 回到首位继续判断位置是否对应，若未成功将 0 换到不对应的位置继续判断操作\n\n\n代码：\n#include &lt;iostream&gt;using namespace std; int main()&#123;    int n;     cin &gt;&gt; n;     int per[n], temp, ans = 0;     for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; temp; // 将输入的数作为下标，第几次输入作为位置        per[temp] = i;     &#125;    for (int i = 0; i &lt; n; i++)    &#123;        if (i != per[i]) // 当各个数字没有归位        &#123;            while (per[0] != 0) //0 没有归位便进行调换            &#123;                swap(per[0], per[per[0]]); // 将 0 所在的位置和其应当存在的的数进行交换                ans++;             &#125;            if (i != per[i]) // 一轮调换未能匹配，将 0 换入不匹配的位置            &#123;                swap(per[0], per[i]);                 ans++;             &#125;        &#125;    &#125;    cout &lt;&lt; ans;     system(&quot;pause&quot;);    return 0;&#125;\n 1038\n题目：Recover the Smallest Number\nGiven a collection of number segments, you are supposed to recover the smallest number from them. For example, given\n{32,321,3214,0229,8732, 321, 3214, 0229, 8732,321,3214,0229,87}, we can recover many numbers such like 32−321−3214−0229−8732-321-3214-0229-8732−321−3214−0229−87 or 0229−32−87−321−32140229-32-87-321-32140229−32−87−321−3214 with respect to different orders of combinations of these segments, and the smallest number is 0229−321−3214−32−870229-321-3214-32-870229−321−3214−32−87.\nInput Specification:\nEach input file contains one test case. Each case gives a positive integer N(≤104)N (≤10^4)N(≤104) followed by N number segments. Each segment contains a non-negative integer of no more than 8 digits. All the numbers in a line are separated by a space.\nOutput Specification:\nFor each test case, print the smallest number in one line. Notice that the first digit must not be zero.\nSample Input:\n\n5 32 321 3214 0229 87\n\nSample Output:\n\n22932132143287\n\n思路： 采用字符串进行读取，定义一个等式相加的排序规则\n代码：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(string a, string b)&#123;    return a + b &lt; b + a; // 如果 a+b&lt;b+a，a 就在前面，否则反之&#125;int main()&#123;    int n;    cin &gt;&gt; n;    string str[n];    for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; str[i];    &#125;    sort(str, str + n, cmp);    string ans;    for (int i = 0; i &lt; n; i++)    &#123;        ans += str[i]; // 拼接排序后的字符数组    &#125;    while (ans.length() != 0 &amp;&amp; ans[0] == &#x27;0&#x27;) // 去掉前导零    &#123;        ans.erase(ans.begin());    &#125;    if (ans.length() == 0)    &#123;        cout &lt;&lt; 0;    &#125;    else    &#123;        cout &lt;&lt; ans;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 二分\n 思想解释\n在有序的排列中，根据目标值 goal 与中间值 mid (mid=(end+begin)/2mid=(end+begin)/2mid=(end+begin)/2) 的大小关系不断缩小范围的查找方式\nmid 的求值：有些数据长度过大，导致 end+beginend+beginend+begin 超出当前数据类型的范围，可以采用 mid=begin+(end−begin)/2mid=begin+(end-begin)/2mid=begin+(end−begin)/2 的式子\n常使用 [algorithm] 下的 upper_bound(lower_bound) 和 binary_search 方法\n 类型练习\n 1085\n题目：Perfect Sequence\nGiven a sequence of positive integers and another positive integer p. The sequence is said to be a perfect sequence if M≤m×pM≤m×pM≤m×p where M and m are the maximum and minimum numbers in the sequence, respectively.\nNow given a sequence and a parameter p, you are supposed to find from the sequence as many numbers as possible to form a perfect subsequence.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains two positive integers N and p, where N(≤105)N (≤10^5)N(≤105) is the number of integers in the sequence, and p(≤109)p (≤10^9)p(≤109) is the parameter. In the second line there are N positive integers, each is no greater than 10910^9109.\nOutput Specification:\nFor each test case, print in one line the maximum number of integers that can be chosen to form a perfect subsequence.\nSample Input:\n\n10 8\n2 3 20 4 5 1 6 7 8 9\n\nSample Output:\n\n8\n\n思路： 将输入的数据从小到大排序，遍历每一个数将它作为 m 计算 M，使用 upper_bound() 函数求出  完美队列  的长度，取长度最大值\n注意：数据范围为 10910^9109那么 m×pm×pm×p可能溢出 int 型，所以使用 long long 强转\n代码：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std; int main()&#123;    int n, p;     cin &gt;&gt; n &gt;&gt; p;     int arr[n];     for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; arr[i];     &#125;    sort(arr, arr + n); // 从小到大排序    int ans = 1;     for (int i = 0; i &lt; n; i++)    &#123; // 从数组的开始每次找一个数作为 m 进行判断        int bound = upper_bound(arr, arr + n, (long long)arr[i] * p) - arr;         //arr[i] 作为 m 时符合完美队列条件的长度        ans = max(ans, bound - i); // 保留最大长度    &#125;    cout &lt;&lt; ans;     system(&quot;pause&quot;);    return 0;&#125;\n 1010\n题目：Radix\nGiven a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is yes, if 6 is a decimal number and 110 is a binary number.\nNow for any pair of positive integers N1N1N1 and N2N2N2, your task is to find the radix of one number while that of the other is given.\nInput Specification:\nEach input file contains one test case. Each case occupies a line which contains 4 positive integers:\n\nN1 N2 tag radix\n\nHere N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set {0-9, a-z } where 0-9 represent the decimal numbers 0-9, and a-z represent the decimal numbers 10-35. The last number radix is the radix of N1 if tag is 1, or of N2 if tag is 2.\nOutput Specification:\nFor each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print Impossible. If the solution is not unique, output the smallest possible radix.\nSample Input 1:\n\n6 110 1 10\n\nSample Output 1:\n\n2\n\nSample Input 2:\n\n1 ab 1 2\n\nSample Output 2:\n\nImpossible\n\n思路： 将确定进制的数转换为十进制，将为判断的数采用二分法来确定进制；一个数的进制越大，转换为十进制的结果越大：101 的二进制为 5，但十六进制为 272\n\n\n编写一个转换函数，其中要解决字符映射问题，手动转换十进制思路：反向循环相加 当前数×指数的位数幂\n\n\n编写查找进制函数，其中要解决的时上下界的确定，下界 low 为单个位最大数 +1，上界 height 位 max(low, 要求数字的十进制），每次二分 binary(low,height)binary(low,height)binary(low,height)作为指数转换为十进制，如果得到的数为负数（过大溢出）或超过要求数字的十进制，表示当前进制过大，否者过小，每次更换范围，直到相等\n\n\n代码：\n#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;long long convert(string str, long long radix)&#123; // 将已经确定进制的数转换为十进制    int decimal = 0;    int temp = 0, index = 0;    for (auto it = str.rbegin(); it != str.rend(); it++)    &#123;        temp = isdigit(*it) ? *it - &#x27;0&#x27; : *it - &#x27;a&#x27; + 10;        decimal += temp * pow(radix, index++);    &#125;    return decimal;&#125;long long findresult(string str, long long decimal)&#123;    char it = *max_element(str.begin(), str.end());// 使用函数求出 ASCII 码最大的字符    long long low = (isdigit(it) ? it - &#x27;0&#x27; : it - &#x27;a&#x27; + 10) + 1;// 确定下界    long long height = max(low, decimal);// 确定上界    while (low &lt;= height)// 二分判断    &#123;        long long mid = low + (height - low) / 2;        long long temp = convert(str, mid);        if (temp &lt; 0 || temp &gt; decimal) //t 小于 0 表示溢出        &#123;            height = mid - 1;        &#125;        else if (temp == decimal)        &#123;            return mid;// 相等返回 mid 作为指数        &#125;        else        &#123;            low = mid + 1;        &#125;    &#125;    return -1;// 不存在返回 -1&#125;int main()&#123;    string s1, s2;    long long tag = 0, radix = 0, result_radix;    cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; tag &gt;&gt; radix;    if (s1 == s2)// 如果输入直接相等，输出给定的指数    &#123;        cout &lt;&lt; radix;    &#125;    else    &#123;        result_radix = (tag == 1) ? findresult(s2, convert(s1, radix)) : findresult(s1, convert(s2, radix));        if (result_radix == -1)        &#123;            cout &lt;&lt; &quot;Impossible&quot;;        &#125;        else        &#123;            cout &lt;&lt; result_radix;        &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1044\n题目：Shopping in Mars\nShopping in Mars is quite a different experience. The Mars people pay by chained diamonds. Each diamond has a value (in Mars dollars M). When making the payment, the chain can be cut at any position for only once and some of the diamonds are taken off the chain one by one. Once a diamond is off the chain, it cannot be taken back. For example, if we have a chain of 8 diamonds with values M 3,2,1,5,4,6,8,73, 2, 1, 5, 4, 6, 8, 73,2,1,5,4,6,8,7, and we must pay M 15. We may have 3 options:\n\n\nCut the chain between 4 and 6, and take off the diamonds from the position 1 to 5\nwith values 3+2+1+5+4=153+2+1+5+4=153+2+1+5+4=15\n\n\nCut before 5 or after 6, and take off the diamonds from the position 4 to 6 (with values 5+4+6=155+4+6=155+4+6=15).\n\n\nCut before 8, and take off the diamonds from the position 7 to 8 (with values 8+7=158+7=158+7=15).\n\n\nNow given the chain of diamond values and the amount that a customer has to pay, you are supposed to list all the paying options for the customer.\nIf it is impossible to pay the exact amount, you must suggest solutions with minimum lost.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains 2 numbers: N (≤105), the total number of diamonds on the chain, and M(≤108)M (≤10^8)M(≤108), the amount that the customer has to pay. Then the next line contains N positive numbers D1⋯DN(Di≤103foralli=1,⋯,N)D1⋯DN (Di≤10^3 for all i=1, ⋯, N)D1⋯DN(Di≤103foralli=1,⋯,N) which are the values of the diamonds. All the numbers in a line are separated by a space.\nOutput Specification:\nFor each test case, print i-j in a line for each pair of i ≤ j such that D i + … + D j = M. Note that if there are more than one solution, all the solutions must be printed in increasing order of i .\nIf there is no solution, output i-j for pairs of i ≤ j such that D i + … + D j &gt;M with (D i + … + D j −M) minimized. Again all the solutions must be printed in increasing order of i .\nIt is guaranteed that the total value of diamonds is sufficient to pay the given amount.\nSample Input 1:\n\n16 15\n3 2 1 5 4 6 8 7 16 10 15 11 9 12 14 13\n\nSample Output 1:\n\n1-5\n4-6\n7-8\n11-11\n\nSample Input 2:\n\n5 13\n2 4 5 7 9\n\nSample Output 2:\n\n2-4\n4-5\n\n思路： 序列的和是有序递增的，因此一个连续序列和的右端减去左端就是该子序列的和 (must pay)\n\n\n对有序序列可以采用二分查找的方式，遍历左端点，二分查找右端点，查找值是 &gt;=m，因为可能有无法匹配求最小损失的情况\n\n\n方法函数的参数可以使用 (int i, int &amp;j, int &amp;tempsum)的方式直接改变 j 和 tempsum 的值\n\n\n代码：\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; int n, m; vector&lt;int&gt; sum, resultArr; void Func(int i, int &amp;j, int &amp;tempsum) // 二分就目标值&#123;    int left = i, right = n;    while (left &lt; right)    &#123;        int mid = left + (right - left) / 2;        if (sum[mid] - sum[i - 1] &gt;= m) // 不一定完全匹配，求较大的最小值        &#123;            right = mid;        &#125;        else        &#123;            left = mid + 1;        &#125;    &#125;    j = right;    tempsum = sum[j] - sum[i - 1];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    sum.resize(n + 1);    sum[0] = 0;    for (int i = 1; i &lt;= n; i++)    &#123;        cin &gt;&gt; sum[i];        sum[i] += sum[i - 1];    &#125;    int minans = sum[n];    for (int i = 1; i &lt;= n; i++) // 遍历所有数字作为左端点    &#123;        int j, tempsum;        Func(i, j, tempsum);  // 挨个二分查找        if (tempsum &gt; minans) // 如果过大下一次循环        &#123;            continue;        &#125;        if (tempsum &gt;= m) // 符合条件        &#123;            if (tempsum &lt; minans) // 有更接近目标值的数字便更新集合            &#123;                resultArr.clear();                minans = tempsum;            &#125;            resultArr.push_back(i);            resultArr.push_back(j);        &#125;    &#125;    for (int i = 0; i &lt; resultArr.size(); i += 2)    &#123;        cout &lt;&lt; resultArr[i] &lt;&lt; &quot;-&quot; &lt;&lt; resultArr[i + 1] &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 双指针\n 思想解释\n使用两个指针指向序列的不同位置，用指针的移动操作减少处理复杂度的方式\n其中归并排序和快速排序都可以使用双指针的方式进行编写\n\n\n归并排序： 常使用的多为二路归并排序，将一组数分为两两一组进行组内排序，再将每组两两合并进行排序，以此类推\n\n\n快速排序： 每次挑选一个数字作为比较参照，将大于参照数的值放入右侧，小于放左侧\n\n\n 类型练习\n 1089\n题目：Insert or Merge\nAccording to Wikipedia:\nInsertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.\nMerge sort works as follows: Divide the unsorted list into N sublists, each containing 1 element (a list of 1 element is considered sorted). Then repeatedly merge two adjacent sublists to produce new sorted sublists until there is only 1 sublist remaining.\nNow given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?\nInput Specification:\nEach input file contains one test case. For each case, the first line gives a positive integer N (≤100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.\nOutput Specification:\nFor each test case, print in the first line either “Insertion Sort” or “Merge Sort” to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.\nSample Input 1:\n\n10\n3 1 2 8 7 5 9 4 6 0\n1 2 3 7 8 5 9 4 6 0\n\nSample Output 1:\n\nInsertion Sort\n1 2 3 5 7 8 9 4 6 0\n\nSample Input 2:\n\n10\n3 1 2 8 7 5 9 4 0 6\n1 3 2 8 5 7 4 9 0 6\n\nSample Output 2:\n\nMerge Sort\n1 2 3 8 4 5 7 9 0 6\n\n思路： 先判断是否为插入排序，如果不是则一定是归并排序\n\n\n建立两个初始数组，和目标数组，初始数组中一个用于插入排序，一个用于归并排序\n\n\n注意初始数组不能直接和目标数组相同，否者容易出现双解\n\n\n代码：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int origin[100], tempOri[100], changed[100]; // 初始数组，初始备份，目标数组int n;bool isSame(int a[], int b[]) // 判断数组相同&#123;    for (int i = 0; i &lt; n; i++)    &#123;        if (a[i] != b[i])        &#123;            return false;        &#125;    &#125;    return true;&#125;void showArr(int a[]) // 输出方法&#123;    for (int i = 0; i &lt; n - 1; i++)    &#123;        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; a[n - 1];&#125;bool insertSort() // 使用布尔型，返回 false 表示其为归并&#123;    bool flag = false;    for (int i = 1; i &lt; n; i++) // 从第二个元素开始插入    &#123;        if (i != 1 &amp;&amp; isSame(tempOri, changed)) // 抛开第一次即相同的情况下相同        &#123;            flag = true; // 判断相同再排序一次，方便输出 next 序列        &#125;        // 插入排序核心代码        int j = i, temp = tempOri[i];        while (j != 0 &amp;&amp; tempOri[j - 1] &gt; temp)        &#123;            tempOri[j] = tempOri[j - 1];            j--;        &#125;        tempOri[j] = temp;        if (flag) // 当判断成功直接跳出        &#123;            break;        &#125;    &#125;    return flag;&#125;void mergeSort() // 不是插入排序直接使用归并方法&#123;    bool flag = false;    for (int step = 2; step / 2 &lt;= n; step *= 2) // 归并的遍历方式    &#123;        if (step != 2 &amp;&amp; isSame(origin, changed)) // 抛开第一次即相同的情况下相同        &#123;            flag = true;        &#125;        for (int i = 0; i &lt; n; i += step) // 对每组进行排序        &#123;            sort(origin + i, origin + min(i + step, n)); // 直接使用 sort 方法即可        &#125;        if (flag)        &#123;            showArr(origin);            break; // 在循环中结束记得跳出        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; origin[i];        tempOri[i] = origin[i];    &#125;    for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; changed[i];    &#125;    if (insertSort())    &#123;        cout &lt;&lt; &quot;Insertion Sort&quot; &lt;&lt; endl;        showArr(tempOri);    &#125;    else    &#123;        cout &lt;&lt; &quot;Merge Sort&quot; &lt;&lt; endl;        mergeSort();    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1029\n** 题目：Median **\nGiven an increasing sequence S of N integers, the median is the number at the middle position. For example, the median of S1=11,12,13,14S1 = {11, 12, 13, 14}S1=11,12,13,14 is 12, and the median of S2=9,10,15,16,17S2 = {9, 10, 15, 16, 17}S2=9,10,15,16,17 is 15. The median of two sequences is defined to be the median of the nondecreasing sequence which contains all the elements of both sequences. For example, the median of S1 and S2 is 13.\nGiven two increasing sequences of integers, you are asked to find their median.\nInput Specification:\nEach input file contains one test case. Each case occupies 2 lines, each gives the information of a sequence. For each sequence, the first positive integer N(≤2×105)N (≤2×10^5)N(≤2×105) is the size of that sequence. Then N integers follow, separated by a space. It is guaranteed that all the integers are in the range of long int.\nOutput Specification:\nFor each test case you should output the median of the two given sequences in a line.\nSample Input:\n\n4 11 12 13 14\n5 9 10 15 16 17\n\nSample Output:\n\n13\n\n思路： 只需要输出中位数而无需对整个序列进行处理，所以不必采用合并后排序的方式进行判断，使用双指针判断相应位置\n\n\n设置 i、j 两个指针分别指向两个数组，每次判断较小值后指针后移，当后移次数为 medianPosition=(N+M−1)÷2medianPosition=(N+M-1)÷2medianPosition=(N+M−1)÷2输出\n\n\n可能存在一个数组的整体数字过于小导致真个数组全部判断完成，两个指针的移动次数和还未到达中位数，所以要在数组的后边界设置一个较大数，int 型最大为 231−12^{31}-1231−1（代码可以写作 0x7fffffff或 (1&lt;&lt;31)-1）的形式\n\n\n最后到达中位位置时，两个数的值还未进行判断，再次判断指针输出较小值\n\n\n代码：\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; int main()&#123;    vector&lt;int&gt; sequeN, sequeM;    int temp;    int n;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; temp;        sequeN.push_back(temp);    &#125;    int m;    cin &gt;&gt; m;    for (int i = 0; i &lt; m; i++)    &#123;        cin &gt;&gt; temp;        sequeM.push_back(temp);    &#125;    int median = (n + m - 1) / 2;    sequeN[n] = sequeM[m] = (1 &lt;&lt; 31) - 1;// 将数组边界设置为 2^31-1    int i = 0, j = 0, count = 0;    while (count &lt; median)    &#123;        if (sequeN[i] &lt; sequeM[j])        &#123;            i++;        &#125;        else        &#123;            j++;        &#125;        count++;    &#125;    if (sequeN[i] &lt; sequeM[j])    &#123;        cout &lt;&lt; sequeN[i];    &#125;    else    &#123;        cout &lt;&lt; sequeM[j];    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 其他\n 思想解释\n\n打表： 将小范围结果计算出来，直接在程序中调用，用空间换时间\n递推： 大部分算法都是有递推规则的，根据规则编写仅适合这一道题的程序\n随机选择：有点玄学\n\n 类型练习\n 1093\n题目：Count PAT’s\nThe string APPAPT contains two PAT’s as substrings. The first one is formed by the 2nd, the 4th, and the 6th characters, and the second one is formed by the 3rd, the 4th, and the 6th characters.\nNow given any string, you are supposed to tell the number of PAT’s contained in the string.\nInput Specification:\nEach input file contains one test case. For each case, there is only one line giving a string of no more than 105 characters containing only P, A, or T.\nOutput Specification:\nFor each test case, print in one line the number of PAT’s contained in the string. Since the result may be a huge number, you only have to output the result moded by 1000000007.\nSample Input:\n\nAPPAPT\n\nSample Output:\n\n2\n\n思路： 根据递推思想，组成 &quot;PAT&quot; 的个数就是字符’A’左边’P’的个数乘右边’T’的个数\n\n\n遍历字符串求出每个字符左边 P 的个数\n\n\n反向遍历，遇到 T 计数器 +1，遇到 A 累加相乘取模\n\n\n代码：\n#include &lt;iostream&gt;using namespace std;const int mod = 1000000007;int main()&#123;    string str;    cin &gt;&gt; str;    int len = str.length();    int countP[100000] = &#123;0&#125;;    for (int i = 0; i &lt; len; i++) // 获取每个位置左侧字符 &#x27;P&#x27; 的个数    &#123;        if (i &gt; 0)        &#123;            countP[i] = countP[i - 1];        &#125;        if (str[i] == &#x27;P&#x27;)        &#123;            countP[i]++;        &#125;    &#125;    int ans = 0, countT = 0;    for (int i = len - 1; i &gt;= 0; i--)    &#123;        if (str[i] == &#x27;T&#x27;)        &#123;            countT++; // 累计 T        &#125;        if (str[i] == &#x27;A&#x27;) // 遇到 &#x27;A&#x27; 便相加取模        &#123;            ans = (ans + countT * countP[i]) % mod;        &#125;    &#125;    cout &lt;&lt; ans;    system(&quot;pause&quot;);    return 0;&#125;\n 1101\n题目：Quick Sort\nThere is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition?\nFor example, given N=5 and the numbers 1, 3, 2, 4, and 5. We have:\n\n\n1 could be the pivot since there is no element to its left and all the elements to its right are larger than it;\n\n\n3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well;\n\n\n2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well;\n\n\nand for the similar reason, 4 and 5 could also be the pivot.\n\n\nHence in total there are 3 pivot candidates.\nInput Specification:\nEach input file contains one test case. For each case, the first line gives a positive integer N (≤105). Then the next line contains N distinct positive integers no larger than 109. The numbers in a line are separated by spaces.\nOutput Specification:\nFor each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.\nSample Input:\n\n5\n1 3 2 4 5\n\nSample Output:\n\n3\n1 4 5\n\n思路： 双向遍历，保留每个数字左边的最大值和右边的最小值，最后遍历判断是否大于左边最大值并小于右边最小值\n代码：\n#include &lt;iostream&gt;using namespace std; int main()&#123;    int n;     cin&gt;&gt;n;     int leftMax[n], rightMin[n], arr[n];     int ans[n], num = 0;     for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; arr[i];     &#125;    leftMax[0] = 0;     for (int i = 1; i &lt; n; i++)    &#123;        leftMax[i] = max(leftMax[i - 1], arr[i - 1]);     &#125;    rightMin[n - 1] = 0x3fffffff;     for (int i = n - 2; i &gt;= 0; i--)    &#123;        rightMin[i] = min(rightMin[i + 1], arr[i + 1]);     &#125;    for (int i = 0; i &lt; n; i++)    &#123;        if (leftMax[i] &lt; arr[i] &amp;&amp; rightMin[i] &gt; arr[i])        &#123;            ans[num++] = arr[i];         &#125;    &#125;    cout &lt;&lt; num &lt;&lt; endl;     for (int i = 0; i &lt; num; i++)    &#123;        cout &lt;&lt; ans[i];         if (i &lt; num - 1)        &#123;            cout &lt;&lt; &quot; &quot;;         &#125;    &#125;    cout &lt;&lt; endl;     system(&quot;pause&quot;);    return 0;&#125;\n","categories":["算法"],"tags":["C/C++"]},{"title":"蓝桥杯普及题","url":"/lan_qiao-common_question/","content":"\n\n之前参加蓝桥杯竞赛时候刷的算法题，蓝桥杯虽然一年比一年难，但是每年的题多少都有往届真题的影子，这些题不说是精华吧，但因为不是按类型刷的，所以题型涵盖度，知识点广度都是有的，我当时刷完之后就感觉有点进门槛了\n\n 判断素数\n题目：\n用筛选法求 0~N 之间的素数\n输入：\n\nN\n\n输出：\n\n0~N 之间的所有素数，用回车进行分割\n\n思路：\n\n直接使用 for() 循环在遍历每一个数，使用封装好的判断方法进行判断即可\n使用素数打表的方式根据数据规模建立一个素数表，直接通过下标的进行输出即可\n\n代码：\nimport java.util.Scanner;public class Main &#123;    static boolean judge(int x) &#123;// 素数判断函数        boolean flag = true;// 使用单一出口        if (x &lt;= 1) &#123;            flag = false;        &#125;        for (int i = 2; i &lt;= (int) Math.sqrt((double) x); i++) &#123;// 因子在 2 到其开根之间            if (x % i == 0) &#123;                flag = false;            &#125;        &#125;        return flag;    &#125;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int N = scanner.nextInt();        for (int i = 1; i &lt; N; i++) &#123;            if (judge(i)) &#123;                System.out.print(i + &quot; &quot;);            &#125;        &#125;    &#125;&#125;\n 字符串 I/O\n题目：\n输入：\n首先输入一个不大于 100 的整数 N；\n之后输入大于 N 行的字符串，字符串可以包含空格；\n字符串个数不大于 1000。\n输出：\n前 N 行按原样输出；后边的字符串按空格或回车以每行的形式输出且每行之间输出一个空行\n思路：\n按行输入那就要用到nextline(), nextline 不同于 next 的一点就是：next 读取到空格就结束；nextline 读取到换行结束\n输出的字符串大于 N, 所以还需要使用 hasnext() 方法来判断不明确的输入\n代码：\nimport java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int N = scanner.nextInt();        scanner.nextLine();// 截取输入 N 之后的换行符        for (int i = 0; i &lt; N; i++) &#123;            String str = scanner.nextLine();            System.out.println(str);// 获取整行直接输出        &#125;        while (scanner.hasNext()) &#123;// 还有输入在进行            String s = scanner.next();            System.out.println(s);        &#125;    &#125;&#125;\n 蛇形矩阵\n题目：\n蛇形矩阵是由 1 开始的自然数依次排列成的一个矩阵上三角形。\n输入：\n本题有多组数据，每组数据由一个正整数 N 组成 (N&lt;=100)\n输出：\n对于每一组数据，输出一个 N 行的蛇形矩阵\n两组输出之间不要额外的空行，行尾不要多余的空格\n矩阵三角中同一行的数字用一个空格分开\n输入样例：\n\n5\n\n输出样例：\n\n1 3 6 10 15\n2 5 9 14\n4 8 13\n7 12\n11\n\n思路：\n首先要搞清楚输出的规律：\n\n输出每行的列数以 N-1 递减\n每列第一个数为 1 开始差为 +1 的等差数列\n每行为 2 开始差为 +1 的等差数列\n根据 2、3 条可以将行差与列差关联起来，然后双重循环嵌套\n\n代码：\nimport java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int N = scanner.nextInt();        int row = 1, subR = 1;//row 为每行的首元素，subR 为每行首元素的差        for (int i = N; i &gt;= 0; i--) &#123;// 反向遍历方便控制列数            int column = row, subC = subR + 1;// 每列首元素为每行的首元素，列差为行差 +1            for (int j = 0; j &lt; i; j++) &#123;                System.out.print(column);                if (j != i - 1) &#123;// 注意行尾空格                    System.out.print(&quot; &quot;);                &#125;                column += subC;                subC++;            &#125;            System.out.println();            row += subR;            subR++;        &#125;    &#125;&#125;\n DNA\n题目：\n输入包含多组测试数据，根据输入的组数和每组的数据打印出目标图形\n输入：\n第一个整数 N(N&lt;=15) 表示组数，每组数据包含两个整数 a,b; 其中 a(3&lt;=a&lt;=39) 表示一个单位的 DNA 串的行数，恒为奇数。b(1&lt;=b&lt;=20) 表示重复度\n输出：\n输出 DNA 的形状，每组输出间有空行，行尾没有多余的空格\n样例输入：\n\n２\n3 1\n5 4\n\n样例输出：\nX X XX XX   X X X  X X XX   X X X  X X XX   X X X  X X XX   X X X  X X XX   X\n思路：\n\n每组分布是有规律的：\n\nX 的分布：row == column || row == a - column - 1\n空格的分布：row &gt; column || row &lt; a - column - 1\n\n\n根据分布规律将每个字符存入 a 行 a 列的字符数组中，然后根据组数进行输出\n\n代码：\nimport java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int N = scanner.nextInt();// 读取组数        while (0 != N--) &#123;// 设置 N 组数据的循环            int a, b;            a = scanner.nextInt();            b = scanner.nextInt();            char[][] map = new char[a][a];// 建立一个 a 行 a 列的字符数组            // 根据分布规则进行赋值            for (int i = 0; i &lt; a; i++) &#123;                for (int j = 0; j &lt; a; j++) &#123;                    if (i == j || i == a - j - 1) &#123;                        map[i][j] = &#x27;X&#x27;;                    &#125; else if (i &gt; j || i &lt; a - j - 1) &#123;                        map[i][j] = &#x27; &#x27;;                    &#125; else &#123;// 出现两个 X 之后的字符赋予 N，这样的目的是输出时有所判断不会输出多余的空格                        map[i][j] = &#x27;N&#x27;;                    &#125;                &#125;            &#125;            for (char c : map[0]) &#123;// 输出第一行，第一行只可能为 X 或空格                System.out.print(c);            &#125;            System.out.println();            for (int i = 0; i &lt; b; i++) &#123;// 根据重复度从第二行开始输出                for (int j = 1; j &lt; a; j++) &#123;                    for (char tempC : map[j]) &#123;                        if (tempC != &#x27;N&#x27;) &#123;// 输出每行不为 N 的字符                            System.out.print(tempC);                        &#125;                    &#125;                    System.out.println();                &#125;            &#125;        &#125;    &#125;&#125;\n IP 判断\n题目：\n判断一个 IP 字符串的合法性。合法的 IP 是这样的形式：A.B.C.D，其中 A、B、C、D 均为位于 [0, 255] 中的整数\n为了简单起见，我们规定这四个整数中不允许有前导零存在，如 001 这种情况\n输入：\n输入由多行组成，每行是一个字符串，输入由“End of file”结束\n输出：\n对于每一个输入，单独输出一行，如果该字符串是合法的 IP，输出 Y，否则，输出 N\n样例输入：\n\n1.2.3.4\na.b.c.d\n267.43.64.12\n12.34.56.bb\n210.43.64.129\n-123.4.5.6\n\n样例输出：\n\nY\nN\nY\nN\n\n思路：\n\n通过字符串获取一行用 split() 方法根据 ‘.’ 进行分割成字符串数组\n判断时需要将字符串转换为 Int 型，可以使用 Integer.parseInt(String s) 的方法，但如果不全是数字会报错，加一个异常抛出，如果捕获到异常说明不符合 IP 规范，无异常进行范围的判断\n\n代码：\nimport java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        while (scanner.hasNextLine()) &#123;            String str = scanner.nextLine();            if (&quot;End of file&quot;.equals(str)) &#123;// 遇到 End of file 程序结束                break;            &#125;            String[] arr = str.split(&quot;\\\\.&quot;);// 分割使用转义字符的方式            boolean flag = true;            for (String s : arr) &#123;                try &#123;                    if (Integer.parseInt(s) &gt; 255 || Integer.parseInt(s) &lt; 0) &#123;                        flag = false;                        break;                    &#125;                &#125; catch (Exception e) &#123;// 非数字转换出错，令 flag 为 false                    flag = false;                    break;                &#125;            &#125;            if (flag) &#123;                System.out.println(&#x27;Y&#x27;);            &#125; else &#123;                System.out.println(&#x27;N&#x27;);            &#125;        &#125;    &#125;&#125;\n Tom 数\n题目：\n正整数的各位数字之和被 Tom 称为 Tom 数\n输入一个数 N(N&lt;232N&lt;2^{32}N&lt;232)，求 N 的 Tom 数\n输入：\n每行输入一个整数 N\n输出：\n每行一个输出，对应 N 的各位数之和\n样例输入：\n\n12345\n56123\n82\n\n样例输出：\n\n15\n17\n10\n\n思路：\n使用字符串获取每行输入的 N，使用 charAt() 的方式进行字符的遍历，遍历出的每个数字减去 0 的 ASCII 码获得这个数字本身的值相加即可\n代码：\nimport java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        while (scanner.hasNext()) &#123;            String str = scanner.next();            int sum = 0;            for (int i = 0; i &lt; str.length(); i++) &#123;                sum += str.charAt(i)-&#x27;0&#x27;;// 这里的 -&#x27;0&#x27; 是减去 0 的 ASCII 码得到数字            &#125;            System.out.println(sum);        &#125;    &#125;&#125;\n 分糖果\n题目：\n有 n 个小朋友围坐成一圈，老师给每个小朋友随机发偶数个糖果，然后进行下面的游戏：\n每个小朋友都把自己的糖果分一半给左手边的孩子。\n一轮分糖后，拥有奇数颗糖的孩子由老师补给 1 个糖果，从而变成偶数\n反复进行这个游戏，直到所有小朋友的糖果数都相同为止\n你的任务是预测在已知的初始糖果情形下，老师一共需要补发多少个糖果\n输入：\n首先读入一个整数 N(2&lt;N&lt;1002&lt;N&lt;1002&lt;N&lt;100)，表示小朋友的人数\n接着是一行用空格分开的 N 个偶数（每个偶数不大于 1000，不小于 2)\n输出：\n要求程序输出一个整数，表示老师需要补发的糖果数。\n样例输入：\n\n3\n2 2 4\n\n样例输出：\n\n4\n\n思路：\n\n用数组的方式进行存储每人的糖果，分糖果时可以采用每人减半加后边人的一半，注意运算前先保存第一人的值\n每个人手中的糖果数更新后进行奇数判断，进行相应操作\n\n代码：\nimport java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int N = scanner.nextInt();        int[] arr = new int[N];        for (int i = 0; i &lt; N; i++) &#123;            arr[i] = scanner.nextInt();        &#125;        int count = 0;        while (judge(arr) != true) &#123;            int frist = arr[0];            for (int i = 0; i &lt; arr.length - 1; i++) &#123;                arr[i] = arr[i] / 2 + arr[i + 1] / 2;                if (arr[i] % 2 != 0) &#123;                    arr[i]++;                    count++;                &#125;            &#125;            arr[N - 1] = arr[N - 1] / 2 + frist / 2;            if (arr[N - 1] % 2 != 0) &#123;                arr[N - 1]++;                count++;            &#125;        &#125;        System.out.println(count);    &#125;    public static boolean judge(int[] temp) &#123;        boolean flag = true;        for (int i = 0; i &lt; temp.length; i++) &#123;            if (temp[i] != temp[0]) &#123;                flag = false;            &#125;        &#125;        return flag;    &#125;&#125;\n 判断回文数\n题目：\n本题要求你找到一些 5 位或 6 位的十进制回文数字\n满足要求：该数字的各个数位之和等于输入的整数\n输入：\n一个正整数 n(10&lt;n&lt;10010&lt;n&lt;10010&lt;n&lt;100)，表示要求满足的数位和\n输出：\n若干行，每行包含一个满足要求的 5 位或 6 位整数\n数字按从小到大的顺序排列\n如果没有满足条件的，输出：-1\n思路：\n\n因为要对每位进行相加判断，用遍历的方式就效率太低了，要求的值为 5/6 位，可以嵌套三重循环，每层遍历 1~9，若能够达到以下条件就输出\n\n五位：2*a+2*b+c==n那么就可以输出a+b+c+b+a\n六位同理\n\n\n从 1~9 进行遍历，自然满足从小到大的排列\n设置一个计数器，在没有符合条件的值出现时输出 &quot;-1&quot;\n\n代码：\nimport java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int N = scanner.nextInt();        int count = 0;        for (int i = 1; i &lt; 10; i++) &#123;            for (int j = 0; j &lt; 10; j++) &#123;                for (int k = 0; k &lt; 10; k++) &#123;                    if (2 * i + 2 * j + k == N) &#123;                        System.out.println(&quot;&quot; + i + j + k + j + i);                        count++;                    &#125;                &#125;            &#125;        &#125;        for (int i = 1; i &lt; 10; i++) &#123;            for (int j = 0; j &lt; 10; j++) &#123;                for (int k = 0; k &lt; 10; k++) &#123;                    if (2 * i + 2 * j + 2 * k == N) &#123;                        System.out.println(&quot;&quot; + i + j + k + k + j + i);                        count++;                    &#125;                &#125;            &#125;        &#125;        if (count == 0) &#123;            System.out.println(-1);        &#125;    &#125;&#125;\n 数字游戏\n题目：\n游戏的规则是这样的：栋栋和同学们一共 n 个人围坐在一圈。栋栋首先说出数字 1。接下来，坐在栋栋左手边的同学要说下一个数字 2。再下面的一个同学要从上一个同学说的数字往下数两个数说出来，也就是说 4。下一个同学要往下数三个数，说 7。依次类推。\n为了使数字不至于太大，栋栋和同学们约定，当在心中数到 k-1 时，下一个数字从 0 开始数。例如，当 k=13 时，栋栋和同学们报出的前几个数依次为：\n\n1、2、4、7、11、3、9、3、11\n\n游戏进行了一会儿，栋栋想知道，到目前为止，他所有说出的数字的总和是多少。\n栋栋说出的数依次为 1、7、9，和为 17\n输入：\n输入的第一行包含三个整数 N、K、T，其中 N 和 K 的意义如上面所述，T 表示到目前为止栋栋一共说出的数字个数\n输出：\n输出一行，包含一个整数，表示栋栋说出所有数的和\n思路：\n\n栋栋一共说了 T 个数，所以只要把这 T 个数相加即可，无需管其他的数，已知 T1 为 1，这样只需 for(i=1;i&lt;t;i++) 执行 T-1 次即可\n数字之间的差为 +1 的等差数列，这样可以找出规律求 T2、T3···\n\n可以将所有的数看成 N 个人一组，总共 T 组，每组的指定报数就是就是上一组的指定数加当前组等差数列的和\n公式为T(m)=(((a+a+n-1)*n/2)+T(m-1))%k;\n\n\n\n代码：\nimport java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int N = scanner.nextInt();        int K = scanner.nextInt();        int T = scanner.nextInt();        long a = 1, An = 1, sum = An;// 注意 int 型会溢出        for (int i = 0; i &lt; T - 1; i++) &#123;// 已将首项加入 sum 中            An = (((a + a + N - 1) * N / 2) + An) % K;// 按组加差            sum += An;            a += N;// 将首项值加 N 作为下一组的首项        &#125;        System.out.println(sum);    &#125;&#125;\n 分核桃\n题目：\n有 3 个开发组，打算给每个组发一袋核桃要求是：\n\n\n各组的核桃数量必须相同\n各组内必须能平分核桃\n尽量提供满足 1,2 条件的最小数量\n\n\n输入：\n输入包含三个正整数 a、b、c 表示每个组正在加班的人数，用空格分开 (a,b,c&lt;30a,b,c&lt;30a,b,c&lt;30)\n输出；\n输出一个正整数，表示每袋核桃的数量\n思路：\n其实就是求最小公倍数，因为 a,b,c&lt;30，所以核桃数量最多不会超过Math.pow(30,3)\n代码：\nimport java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int a = scanner.nextInt();        int b = scanner.nextInt();        int c = scanner.nextInt();        for (int i = 0; i &lt; Math.pow(30, 3); i++) &#123;            if (i &gt;= a &amp;&amp; i &gt;= b &amp;&amp; i &gt;= c) &#123;                if (i % a == 0 &amp;&amp; i % b == 0 &amp;&amp; i % c == 0) &#123;                    System.out.println(i);                    break;                &#125;            &#125;        &#125;    &#125;&#125;\n 蚂蚁感冒\n题目：\n长 100 厘米的细长直杆子上有 n 蚂蚁。它们的头有的朝左，有的朝右\n每只蚂蚁都只能沿着杆子向前爬，速度是每秒 1cm\n当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行\n这些蚂蚁中，有 1 只蚂蚁感冒了，并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁\n请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒\n输入：\n第一行输入一个整数 n(1&lt;n&lt;501&lt;n&lt;501&lt;n&lt;50)，表示蚂蚁的总数\n接着的一行是 n 个用空格分开的整数 Xi(−100&lt;Xi&lt;100-100&lt;X_i&lt;100−100&lt;Xi​&lt;100)，Xi 的绝对值，表示蚂蚁离开杆子左边端点的距离。正值表示头朝右，负值表示头朝左，数据中不会出现 0 值，也不会出现两只蚂蚁占用同一位置。其中，第一个数据代表的蚂蚁感冒了\n输出：\n要求输出 1 个整数，表示最后感冒蚂蚁的数目\n样例输入：\n\n5\n-10 8 -20 12 25\n\n样例输出：\n\n3\n\n思路：\n\n每个蚂蚁速度相同，所以不存在后边的蚂蚁感冒追上前边蚂蚁的情况发生，而且与感冒的蚂蚁（叫做 X）相对的一定会被感染\n被感染的蚂蚁与 X 没有任何区别，那么掉头可以看作两只蚂蚁碰头后穿过继续走\n当 X 传染给相对蚂蚁后，被传染的蚂蚁继续走的情况下就又会传染给与他相对的其他蚂蚁，反之也相同\n那么可以分左右进行判断，对 X 以外的蚂蚁依次读入，判断是否与 X 相对，除了相对会被传染外还有跟随在 X 后边的蚂蚁，当有被 X 传染的蚂蚁就表示跟随 X 的蚂蚁也会被传染，需要将跟随的蚂蚁数量记录下来，最后判断是否需要添加\n\n代码：\nimport java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int N = scanner.nextInt();        int first = scanner.nextInt();        int sum = 1, next = 0;        boolean flag = false;        while (--N != 0) &#123;            int temp = scanner.nextInt();            if (first &gt; 0) &#123;// 当感冒的蚂蚁朝右                if (Math.abs(temp) &gt; first &amp;&amp; temp &lt; 0) &#123;// 与其相对时必感冒                    flag = true;                    sum++;                &#125; else if (temp &lt; first &amp;&amp; temp &gt; 0) &#123;// 在其后边跟随的                    next++;                &#125;            &#125;            if (first &lt; 0) &#123;// 感冒蚂蚁朝左                if (Math.abs(temp) &lt; Math.abs(first) &amp;&amp; temp &gt; 0) &#123;// 与其相对时必感冒                    flag = true;                    sum++;                &#125; else if (temp &lt; first) &#123;                    next++;                &#125;            &#125;        &#125;        sum += flag ? next : 0;        System.out.println(sum);    &#125;&#125;\n 错误票据\n题目：\n某涉密单位下发了某种票据，并要在年终全部收回。每张票据有唯一的 ID 号，所有票据的 ID 号是连续的，但 ID 的开始数码是随机选定的。因为工作人员疏忽，在录入 ID 号的时候发生了一处错误，造成了某个 ID 断号，另外一个 ID 重号。通过编程，找出断号的 ID 和重号的 ID\n假设断号不可能发生在最大和最小号\n输入：\n要求程序首先输入一个整数 N(N&lt;100N&lt;100N&lt;100) 表示后面数据行数\n接着读入 N 行数据，每行数据长度不等，是用空格分开的若干个（不大于 100 个）正整数（不大于 100000)，请注意行内和行末可能有多余的空格，你的程序需要能处理这些空格\n每个整数代表一个 ID 号。\n输出：\n要求程序输出 1 行，含两个整数 m 表示断号，n 表示重号\n样例输入：\n\n2\n5 6 8 11 9\n10 12 9\n\n样例输出：\n\n7 9\n\n思路：\n主要解决的输入格式，因为是输入不同行，所以可以实例化 A、B 两个 Scanner 对象，用 A 获取每行，用 B 拆解 A 的每行数据，然后排序判断即可\n代码：\nimport java.util.Arrays;import java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int N = scanner.nextInt();        scanner.nextLine();// 抵消 N 后面的换行符        int[] arr = new int[10000];        int count = 0, interrupt = 0, repeat = 0;        for (int i = 0; i &lt; N; i++) &#123;            Scanner input = new Scanner(scanner.nextLine());// 获取每行            while (input.hasNext()) &#123;// 遍历每行数据                arr[count++] = input.nextInt();            &#125;        &#125;        Arrays.sort(arr, 0, count);        for (int begin = arr[0], i = 0; i &lt; count; i++) &#123;            if (begin != arr[i]) &#123;                if (arr[i] - arr[i - 1] == 2) &#123;                    interrupt = arr[i] - 1;                    begin = arr[i];                &#125;                if (arr[i] == arr[i - 1]) &#123;                    repeat = arr[i];                    begin = arr[i];                &#125;            &#125;            begin++;        &#125;        System.out.println(interrupt + &quot; &quot; + repeat);    &#125;&#125;\n FJ 的字符串\n题目：\nFJ 在沙盘上写了这样一些字符串：\n\nA1  =  “A”\nA2  =  “ABA”\nA3  =  “ABACABA”\nA4  =  “ABACABADABACABA”\n··· ···\n\n输入：\n仅有一个数：N(N≤26N≤26N≤26)\n输出：\n请输出相应的字符串ANA_NAN​，以一个换行符结束\n样例输入：\n\n3\n\n样例输出：\n\nABACABA\n\n思路：\n字符串变长，避免内存冗余的情况使用 StringBuilder 比较好，使用循环配合 ASCII 码即可，注意 StringBuilder 每次拼接返回的都是自身所以每次循环时保存一下之前的字符串（使用 char[] 数组节约空间）\n代码：\nimport java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int N = scanner.nextInt();        var sb = new StringBuilder();        sb.append(&#x27;A&#x27;);        for (int i = 1; i &lt; N; i++) &#123;            char[] temp = sb.toString().toCharArray();//StringBuilder 每次拼接返回自身，先保存一下            sb.append((char) (65 + i)).append(temp);        &#125;        System.out.println(sb);    &#125;&#125;\n 分解质因数\n题目：\n求出区间 a,b(2≤a≤b≤100002≤a≤b≤100002≤a≤b≤10000) 中所有整数的质因数分解\n输入：\n输入两个整数 a,b\n输出：\n每行输出一个数的分解，形如 k=a1a2a3···\n样例输入：\n\n3 10\n\n样例输出：\n\n3=3\n4=22\n5=5\n6=23\n7=7\n8=222\n9=33\n10=25\n\n思路：\n\n质因数分解，就是最后的因子全部变为质数，那这样还需要判断质数本身\n创建从 a-&gt;b 的循环，赋值于临时变量 t，t 可能重复分解，所以这里用 while 循环\n如果 while 循环判断不能进行时继续 fori 循环，直至 t==i 时说明最大的素数因子已然出现\n\n代码：\nimport java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int a = scanner.nextInt();        int b = scanner.nextInt();        for (int i = a; i &lt;= b; i++) &#123;            int temp = i;            System.out.print(temp + &quot;=&quot;);// 输出开头            for (int j = 2; j &lt;= temp; j++) &#123;                while (temp % j == 0 &amp;&amp; temp != j) &#123;// 防止除数和被除数相等进入死循环                    System.out.print(j + &quot;*&quot;);                    temp /= j;                &#125;                if (temp == j) &#123;// 相等表示分解完毕                    System.out.println(j);                &#125;            &#125;        &#125;    &#125;&#125;\n 合并链表\n题目：\n给出两个有序链表，将其合并为一个链表后仍然有序\n思路：\n使用递归对每一个节点进行比对总是返回较小值\n代码：\npublic class Test &#123;    public static void main(String[] args) &#123;        Node head1 = new Node(3);        Node head2 = new Node(4);        Node h1Next1 = new Node(5);        Node h2Next1 = new Node(6);        Node h1Next2 = new Node(7);        Node h2Next2 = new Node(8);        Node h1Next3 = new Node(10);        head1.next = h1Next1;        h1Next1.next = h1Next2;        h1Next2.next = h1Next3;        head2.next = h2Next1;        h2Next1.next = h2Next2;        merTwoList(head1, head2);        Node temp = head1;        for (int i = 0; i &lt; 7; i++) &#123;            System.out.print(temp.data + &quot; &quot;);            temp = temp.next;        &#125;    &#125;    static Node merTwoList(Node one, Node two) &#123;        if (one == null &amp;&amp; two == null) &#123;            return null;        &#125;        if (one == null) &#123;            return two;        &#125;        if (two == null) &#123;            return one;        &#125;        Node head;        if (one.data &gt; two.data) &#123;            head = two;            head.next = merTwoList(one, two.next);        &#125; else &#123;            head = one;            head.next = merTwoList(two, one.next);        &#125;        return head;    &#125;&#125;class Node &#123;    public int data;    public Node next;    public Node(int data) &#123;        this.data = data;    &#125;&#125;\n 打乱数组\n题目：\n编写一个程序，将数据中的所有数据随机打乱，确保每一个数据都被更换过\n思路：\n在循环中，使用生成随机数与当前所剩未打乱数据的个数相乘，找出一个符合数组范围的随机数作为下标，将其与当前循环变量的值做下标的数据相调换\n代码：\npublic class Test &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;1, 2, 3, 4, 5, 6, 7&#125;;        int len = arr.length;        for (int i = 0; i &lt; arr.length; i++) &#123;            int t = (int) (Math.random() * len--);// 长度乘随机数确保每个值都被更换到            int temp = arr[i];            arr[i] = arr[t];            arr[t] = temp;        &#125;        for (int each : arr) &#123;            System.out.println(each);        &#125;    &#125;&#125;\n 等差公式吗？\n题目：\n给定一个无序数组，判断其是否是一个等差数列（要求时间复杂度为 On)\n思路：\n有时间复杂度的约束可以使用公式来考虑，遍历一遍找出其中的最大最小值然后求出差 d(d=max−minlength−1)d(d=\\frac{max-min}{length-1})d(d=length−1max−min​)，再遍历一遍判断每个值减去 minminmin 后是否能整除 ddd\n代码：\nimport java.util.Arrays;import java.util.Collections;public class Test &#123;    public static void main(String[] args) &#123;        Integer[] arr = &#123;2, 4, 6, 7, 10&#125;;        var min = (int)Math.floor(Collections.min(Arrays.asList(arr)));        var max = (int)Math.floor(Collections.max(Arrays.asList(arr)));        var d = (max - min) / (arr.length - 1);        boolean flag = true;        for (Integer each : arr) &#123;            if (0 != (each - min) % d) &#123;                flag = false;                break;            &#125;        &#125;        System.out.println(flag);    &#125;&#125;\n 字符串对比\n题目：\n给定两个仅由大写字母或小写字母组成的字符串（长度介于 1 到 10 之间），它们之间的关系是以下四种情况之一：\n\n\n两个字符串长度不等。比如 Beijing 和 Hebei\n两个字符串不仅长度相等，而且相应位置上的字符完全一致（区分大小写），比如 Beijing 和 Beijing\n两个字符串长度相等，相应位置上的字符仅在不区分大小写的前提下才能达到完全一致（也就是说，它并不满足情况 2)，比如  beijing 和 BEIjing\n两个字符串长度相等，但是即使是不区分大小写也不能使这两个字符串一致。比如 Beijing 和 Nanjing\n\n\n编程判断输入的两个字符串之间的关系属于这四类中的哪一类，给出所属的类的编号\n输入：\n包括两行，每行都是一个字符串\n输出：\n仅有一个数字，表明这两个字符串的关系编号\n样例输入：\n\nBEIjing\nbeiJing\n\n样例输出：\n\n3\n\n思路：\n\n四个条件相加就是全集，所以最后的条件 4 无需判断\n引用 String 类中的实用方法 .equals() 和.compareToIgnoreCase()\n定义一个 num 变量用来记录符合的条件，先判断长度，长度相同直接将 num 赋值为 4，然后进行 2、3 的判断\n\n代码：\nimport java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String str1 = scanner.next();        String str2 = scanner.next();        int num;        if (str1.length() != str2.length()) &#123;            num = 1;        &#125; else &#123;            num = 4;            if (str1.equals(str2)) &#123;                num = 2;            &#125;            if (0 == str1.compareToIgnoreCase(str2)) &#123;                num = 3;            &#125;        &#125;        System.out.println(num);    &#125;&#125;\n 完美的代价\n题目：\n回文串才是完美的\n现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串\n交换的定义是：交换两个相邻的字符\n\n例如 mamad\n第一次交换 ad : mamda\n第二次交换 md : madma\n第三次交换 ma : madam （回文！完美！)\n\n输入：\n第一行是一个整数 N，表示接下来的字符串的长度 (N≤8000N≤8000N≤8000)\n第二行是一个字符串，只包含小写字母\n输出：\n如果可能，输出最少的交换次数\n否则输出Impossible\n样例输入：\n\n5\nmamad\n\n样例输出：\n\n3\n\n思路：\n\n分支判断，先判断什么情况下不可能组成回文数：当出现奇数次字符的个数超过 2 次\n剩下的情况一定能够组成回文数，模拟的时间复杂度太高，直接用字符串删除的方式判断\n\n判断第一个出现的字符最后一次出现是在什么位置，将二者直接删除，计算出字符从最后出现的位置到串尾需要换几次，累加后继续递归判断\n如果有个字符出现了奇数次，在几次删除后（也可能初始时）就只有这一个字符处于串首，这种情况直接舍掉，累加其对换到串中需要的次数\n最后字符串的长度小于等于 2 时无需调换，以此为递归出口\n\n\n\n代码：\nimport java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int N = scanner.nextInt();        String str = scanner.next();        var arr = new char[N];        arr = str.toCharArray();        int oddCount = 0;        int[] flagArr = new int[26];        for (char c : arr) &#123;            flagArr[c - &#x27;a&#x27;]++;// 记录每个字符出现的次数        &#125;        for (int k : flagArr) &#123;            if (k % 2 != 0) &#123;                oddCount++;// 记录出现奇数次字符的个数            &#125;        &#125;        if (oddCount &gt; 1) &#123;            System.out.println(&quot;Impossible&quot;);        &#125; else &#123;            System.out.println(getCount(str));        &#125;    &#125;    static int getCount(String str) &#123;// 使用递归进行判断        int count = 0;        if (str.length() == 1 || str.length() == 2) &#123;            return count;// 长度小于等于 2 时，无需移动        &#125;        // 取字符串第一个字符最后一次出现的位置        int temp = str.lastIndexOf(str.charAt(0));        if (temp == 0) &#123;            // 恰好第一个数就是奇数，截取后面的继续判断            count = (str.length() / 2) + getCount(str.substring(1));            // 假设将首位的唯一奇数放到中间了        &#125; else &#123;            //0 号位字符和已找到 temp 位置的字符都移除，然后进行递归            StringBuilder strBuilder = new StringBuilder(str);            strBuilder.deleteCharAt(temp);            strBuilder.deleteCharAt(0);            count = str.length() - 1 - temp + getCount(strBuilder.toString());        &#125;        return count;    &#125;&#125;\n 报时助手\n题目：\n给定当前的时间，请用英文的读法将它读出来\n时间用时 h 和分 m 表示，在英文的读法中，读一个时间的方法是：\n如果 m 为 0，则将时读出来，然后加上 “o’clock”，如 3:00 读作 “three  o’clock”\n如果 m 不为 0，则将时读出来，然后将分读出来，如 5:30 读作 “five thirty”\n时和分的读法使用的是英文数字的读法，其中 0~20 读作：\n\n0:zero,  1:  one,  2:two,  3:three,  4:four,  5:five,  6:six,  7:seven,  8:eight,  9:nine,  10:ten,  11:eleven,  12:twelve,  13:thirteen,  14:fourteen,  15:fifteen,  16:sixteen,  17:seventeen,  18:eighteen,  19:nineteen,  20:twenty, 30:thirty, 40:forty, 50:fifty\n对于大于 20 小于 60 的数字，首先读整十的数，然后再加上个位数，如 31 首先读 30 再加 1 的读法，读作 “thirty one”\n按上面的规则 21:54 读作 “twenty one fifty four”，9:07 读作 “nine seven”，0:15 读作 “zero fifteen”\n\n输入：\n输入包含两个非负整数 h 和 m，表示时间的时和分。非零的数字前没有前导 0。h 小于 24，m 小于 60。\n输出：\n输出时间时刻的英文\n样例输入：\n\n0 15\n\n样例输出：\n\nzero fifteen\n\n思路：\n\n先定义一个字符串数组存储既定输出（0~20）；两个变量：h,m 将两个分开判断\n\n无论 m 的值为任何数，h 并不会受影响（只是输出 o'clock 的不同）\nh 在 0 和 24 之间，但其实字符串数组的大小只有 21，所以判断 h 是否小于 21，小于输出对应下标的字符串，否则先输出 twenty 然后 h-20，再输出 s[h]\n\n\n然后判断 m，当 m==0 时输出 o'clock，否则跟 h 一样同理判断，但 m 在 0~60 之间，所以在 20 之后进行每次 + 10 的区间判断\n\n代码：\nimport java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        int h = in.nextInt();        int m = in.nextInt();        String[] s = &#123;&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;,                &quot;nine&quot;, &quot;ten&quot;, &quot;eleven&quot;, &quot;twelve&quot;, &quot;thirteen&quot;, &quot;fourteen&quot;, &quot;fifteen&quot;,                &quot;sixteen&quot;, &quot;seventeen&quot;, &quot;eighteen&quot;, &quot;nineteen&quot;, &quot;twenty&quot;&#125;;        // 处理时的输出        if (h &gt;= 21) &#123;            System.out.print(&quot;twenty&quot;);            h = h - 20;        &#125;        System.out.print(s[h] + &quot; &quot;);        // 处理分的输出        if (m == 0) &#123;            System.out.print(&quot;o&#x27;clock&quot;);        &#125; else if (m &lt; 21) &#123;            System.out.print(s[m]);        &#125; else if (m &lt; 30) &#123;            System.out.print(&quot;twenty&quot;);            m = m - 20;            System.out.print(s[m]);        &#125; else if (m == 30) &#123;            System.out.print(&quot;thirty&quot;);        &#125; else if (m &lt; 40) &#123;            System.out.print(&quot;thirty&quot;);            m = m - 30;            System.out.print(s[m]);        &#125; else if (m == 40) &#123;            System.out.print(&quot;forty&quot;);        &#125; else if (m &lt; 50) &#123;            System.out.print(&quot;forty&quot;);            m = m - 40;            System.out.print(s[m]);        &#125; else if (m == 50) &#123;            System.out.print(&quot;fifty&quot;);        &#125; else if (m &lt; 60) &#123;            System.out.print(&quot;fifty&quot;);            m = m - 50;            System.out.print(s[m]);        &#125;    &#125;&#125;\n 龟兔赛跑预测\n题目：\n一旦任意秒结束后兔子发现自己领先 t 米或以上，它们就会停下来休息 s 秒，对于不同的兔子，t，s 的数值是不同的，但是所有的乌龟却是不到终点不停止\n然而有些比赛相当漫长，全程观看会耗费大量时间，而小华发现只要在每场比赛开始后记录下兔子的速度 v1/ 秒，乌龟的速度 v2/ 秒，以及兔子对应的 t、s 值，以及赛道的长度 l，就能预测出比赛的结果\n输入：\n输入只有一行，包含用空格隔开的五个正整数 v1、v2、t、s、l，其中数据范围为：v1,v2≤100;t≤300;s≤10;l≤10000v1,v2≤100;t≤300;s≤10;l≤10000v1,v2≤100;t≤300;s≤10;l≤10000且为 v1、v2 的公倍数\n输出：\n输出包含两行，第一行输出比赛结果：“T” 或 “R” 或 “D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点\n第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）\n样例输入：\n\n10 5 5 2 20\n\n样例输出：\n\nD\n4\n\n思路：\n\n分别为兔子和乌龟设置属性：当前时间和当前路程，只要二者都未到达终点便一直循环模拟\n当兔子超过乌龟 t 米时直接进行时间跳转到 s 秒之后的处理，可能存在不需 s 秒乌龟就到达终点，判断一下\n\n代码：\nimport java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int v1, v2, t, s, l;        v1 = scanner.nextInt();        v2 = scanner.nextInt();        t = scanner.nextInt();        s = scanner.nextInt();        l = scanner.nextInt();        int timeT = 0;        int timeR = 0;        int sT = 0;        int sR = 0;        while (sT &lt; l &amp;&amp; sR &lt; l) &#123;// 只要没有到达终点就一直循环            if (sR - sT &lt; t) &#123;// 兔子没超过位置就按秒模拟                timeR++;                timeT++;                sR += v1;                sT += v2;            &#125; else &#123;// 按 s 的时长相加                timeR += s;                timeT += s;                sT += s * v2;                if ((sT &gt; l) &amp;&amp; ((sT - l) / v2 &gt; 0)) &#123;// 存在乌龟过线不需要 s 秒的情况                    timeT -= (sT - l) / v2;                    sT = timeT * v2;                    break;                &#125;            &#125;        &#125;        if (sT == sR) &#123;            System.out.println(&quot;D\\n&quot; + timeR);        &#125; else if (sT &gt; sR) &#123;            System.out.println(&quot;T\\n&quot; + timeT);        &#125; else &#123;            System.out.println(&quot;R\\n&quot; + timeR);        &#125;    &#125;&#125;\n 数组替换\n题目：\n该函数将数组 b 的前 n 个元素追加到数组 a 的前 m 个元素后，假定数组 a 具有至少存放 m+n 个元素的空间\n例如，如果数组 a 为{22,33,44,55,66,77,88,99}，数组 b 为{20,30,40,50,60,70,80,90}，则调用 Add(a,5,b,3) 后，将把数组 a 变为{22,33,44,55,66,20,30,40}\n注意数组 b 并没有改变，而且数组 a 中只需改变 n 个元素。\n输入：\n第一行输入 a、b 数组的长度，第二、三行输入数组的元素，最后输入 m、n 表示 a 数组的 m 元素后替换为 b 数组的前 n 个元素\n输出：\n最后数组 a 中的元素，两个元素之间以逗号隔开\n\n样例输入 *\n\n\n8 8\n1 2 3 4 5 6 7 8\n9 10 11 12 13 14 15 16\n4 5\n\n样例输出：\n\n1,2,3,4,9,10,11,12,13\n\n思路：\n将 a 数组长度设置为两数组长度的总和，操作后根据长度判断输出即可\n代码：\nimport java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        int m = in.nextInt();        int n = in.nextInt();        int b[] = new int[n];        int a[] = new int[m + n];// 注意数组大小        for (int i = 0; i &lt; m; i++) &#123;            a[i] = in.nextInt();        &#125;        for (int i = 0; i &lt; n; i++) &#123;            b[i] = in.nextInt();        &#125;        int m1 = in.nextInt();        int n1 = in.nextInt();        int temp = m1;        for (int i = 0; i &lt; n1; i++) &#123;            a[temp++] = b[i];        &#125;        if (m - m1 &lt; n1)            m = m1 + n1;// 改变之后 a 数组的大小        for (int i = 0; i &lt; m - 1; i++) &#123;            System.out.print(a[i] + &quot;,&quot;);        &#125;        System.out.print(a[m - 1]);    &#125;&#125;\n 质数的积\n此题考查模除公式的应用\n\n(a+b) mod n=((a mod n)+(b mod n)) mod n;\n(a - b) mod n=((a mod n)-(b mod n)+ n) mod n;\nab mod n =(a mod n)(b mod n) mod n;\n\n题目：\n算出前 n 个质数的乘积（只要算出这个数模上 50000 的值）\n输入：\n仅包含一个正整数 n，其中 n&lt; =100000\n输出：\n输出一行，即前 n 个质数的乘积模 50000 的值\n样例输入\n\n1\n\n样例输出：\n\n2\n\n思路：\n使用计数器进行 N 个数的判断，是质数与积相乘取余即可\n代码：\nimport java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int N = scanner.nextInt();        int i = 2, count = 0;        long product = 1;        while (count &lt; N) &#123;// 从 2 开始遍历，等计数器到 N 时停止循环            boolean flag = true;            for (int j = 2; j * j &lt;= i; j++) &#123;// 判断质数的另一种方式                if (i % j == 0) &#123;                    flag = false;                    break;                &#125;            &#125;            if (flag) &#123;                product = product * i % 50000;                count++;            &#125;            i++;        &#125;        System.out.println(product);    &#125;&#125;\n 乘法运算\n题目：\n从键盘读入 2 个 100 以内的正整数，进行乘法运算并以竖式输出\n样例输入：\n16  8\n样例输出：\n  16×  8━━━━ 128\n8×16=128，则第四行 128 右侧对准个位输出\n再例如：87x76\n  87× 76━━━━ 522609━━━━6612\n输入：\n输入只有一行，是两个用空格隔开的数字，均在 1~99 之间\n输出：\n输出为 4 行或 7 行，符合乘法的竖式运算格式（乘号和下划线为特殊符号）\n思路：\n\n首先输出 “x” 和 “━━━” 此类的特殊字符，都应该从题目中复制，要不然出错\n因为输出需要对齐，空格不能适用于多种状况，所以采用 “%nd” 的方式输出\n输出为 4 或 7 行，主要是根据乘数是否为两位数决定，所以要设置一个 b&gt;=10 的判断语句\n如果乘数的个位是 0 那么直接输出 “00” 即可\n\n代码：\nimport java.util.Scanner;public class Test &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int a = sc.nextInt();        int b = sc.nextInt();        System.out.printf(&quot;%4d\\n×%3d\\n&quot;, a, b);        System.out.println(&quot;━━━&quot;);        if (b &gt;= 10) &#123;            if (b % 10 == 0) &#123;                System.out.println(&quot;00&quot;);            &#125; else &#123;                System.out.printf(&quot;%4d\\n&quot;, (b % 10) * a);            &#125;            System.out.printf(&quot;%3d\\n━━━\\n%4d\\n&quot;, (b / 10) * a, a * b);        &#125;    &#125;&#125;\n 五次方数\n题目：\n对一个数十进制表示时的每一位数字乘五次方再求和，会得到一个数的五次方数\n例如：1024 的五次方数为 1+0+32+1024=1057\n有这样一些神奇的数，它的五次方数就是它自己，而且这样的数竟然只有有限多个\n从小到大输出所有这样的数\n思路：\n因为是有限数，所以首先要判断它的边界\n\n上边界：十进制数中最大的是 9，而 95=59049, 是一个五位数，那最大不会超过每一位都为 9 时的五次方数，也就是 5*95=295245，而当位数是 6 或者大于 6 的时候，不论每一位的数是几，它本身的五次方数永远不会超过这个数本身，就没有了相等的可能，所以 295245 是理论上的最大值，这里的边界用实际上最大的六位数 999999 来表示\n下边界：0，1 不符合条件，所以可以直接从两位数开始，下边界为 10\n\n代码：\npublic class Test &#123;    public static void main(String[] args) &#123;        for (int i = 10; i &lt; 999999; i++) &#123;            int t1 = i % 10, t2 = i / 10 % 10, t3 = i / 100 % 10, t4 = i / 1000 % 10, t5 = i / 10000 % 10, t6 = i / 100000;            if (Math.pow(t1, 5) + Math.pow(t2, 5) + Math.pow(t3, 5)                    + Math.pow(t4, 5) + Math.pow(t5, 5) + Math.pow(t6, 5) == i) &#123;                System.out.println(i);            &#125;        &#125;    &#125;&#125;\n 分发口罩\n题目：\n某市市长获得了若干批口罩，每一批口罩的数目如下：\n\n9090400\n8499400\n5926800\n8547000\n4958200\n4422600\n5751200\n4175600\n6309600\n5865200\n6604400\n4635000\n10663400\n8087200\n4554000\n\n现在市长要把口罩分配给市内的 2 所医院。由于物流限制，每一批口罩只\n能全部分配给其中一家医院。市长希望 2 所医院获得的口罩总数之差越小越好。\n请你计算这个差最小是多少？\n思路：\n对于这种需要多次分情况进行判断每种组合的题目使用双重循环是无法进行的，每次分给谁又会引出不同的分支，如二叉树\n这样到达第十五次的时候，的得到的结果是 2142^{14}214 种\n所以使用分支型 DFS 进行判断，当达到相应层数时，判断当前的差与之前求出的最小值比较\n差的判断：abs(a−b)=abs(a+b−2×a)abs(a-b)=abs(a+b-2×a)abs(a−b)=abs(a+b−2×a)\nimport java.util.Scanner;public class Test &#123;    // 定义在静态空间方便 DFS 方法调用    static int cnt = Integer.MAX_VALUE, sum = 0, value[] = new int[15];    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        for (int i = 0; i &lt; 15; i++) &#123;            sum += value[i] = scanner.nextInt();        &#125;        dfs(14, 0);        System.out.println(cnt);    &#125;    static void dfs(int next, int v) &#123;        if (next &lt; 0) &#123;// 到达层数判断            cnt = Math.min(cnt, Math.abs(sum - v - v));        &#125; else &#123;// 每次分支模拟            dfs(next - 1, v + value[next]);            dfs(next - 1, v);        &#125;    &#125;&#125;","categories":["算法"],"tags":["Java"]},{"title":"PAT 甲级 - 数学问题","url":"/pat_level_a-math_problem/","content":"\n\n 数学可以提高思维能力，而算法最需要的就是思维能力，所以数学和算法题总是绕不开的，PAT 中就有专门的数学类型题但只是将需要大量计算的数学题用算法的方式进行解答，但还是有一部分题做到了很好的结合。举个不恰当的例子：圆的面积就是将其不断分割成可以用来计算的矩形和三角形，按照数学的思路就是用圆周率，而算法就是模拟切割的过程不断计算（当然实际肯定不是这样），不过计算机被创造出来的初衷好像就是做这种事 \n\n 思想解释 \n 简单数学 \n 一些不需要算法，仅仅使用基础数学知识的问题，一般考察的逻辑数理能力 \n 公约公倍数 \nint gcd(int a, int b)&#123; // 求最大公约数     return !b ? a : gcd(b, a % b);&#125;\n 最小公倍数：(a×b)/gcd(a,b)(a×b)/gcd(a,b)(a×b)/gcd(a,b)\n 分数 \n 分数的存储一般使用结构体的方式 \nstruct Fraction&#123;    int up,down;&#125;;\n 至于其运算也是使用不同的公式对分数的分子分母进行操作 \n 分数许多情况下需要化简，其化简过程有三个：\n\n\n 判断 down 是否为负数，是则使分子和分母都变为其相反数 \n\n\n 判断分子是否为 0，是则分母化为 1\n\n\n 求分子和分母的绝对值是否有最大公约数，有则转换为除公约数的情况 \n\n\n 分数的输出有多种情况，输出前必须化简 \n\n\n 需要判断分母是否为 1，是则输出整数 \n\n\n 分子的绝对值大于分母，则是一个假分数，输出带分数的形式 \n\n\n 素数 \n 判断代码：\nbool isPrime(int a)&#123;    if (a &lt;= 1)    &#123;        return false;    &#125;    int sqr = (int)sqrt(1.0 * a);    for (int i = 2; i &lt;= sqr; i++)    &#123;        if (a % i == 0)        &#123;            return false;        &#125;    &#125;    return true;&#125;\n 手动表：\nvector&lt;int&gt; prime(50000, 1);for (int i = 2; i * i &lt; 50000; i++)&#123; // 根据特性，将不是素数的置为 0    for (int j = 2; j * i &lt; 50000; j++)    &#123;        prime[j * i] = 0;    &#125;&#125;\n 质因子 \n 一个整数被分解成一个或多个质数的乘积，但是质因子相乘到 29 时 (2×3×⋅⋅⋅×292×3×···×292×3×⋅⋅⋅×29) 就已经超过了 int 型的范围，所以保存因子的数组大小为 10 即可 \n 大数存储与运算 \n 大数使用读入字符串，反向存储到 int 数组中，运算根据规则定义即可 \n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std; struct bign // 定义大数结构体 &#123;    int num[1000], len;    bign() // 析构函数，使每次定义时初始化     &#123;        memset(num, 0, sizeof(num));        len = 0;    &#125;&#125;; bign change(string str) // 输入转换为大数形式 &#123;    bign temp;    temp.len = str.length();    for (int i = 0; i &lt; temp.len; i++)    &#123;        temp.num[i] = str[temp.len - i - 1] - &#x27;0&#x27;; // 逆向非零赋值     &#125;    return temp;&#125;int compare(bign a, bign b) // 比较大小，A 大返回 1，B 大返回 -1，相等返回 0&#123;    if (a.len &gt; b.len) //A 的长度大于 B    &#123;        return 1;    &#125;    else if (a.len &gt; b.len) //A.length&lt;B.length    &#123;        return -1;    &#125;    else // 长度相同     &#123;        for (int i = a.len - 1; i &gt;= 0; i--)        &#123;                            // 从高位到低位比较             if (a.num[i] &gt; b.num[i]) // 只要有一个大就是大             &#123;                return 1;            &#125;            else if (a.num[i] &lt; b.num[i])            &#123;                return -1;            &#125;        &#125;        return 0; // 全部排除为相等     &#125;&#125;void show(bign bignum) // 输出 &#123;    for (int i = bignum.len - 1; i &gt;= 0; i--)    &#123;        cout &lt;&lt; bignum.num[i];    &#125;&#125;bign multi(bign a, int b)&#123;    bign c;    int carry = 0;    for (int i = 0; i &lt; a.len; i++)    &#123;        int temp = a.num[i] * b + carry;        c.num[c.len++] = temp % 10;        carry = temp / 10;    &#125;    while (carry != 0)    &#123;        c.num[c.len++] = carry % 10;        carry /= 10;    &#125;    return c;&#125;int main()&#123;    string str;    cin &gt;&gt; str;    bign bigtemp = change(str);    show(bigtemp);    system(&quot;pause&quot;);    return 0;&#125;\n 类型练习 \n 1069\n 题目：The Black Hole of Numbers\nFor any 4-digit integer except the ones with all the digits being the same, if we sort the digits in non-increasing order first, and then in non-decreasing order, a new number can be obtained by taking the second number from the first one. Repeat in this manner we will soon end up at the number 6174 – the black hole of 4-digit numbers. This number is named Kaprekar Constant.\nFor example, start from 6767, we’ll get:\n\n7766 - 6677 = 1089\n9810 - 0189 = 9621\n9621 - 1269 = 8352\n8532 - 2358 = 6174\n7641 - 1467 = 6174\n… …\n\nGiven any 4-digit number, you are supposed to illustrate the way it gets into the black hole.\nInput Specification:\nEach input file contains one test case which gives a positive integer N in the range (0,104)(0,10^4)(0,104).\nOutput Specification:\nIf all the 4 digits of N are the same, print in one line the equation N - N = 0000. Else print each step of calculation in a line until 6174 comes out as the difference. All the numbers must be printed as 4-digit numbers.\nSample Input 1:\n\n6767\n\nSample Output 1:\n\n7766 - 6677 = 1089\n9810 - 0189 = 9621\n9621 - 1269 = 8352\n8532 - 2358 = 6174\n\nSample Input 2:\n\n2222\n\nSample Output 2:\n\n2222 - 2222 = 0000\n\n 思路： 使用字符串的形式进行输入，对字符串进行升序和降序排序，转换为整数求结果，再将结果转换为字符串判断是否为 6174 或 0000\n 代码：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(char a, char b)&#123;    return a &gt; b; // 递减排序 &#125;int main()&#123;    string str;    cin &gt;&gt; str;    str.insert(0, 4 - str.length(), &#x27;0&#x27;);// 不足 4 位前面补 0    do    &#123;        string a = str, b = str;        sort(a.begin(), a.end(), cmp);// 降序排序         sort(b.begin(), b.end());// 升序排序         int result = stoi(a) - stoi(b);// 转换求值         str = to_string(result);// 再转为字符串         str.insert(0, 4 - str.length(), &#x27;0&#x27;);// 补零         cout &lt;&lt; a &lt;&lt; &quot; - &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; str &lt;&lt; endl;    &#125; while (str != &quot;6174&quot; &amp;&amp; str != &quot;0000&quot;);    syste(&quot;pause&quot;);    return 0;&#125;\n 1104\n 题目：Sum of Number Segments\nGiven a sequence of positive numbers, a segment is defined to be a consecutive subsequence. For example, given the sequence {0.1, 0.2, 0.3, 0.4}, we have 10 segments: (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) and (0.4).\nNow given a sequence, you are supposed to find the sum of all the numbers in all the segments. For the previous example, the sum of all the 10 segments is 0.1+0.3+0.6+1.0+0.2+0.5+0.9+0.3+0.7+0.4=5.00.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.00.1+0.3+0.6+1.0+0.2+0.5+0.9+0.3+0.7+0.4=5.0.\nInput Specification:\nEach input file contains one test case. For each case, the first line gives a positive integer N, the size of the sequence which is no more than 105. The next line contains N positive numbers in the sequence, each no more than 1.0, separated by a space.\nOutput Specification:\nFor each test case, print in one line the sum of all the numbers in all the segments, accurate up to 2 decimal places.\nSample Input:\n\n4\n0.1 0.2 0.3 0.4\n\nSample Output:\n\n5.00\n\n 思路：  找出每个数字在不同片段出现的次数，规律为 i×(n+1−i)i×(n+1-i)i×(n+1−i)，注意精度可能不足 \n 代码：\n#include &lt;iostream&gt;using namespace std; int main() &#123;    int n;    cin &gt;&gt; n;    long long sum = 0;    double temp;    for (int i = 1; i &lt;= n; i++) &#123;         cin &gt;&gt; temp;        sum += (long long)(temp * 1000) * i * (n - i + 1);    &#125;    printf(&quot;%.2f&quot;, sum / 1000.0);    return 0;&#125;\n 1008\n 题目：Elevator\nThe highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.\nFor a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.\nInput Specification:\nEach input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.\nOutput Specification:\nFor each test case, print the total time on a single line.\nSample Input:\n\n3 2 3 1\n\nSample Output:\n\n41\n\n 思路： 循环处理，根据大小关系处理上楼下楼，每次更新 now 代表的楼层 \n 代码：\n#include &lt;iostream&gt;using namespace std;int main()&#123;    int n;    cin &gt;&gt; n;    int now = 0, ans = 0, temp;    while (n--)    &#123;        cin &gt;&gt; temp;        if (temp &gt;= now)        &#123;            ans += 6 * (temp - now) + 5;        &#125;        else if (temp &lt; now)        &#123;            ans += 4 * (now - temp) + 5;        &#125;        now = temp;    &#125;    cout &lt;&lt; ans;    system(&quot;pause&quot;);    return 0;&#125; \n 1049\n 题目：Counting Ones\nThe task is simple: given any positive integer N, you are supposed to count the total number of 1’s in the decimal form of the integers from 1 to N. For example, given N being 12, there are five 1’s in 1, 10, 11, and 12.\nInput Specification:\nEach input file contains one test case which gives the positive N(≤230)N (≤2^{30})N(≤230).\nOutput Specification:\nFor each test case, print the number of 1’s in one line.\nSample Input:\n\n12\n\nSample Output:\n\n5\n\n 思路： 直接循环必然超时，总结规律：从第一位（个位）到最高位，设 now 为当前位的数字，left 为 now 左边的所有数字构成的数字，right 是 now 右边的所有数字构成的数字。只需要一次次累加对于当前位 now 来说可能出现 1 的个数，然后把它们累加即可。a 表示当前的个位为 1，十位为 10，百位为 100 类推。\n 对于 now，有三种情况：\n\n\nnow == 0 : 那么 ans += left * a; // 因为 now==0 说明 now 位只有在 left 从 0~left-1 的时候会产生 1，所以会产生 left 次，但是又因为右边会重复从 0~999… 出现 a 次 \n\n\nnow == 1 : ans += left * a + right + 1;//now = 1 的时候就要比上一步多加一个当 now 为 1 的时候右边出现 0~right 个数导致的 now 为 1 的次数 \n\n\nnow &gt;= 2 : ans += (left + 1) * a;//now 大于等于 2 就左边 0~left 的时候会在 now 位置产生 1，所以会产生 left 次，但是又因为右边会重复从 0~999… 出现 a 次 \n\n\n 代码：\n#include &lt;iostream&gt;using namespace std; int main()&#123;    int n;    cin &gt;&gt; n;    int left = 0, right = 0, a = 1, now = 1, ans = 0;    while (n / a)    &#123;        left = n / (a * 10), now = n / a % 10, right = n % a;        if (now == 0)        &#123;            ans += left * a;        &#125;        else if (now == 1)        &#123;            ans += left * a + right + 1;        &#125;        else        &#123;            ans += (left + 1) * a;        &#125;        a *= 10;    &#125;    cout &lt;&lt; ans;    system(&quot;pause&quot;);    return 0;&#125;\n 1081\n 题目：Rational Sum\nGiven N rational numbers in the form numerator/denominator, you are supposed to calculate their sum.\nInput Specification:\nEach input file contains one test case. Each case starts with a positive integer N (≤100), followed in the next line N rational numbers a1/b1 a2/b2 ... where all the numerators and denominators are in the range of long int. If there is a negative number, then the sign must appear in front of the numerator.\nOutput Specification:\nFor each test case, output the sum in the simplest form integer numerator/denominator where integer is the integer part of the sum, numerator &lt; denominator, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0.\nSample Input 1:\n\n5\n2/5 4/15 1/30 -2/60 8/3\n\nSample Output 1:\n\n3 1/3\n\n 思路： 根据文首分数的处理思路，对其进行处理即可 \n 代码：\n#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;long long gcd(long long a, long long b)&#123;    return b == 0 ? abs(a) : gcd(b, a % b);&#125;int main()&#123;    long long n, a, b, suma = 0, sumb = 1, gcdvalue;    scanf(&quot;%lld&quot;, &amp;n);    for (int i = 0; i &lt; n; i++)    &#123;        scanf(&quot;%lld/%lld&quot;, &amp;a, &amp;b);        gcdvalue = gcd(a, b);        a = a / gcdvalue;        b = b / gcdvalue;        suma = a * sumb + suma * b;        sumb = b * sumb;        gcdvalue = gcd(suma, sumb);        sumb = sumb / gcdvalue;        suma = suma / gcdvalue;    &#125;    long long integer = suma / sumb;    suma = suma - (sumb * integer);    if (integer != 0)    &#123;        printf(&quot;%lld&quot;, integer);        if (suma != 0)            printf(&quot; &quot;);    &#125;    if (suma != 0)        printf(&quot;%lld/%lld&quot;, suma, sumb);    if (integer == 0 &amp;&amp; suma == 0)        printf(&quot;0&quot;);    return 0;&#125;\n 1088\n 题目：Rational Arithmetic\nFor two rational numbers, your task is to implement the basic arithmetics, that is, to calculate their sum, difference, product and quotient.\nInput Specification:\nEach input file contains one test case, which gives in one line the two rational numbers in the format a1/b1 a2/b2 . The numerators and the denominators are all in the range of long int. If there is a negative sign, it must appear only in front of the numerator. The denominators are guaranteed to be non-zero numbers.\nOutput Specification:\nFor each test case, print in 4 lines the sum, difference, product and quotient of the two rational numbers, respectively. The format of each line is number1 operator number2 = result . Notice that all the rational numbers must be in their simplest form k a/b , where k is the integer part, and a/b is the simplest fraction part. If the number is negative, it must be included in a pair of parentheses. If the denominator in the division is zero, output Inf as the result. It is guaranteed that all the output integers are in the range of long int.\nSample Input 1:\n\n2/3 -4/2\n\nSample Output 1:\n\n2/3 + (-2) = (-1 1/3)\n2/3 - (-2) = 2 2/3\n2/3 * (-2) = (-1 1/3)\n2/3 / (-2) = (-1/3)\n\nSample Input 2:\n\n5/3 0/6\n\nSample Output 2:\n\n1 2/3 + 0 = 1 2/3\n1 2/3 - 0 = 1 2/3\n1 2/3 * 0 = 0\n1 2/3 / 0 = Inf\n\n 思路： 使用上方分数思想编写不同的算法函数进行运算即可，这里采用的是柳神代码 \n 代码：\n#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std; long long a, b, c, d; long long gcd(long long t1, long long t2)&#123;    return t2 == 0 ? t1 : gcd(t2, t1 % t2);&#125;void func(long long m, long long n)&#123;    if (m * n == 0)    &#123;        printf(&quot;%s&quot;, n == 0 ? &quot;Inf&quot; : &quot;0&quot;);        return;    &#125;    bool flag = ((m &lt; 0 &amp;&amp; n &gt; 0) || (m &gt; 0 &amp;&amp; n &lt; 0));    m = abs(m);    n = abs(n);    long long x = m / n;    printf(&quot;%s&quot;, flag ? &quot;(-&quot; : &quot;&quot;);    if (x != 0)        printf(&quot;%lld&quot;, x);    if (m % n == 0)    &#123;        if (flag)            printf(&quot;)&quot;);        return;    &#125;    if (x != 0)        printf(&quot; &quot;);    m = m - x * n;    long long t = gcd(m, n);    m = m / t;    n = n / t;    printf(&quot;%lld/%lld%s&quot;, m, n, flag ? &quot;)&quot; : &quot;&quot;);&#125;int main()&#123;    scanf(&quot;%lld/%lld %lld/%lld&quot;, &amp;a, &amp;b, &amp;c, &amp;d);    func(a, b);    printf(&quot; + &quot;);    func(c, d);    printf(&quot; = &quot;);    func(a * d + b * c, b * d);    printf(&quot;\\n&quot;);    func(a, b);    printf(&quot; - &quot;);    func(c, d);    printf(&quot; = &quot;);    func(a * d - b * c, b * d);    printf(&quot;\\n&quot;);    func(a, b);    printf(&quot; * &quot;);    func(c, d);    printf(&quot; = &quot;);    func(a * c, b * d);    printf(&quot;\\n&quot;);    func(a, b);    printf(&quot; / &quot;);    func(c, d);    printf(&quot; = &quot;);    func(a * d, b * c);    return 0;&#125;\n 1078\n 题目：Hashing\nThe task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to be H(key)=keyH(key)=key%TSizeH(key)=key where TSize is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions.\nNote that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains two positive numbers: MSize(≤104)MSize (≤10^4)MSize(≤104) and N(≤MSize)N (≤MSize)N(≤MSize) which are the user-defined table size and the number of input numbers, respectively. Then N distinct positive integers are given in the next line. All the numbers in a line are separated by a space.\nOutput Specification:\nFor each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print “-” instead.\nSample Input:\n\n4 4\n10 6 4 15\n\nSample Output:\n\n0 1 4  -\n\n 思路： 找到大于 Tsize 的最小的素数，然后使用二次探查法 \n 如果 hashTable 里面 key % size 的下标对应的 hashTable 为 false, 说明这个下标没有被使用过，直接输出。否则 step 步长从 1 加到 size-1，一次次尝试是否能使 index = (key + step * step) % size; 所对应的位置没有元素，如果都没有找到就输出“-”，否则就输出这个找到的元素的位置 \n注意 是 (key + step * step) % size 而不是 ** (key % size + step * step)\n 代码：\n#include &lt;iostream&gt;using namespace std;int size, n, hashTable[10100];bool isprime(int num) // 判断素数 &#123;    if (num == 1)        return false;    for (int i = 2; i * i &lt;= num; i++)        if (num % i == 0)            return false;    return true;&#125;void insert(int key) // 插入方法 &#123;    for (int step = 0; step &lt; size; step++)    &#123;        int index = (key + step * step) % size;        if (hashTable[index] == 0)        &#123;            hashTable[index] = 1;            cout &lt;&lt; index;            return;        &#125;    &#125;    cout &lt;&lt; &#x27;-&#x27;;&#125;int main()&#123;    cin &gt;&gt; size &gt;&gt; n;    while (!isprime(size)) // 找到第一个比 Tsize 大的素数     &#123;        size++;    &#125;    for (int i = 0; i &lt; n; i++)    &#123;        int key;        cin &gt;&gt; key;        if (i != 0)        &#123;            cout &lt;&lt; &#x27; &#x27;;        &#125;        insert(key);    &#125;    return 0;&#125;\n 1096\n 题目：Consecutive Factors\nAmong all the factors of a positive integer N, there may exist several consecutive numbers. For example, 630 can be factored as 3×5×6×73×5×6×73×5×6×7, where 5, 6, and 7 are the three consecutive numbers. Now given any positive N, you are supposed to find the maximum number of consecutive factors, and list the smallest sequence of the consecutive factors.\nInput Specification:\nEach input file contains one test case, which gives the integer N(1&lt;N&lt;231)N(1&lt;N&lt;2^{31})N(1&lt;N&lt;231).\nOutput Specification:\nFor each test case, print in the first line the maximum number of consecutive factors. Then in the second line, print the smallest sequence of the consecutive factors in the format factor[1]*factor[2]*...*factor[k] , where the factors are listed in increasing order, and 1 is NOT included.\nSample Input:\n\n630\n\nSample Output:\n\n3\n5×6×7\n\n 思路： 使用双重循环嵌套，模拟连续的长度，不论长度多少，当前乘积不能被 num 整除就不符合条件，相反，只要能够整除不论其他因子为多少都符合条件 \n\n\n 数据规模为 int 型的范围，但中间计算乘积时可能导致溢出，所以存储为 long long\n\n\n 因子 1 不包含在范围中，第一层循环从 2 开始，然后将第一层的变量 i 作为第二层循环的起始因子，不断自增模拟 \n\n\n 使用临时变量 temp（每次初始为 1）相乘第二层的循环变量 j，若 num 对 temp 不能整除，表示不符合条件跳出 \n\n\n 代码：\n#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std; long int num, temp; int main()&#123;    cin &gt;&gt; num;    int first = 0, len = 0, maxn = sqrt(num) + 1; // 乘积因子的最大值为 n 的开根     for (int i = 2; i &lt;= maxn; i++)               // 控制起始因子     &#123;        int j;        temp = 1;        for (j = i; j &lt;= maxn; j++) // 控制连续因子         &#123;            temp *= j;            if (num % temp != 0) // 不再符合跳出             &#123;                break;            &#125;        &#125;        if (j - i &gt; len) // 每次更新最长长度         &#123;            len = j - i;            first = i;        &#125;    &#125;    if (first == 0)    &#123;        cout &lt;&lt; 1 &lt;&lt; endl             &lt;&lt; num;    &#125;    else    &#123;        cout &lt;&lt; len &lt;&lt; endl;        for (int i = 0; i &lt; len; i++)        &#123;            cout &lt;&lt; first + i;            if (i != len - 1)            &#123;                cout &lt;&lt; &#x27;*&#x27;;            &#125;        &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1059\n 题目：Prime Factors\nGiven any positive integer N, you are supposed to find all of its prime factors, and write them in the format N=p1k1×p2k2×⋯×pmkmN= p1^{k1}×p2^{k2}×⋯×pm^{km}N=p1k1×p2k2×⋯×pmkm.\nInput Specification:\nEach input file contains one test case which gives a positive integer N in the range of long int.\nOutput Specification:\nFactor N in the format N = p1^k1*p2^k2*…*pm^km, where pi’s are prime factors of N in increasing order, and the exponent ki is the number of pi – hence when there is only one pi, ki is 1 and must NOT be printed out.\nSample Input:\n\n97532468\n\nSample Output:\n\n97532468=2^211171011291\n\n 思路： 建立素数表，遍历判断，符合条件整除当前因子后继续判断 \n\n\n 建立素数表：long int 的 sqrt 最大不超过 50000，也就是说因子只会在这里边产生，将数组初始值为 1，不符合条件的赋值为 0\n\n\n 循环遍历，然后对每一个变量 i 进行素数判断，是素数就判断能否整除，能够整除在判断一次，判断当前因子出现了几次 \n\n\n 代码：\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; prime(50000, 1); // 乘积因子不会大于 50000，建立素数表，初始为 1long int num;int main()&#123;    for (int i = 2; i * i &lt; 50000; i++)    &#123;        for (int j = 2; j * i &lt; 50000; j++)        &#123;            prime[i * j] = 0; // 将不是素数的标记为 0        &#125;    &#125;    cin &gt;&gt; num;    cout &lt;&lt; num &lt;&lt; &#x27;=&#x27;;    if (num == 1)    &#123;        cout &lt;&lt; 1;    &#125;    bool state = false; // 有无因子输出标志     for (int i = 2; i &lt; 50000 &amp;&amp; num &gt;= 2; i++)    &#123;        int cnt = 0;                          // 指数         bool flag = false;                    // 条件符合         while (prime[i] == 1 &amp;&amp; num % i == 0) // 是素数而且可以整除         &#123;            num /= i;            cnt++;            flag = true;        &#125;        if (flag)        &#123;            if (state)            &#123;                cout &lt;&lt; &#x27;*&#x27;;            &#125;            cout &lt;&lt; i;            state = true;        &#125;        if (cnt &gt; 1)        &#123;            cout &lt;&lt; &#x27;^&#x27; &lt;&lt; cnt;        &#125;    &#125;    return 0;&#125;\n 1023\n 题目：Have Fun with Numbers\nNotice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again!\nNow you are suppose to check if there are more numbers with this property. That is, double a given number with k digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number.\nInput Specification:\nEach input contains one test case. Each case contains one positive integer with no more than 20 digits.\nOutput Specification:\nFor each test case, first print in a line “Yes” if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or “No” if not. Then in the next line, print the doubled number.\nSample Input:\n\n1234567899\n\nSample Output:\n\nYes\n2469135798\n\n 思路： 大数类的转换和乘法，使用标记数组进行每个字符次数的判断 \n 代码：\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std; struct bignum&#123;    int num[25], len;    bignum()    &#123;        memset(num, 0, sizeof(num));        len = 0;    &#125;&#125;; bignum add(bignum a, bignum b)&#123;    bignum c;    int carry = 0;    for (int i = 0; i &lt; a.len || i &lt; b.len; i++)    &#123;        int temp = a.num[i] + b.num[i] + carry;        c.num[c.len++] = temp % 10;        carry = temp / 10;    &#125;    if (carry != 0)    &#123;        c.num[c.len++] = carry;    &#125;    return c;&#125;bignum multi(bignum a, int b)&#123;    bignum c;    int carry = 0;    for (int i = 0; i &lt; a.len; i++)    &#123;        int temp = a.num[i] * b + carry;        c.num[c.len++] = temp % 10;        carry = temp / 10;    &#125;    while (carry != 0)    &#123;        c.num[c.len++] = carry % 10;        carry /= 10;    &#125;    return c;&#125;int main()&#123;    string str;    cin &gt;&gt; str;    vector&lt;int&gt; flag(10, 0);    bool p = true;    bignum bign;    bign.len = str.length();    for (int i = 0; i &lt; str.length(); i++)    &#123;        bign.num[i] = str[bign.len - i - 1] - &#x27;0&#x27;;        flag[bign.num[i]]++;    &#125;    bignum result = multi(bign, 2);    for (int i = 0; i &lt; result.len; i++)    &#123;        flag[result.num[i]]--;    &#125;    if (bign.len != result.len)    &#123;        p = false;    &#125;    else    &#123;        for (int i = 1; i &lt;= 9; i++)        &#123;            if (flag[i])            &#123;                p = false;            &#125;        &#125;    &#125;    if (p)    &#123;        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;    &#125;    for (int i = result.len - 1; i &gt;= 0; i--)    &#123;        cout &lt;&lt; result.num[i];    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1024\n 题目：Palindromic Number\nA number that will be the same when it is written forwards or backwards is known as a Palindromic Number. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers.\nNon-palindromic numbers can be paired with palindromic ones via a series of operations. First, the non-palindromic number is reversed and the result is added to the original number. If the result is not a palindromic number, this is repeated until it gives a palindromic number. For example, if we start from 67, we can obtain a palindromic number in 2 steps: 67 + 76 = 143, and 143 + 341 = 484.\nGiven any positive integer N, you are supposed to find its paired palindromic number and the number of steps taken to find it.\nInput Specification:\nEach input file contains one test case. Each case consists of two positive numbers N and K, where N(≤1010)N (≤10^{10})N(≤1010) is the initial numer and K (≤100) is the maximum number of steps. The numbers are separated by a space.\nOutput Specification:\nFor each test case, output two numbers, one in each line. The first number is the paired palindromic number of N, and the second number is the number of steps taken to find the palindromic number. If the palindromic number is not found after K steps, just output the number obtained at the Kth step and K instead.\nSample Input 1:\n\n67 3\n\nSample Output 1:\n\n484\n2\n\n 思路： 将操作的方法独立编写，使用次数和是否回文作为循环终止条件进行 while 循环，最后输出 \n 代码：\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct bign&#123;    int num[1000], len;    bign()    &#123;        memset(num, 0, sizeof(num));        len = 0;    &#125;&#125;;bign change(string str)&#123;    bign temp;    temp.len = str.length();    for (int i = 0; i &lt; str.length(); i++)    &#123;        temp.num[i] = str[temp.len - i - 1] - &#x27;0&#x27;;    &#125;    return temp;&#125;bign add(bign a, bign b)&#123;    bign c;    int carry = 0;    for (int i = 0; i &lt; a.len || i &lt; b.len; i++)    &#123;        int temp = a.num[i] + b.num[i] + carry;        c.num[c.len++] = temp % 10;        carry = temp / 10;    &#125;    if (carry != 0)    &#123;        c.num[c.len++] = carry;    &#125;    return c;&#125;bool judge(bign a)&#123;    for (int i = 0; i &lt; a.len / 2; i++)    &#123;        if (a.num[i] != a.num[a.len - 1 - i])        &#123;            return false;        &#125;    &#125;    return true;&#125;int main()&#123;    string str;    int n;    cin &gt;&gt; str &gt;&gt; n;    bign a = change(str);    int k = 0;    while (k &lt; n &amp;&amp; judge(a) == false)    &#123;        bign b = a;        reverse(b.num, b.num + b.len);        a = add(a, b);        k++;    &#125;    for (int i = a.len - 1; i &gt;= 0; i--)    &#123;        cout &lt;&lt; a.num[i];    &#125;    cout &lt;&lt; endl         &lt;&lt; k;    system(&quot;pause&quot;);    return 0;&#125;\n","categories":["算法"],"tags":["C/C++"]},{"title":"PAT 甲级 - 搜索和动规","url":"/pat_level_a-search_and_dp/","content":"\n\n 因为当时备考比较匆忙，图和树的题只是粗略写了一下并没有整理，包括搜索中的 BFS 也没整理，搜索和动态规划这两部分的内容较少，便直接整合到一起了，后续就没了，当时参加 PAT 是在大三，那时候总觉得时间用不完，写了几个没什么技术含量的小东西之后就觉得没意思了，当时刷知乎看到陈越姥姥说 PAT 就等于计算机的托福啊，便一头扎进去准备了，中间因为自身原因放下了一段时间，导致后来成绩不理想（当时还收到 58 同城的面试邀请），但功不唐捐感觉还是学到了不少东西 \n\n DFS\n 1103\n 题目：Integer Factorization\nThe K−P factorization of a positive integer N is to write N as the sum of the P-th power of K positive integers. You are supposed to write a program to find the K−P factorization of N for any positive integers N, K and P.\nInput Specification:\nEach input file contains one test case which gives in a line the three positive integers N (≤400), K (≤N) and P (1&lt;P≤7). The numbers in a line are separated by a space.\nOutput Specification:\nFor each case, if the solution exists, output in the format:\n\nN = n[1]^P + … n[K]^P\n\nwhere n[i] (i = 1, …, K ) is the i -th factor. All the factors must be printed in non-increasing order.\nNote: the solution may not be unique. For example, the 5-2 factorization of 169 has 9 solutions, such as 122+42+22+22+12, or 112+62+22+22+22, or more. You must output the one with the maximum sum of the factors. If there is a tie, the largest factor sequence must be chosen – sequence {a1, a2, ⋯, aK} is said to be larger than {b1, b2, ⋯, bK} if there exists 1≤L≤K such that ai=bi for ibL.\nIf there is no solution, simple output Impossible .\nSample Input 1:\n\n169 5 2\n\nSample Output 1:\n\n169 = 6^2 + 6^2 + 6^2 + 6^2 + 5^2\n\nSample Input 2:\n\n169 167 3\n\nSample Output 2:\n\nImpossible\n\n 思路： 输入初始数据之后，就将所有能够符合条件的因子放入数组中，然后搜索模拟 \n 代码：\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std; int N, K, P, maxsum = -1; // 定义一个底数和用来判断底数最大的序列 vector&lt;int&gt; factor, ans, temp; //factor 用来保存所有不超过 N 的因子，下标为底数，数据为 pow(index, P)//ans 存储答案，temp 为 DFS 搜索过程中的临时序列存储 void init() // 将所有小于 N 的因子存放到数组中 &#123;    int i = 0, temp = 0;    while (temp &lt;= N)    &#123;        factor.push_back(temp);        temp = (int)pow((double)++i, (double)P);    &#125;&#125;void DFS(int index, int nowK, int sum, int facsum) // 参数为下标，当前步，数据和与底数和 &#123;    if (sum == N &amp;&amp; nowK == K) // 当和与步数到达目标数值时判断     &#123;        if (facsum &gt; maxsum) // 输出底数和最大的一个         &#123;            ans = temp;            maxsum = facsum;        &#125;        return;    &#125;    if (sum &gt; N || nowK &gt; K) // 和或步数超过目标数值，表示不符合条件     &#123;        return;    &#125;    if (index - 1 &gt;= 0) //factor[0]=0; 只是为了数据存储的条理性，不必参与运算     &#123;        temp.push_back(index); // 将当前下标放入后进行下一步搜索         DFS(index, nowK + 1, sum + factor[index], facsum + index);        temp.pop_back(); // 成功或失败后，回溯，在进行搜索         DFS(index - 1, nowK, sum, facsum);    &#125;&#125;int main()&#123;    cin &gt;&gt; N &gt;&gt; K &gt;&gt; P;    init();    DFS(factor.size() - 1, 0, 0, 0);    if (maxsum == -1) // 只要不为 -1 说明有答案     &#123;        cout &lt;&lt; &quot;Impossible&quot;;    &#125;    else    &#123;        cout &lt;&lt; N &lt;&lt; &quot; = &quot; &lt;&lt; ans[0] &lt;&lt; &quot;^&quot; &lt;&lt; P;        for (int i = 1; i &lt; ans.size(); i++)        &#123;            cout &lt;&lt; &quot; + &quot; &lt;&lt; ans[i] &lt;&lt; &quot;^&quot; &lt;&lt; P;        &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 最大子序列和 \n 1007\n 题目：Maximum Subsequence Sum\nGiven a sequence of K integers {N1, N2, …, NK}. A continuous subsequence is defined to be {Ni, Ni+1, …, Nj} where 1≤i≤j≤K1≤i≤j≤K1≤i≤j≤K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence {-2, 11, -4, 13, -5, -2}, its maximum subsequence is {11, -4, 13} with the largest sum being 20.\nNow you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.\nInput Specification:\nEach input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (≤10000). The second line contains K numbers, separated by a space.\nOutput Specification:\nFor each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.\nSample Input:\n\n10\n-10 1 2 3 4 -5 -23 3 7 -21\n\nSample Output:\n\n10 1 4\n\n 思路：   使用动态规划的思想，将所有的子串和找出，求最大的即可 \n\n\n 需要判断输入的数据是否为全负数，如果全是负数，就是从头到尾的输出 \n\n\n 保留最大子串时需要判断前面的子串和与当前数相加是否更大，如果没有，保留当前数字即可，否者将其继续放入子串序列后 \n\n\n 还需保存起始与结束位置，位置的存储也分情况判断，如果当前数加到子序列后，那么这条子串的起始下标还是之前 begin[i]=begin[i-1]，如果从当前数开始开辟另一条子序列那么，当前的起始就是现在数字的下标 begin[i]=i\n\n\n 代码：\n#include &lt;iostream&gt;using namespace std;const int maxn = 10010;int data[maxn], dp[maxn]; // 存储数据和子串和 int beg[maxn] = &#123;0&#125;;      // 记录当前以 i 为结尾的子串的起始下标 int main()&#123;    int n;    cin &gt;&gt; n;    bool flag = false;    for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; data[i];        if (data[i] &gt;= 0)        &#123;            flag = true; // 只要有一个正数就可以进行运算         &#125;    &#125;    if (!flag) // 如果全是负数     &#123;        cout &lt;&lt; &quot;0 &quot; &lt;&lt; data[0] &lt;&lt; &quot; &quot; &lt;&lt; data[n - 1];        return 0;    &#125;    dp[0] = data[0];    for (int i = 1; i &lt; n; i++) // 状态转移方程     &#123;        if (dp[i - 1] + data[i] &gt; data[i])        &#123;            dp[i] = dp[i - 1] + data[i];            beg[i] = beg[i - 1];        &#125;        else        &#123;            dp[i] = data[i];            beg[i] = i;        &#125;    &#125;    int end = 0; // 结束节点     for (int i = 0; i &lt; n; i++)    &#123;        if (dp[i] &gt; dp[end])        &#123;            end = i;        &#125;    &#125;    cout &lt;&lt; dp[end] &lt;&lt; &quot; &quot; &lt;&lt; data[beg[end]] &lt;&lt; &quot; &quot; &lt;&lt; data[end];    return 0;&#125;\n 背包问题 \n 1068\n 题目：Find More Coins\nEva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she must pay the exact amount. Since she has as many as 104 coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find some coins to pay for it.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains 2 positive numbers: N (≤ 10410^4104, the total number of coins) and M (≤ 10210^2102, the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers. All the numbers in a line are separated by a space.\nOutput Specification:\nFor each test case, print in one line the face values V1≤V2≤⋯≤Vk such that V1+V2+⋯+Vk= M . All the numbers must be separated by a space, and there must be no extra space at the end of the line. If such a solution is not unique, output the smallest sequence. If there is no solution, output “No Solution” instead.\nNote: sequence {A[1], A[2], …} is said to be “smaller” than sequence {B[1], B[2], …} if there exists k≥1 such that A[i]=B[i] for all i&lt;k, and A[k] &lt; B[k].\nSample Input 1:\n\n8 9\n5 9 8 7 2 3 4 1\n\nSample Output 1:\n\n1 3 5\n\nSample Input 2:\n\n4 8\n7 2 4 3\n\nSample Output 2:\n\nNo Solution\n\n 思路：  最后输出字典序最小的结果，先将其从大到小进行排序，将正确的值反向进行查找，跳转放入数组输出 \n 代码：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std; int N, M, coins[10010]; int dp[10010], choice[10010][110]; bool cmp(int a, int b)&#123;    return a &gt; b;&#125;int main()&#123;    cin &gt;&gt; N &gt;&gt; M;    for (int i = 1; i &lt;= N; i++)    &#123;        cin &gt;&gt; coins[i];    &#125;    sort(coins + 1, coins + N + 1, cmp); // 将硬币从大到小排序     // 背包模板     for (int i = 1; i &lt;= N; i++)    &#123;        for (int j = M; j &gt;= coins[i]; j--)        &#123;            if (dp[j] &lt;= dp[j - coins[i]] + coins[i])            &#123;                choice[i][j] = true;                dp[j] = dp[j - coins[i]] + coins[i];            &#125;        &#125;    &#125;    if (dp[M] != M)    &#123;        cout &lt;&lt; &quot;No Solution&quot;;    &#125;    else    &#123;        vector&lt;int&gt; arr;        int v = M, index = N;        while (v &gt; 0) // 反向查找，保证字典序最小         &#123;            if (choice[index][v])            &#123;                arr.push_back(coins[index]);                v -= coins[index];            &#125;            index--;        &#125;                for (int i = 0; i &lt; arr.size(); i++)        &#123;            if (i != 0)            &#123;                cout &lt;&lt; &quot; &quot;;            &#125;            cout &lt;&lt; arr[i];        &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n","categories":["算法"],"tags":["C/C++"]},{"title":"蓝桥杯省赛真题","url":"/lan_qiao-provincial_question/","content":"\n\n准备蓝桥杯时候刷真题的一小部分记录，有几道题在我之前发过的 蓝桥杯普及题 中，好多复杂的题直接把思路写在代码注释上，也没精力再整理到这了，后来还整理了一部分国赛真题，放在 OneNote 上的，结果在整理 OneDrive 上的文件时一不小心（手贱）给送走了，蓝桥杯的相关题刷过的还蛮丰富的，但记录下来的就只有这些了\n\n 2018 年\n 三角形的面积\n题目：\n已知三角形三个顶点在直角坐标系下的坐标分别为：\n\n(2.3, 2.5)\n\n(6.4, 3.1)\n(5.1, 7.2)\n求该三角形的面积。\n注意，要提交的是一个小数形式表示的浮点数。\n要求精确到小数后 3 位，如不足 3 位，需要补零。\n思路：\n可以采用两种算法：图形切割和海伦公式\n\n图形切割法：用最外侧两点的坐标减去最靠近圆心坐标的点求出两个正方形的边长，用大正方形的面积减去小正方形的面积就是三角形的两倍\n海伦公式：S=P(P−a)(P−b)(P−c)S=\\sqrt{P(P-a)(P-b)(P-c)}S=P(P−a)(P−b)(P−c)​，其中 P 是周长的一半，先根据坐标用勾股定理求出每条边的边长\n\n代码：\npublic static void main(String[] args) &#123;    // 图形切割法    // 用最外侧两点的坐标减去最靠近圆心坐标的点求出两个正方形的边长    // 用大正方形的面积减去小正方形的面积就是三角形的两倍    double x1 = 2.3;    double y1 = 2.5;    double x2 = 6.4;    double y2 = 3.1;    double x3 = 5.1;    double y3 = 7.2;    double X1 = x2 - x1;    double Y1 = y2 - y1;    double X2 = x3 - x1;    double Y2 = y3 - y1;    System.out.println((X1 * Y2 - X2 * Y1) / 2);    // 海伦公式    // 面积 =sqrt(P(P-a)(P-b)(P-c))；其中 P 是周长的一半    // 先根据坐标用勾股定理求出每条边的边长    double a = Math.sqrt((6.4 - 2.3) * (6.4 - 2.3) + (3.1 - 2.5) * (3.1 - 2.5));    double b = Math.sqrt((5.1 - 2.3) * (5.1 - 2.3) + (7.2 - 2.5) * (7.2 - 2.5));    double c = Math.sqrt((6.4 - 5.1) * (6.4 - 5.1) + (7.2 - 3.1) * (7.2 - 3.1));    double p = (a + b + c) / 2;    System.out.println(Math.sqrt(p * (p - a) * (p - b) * (p - c)));&#125;\n 最大乘积\n题目：\n把 1~9 位数字分成两组，将其相乘，使得它的乘积也是不重复的九个数字\n\n984672 * 351=345619872\n\n9 * 87146325=784316925\n符合这种规律的乘式还有很多，求乘积最大的那一个\n思路：\n\n首先进行全排列，这样就不用考虑重复的问题\n将每次全排列的 9 个数字进行拆分相乘，保留符合条件的乘积，最后输出最大值即可\n\n代码：\npublic class MaxProduct &#123;    static int[] a = new int[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;    static int ans = 0;    public static void main(String[] args) &#123;        dfs(0);        System.out.println(ans);    &#125;    static void dfs(int m) &#123;        if (m &gt;= 9) &#123;// 穷举所有全排列的将其分割相乘，判断乘积是否符合条件            for (int i = 1; i &lt;= 8; i++) &#123;                int x = 0, y = 0;                for (int j = 0; j &lt; i; j++)                    x = 10 * x + a[j];// 定义左边的乘数                for (int k = i; k &lt; 9; k++)                    y = 10 * y + a[k];// 定义右边的乘数                int res = x * y;                int[] cnt = new int[10];                while (res &gt; 0) &#123;                    cnt[res % 10]++;// 将乘积分开放到数组中，对应下标的数组设为 1                    res /= 10;                &#125;                boolean flag = true;                for (int k = 1; k &lt;= 9; k++)                    if (cnt[k] != 1) &#123;                        flag = false;                        break;                    &#125;                if (flag) &#123;                    ans = Math.max(x * y, ans);// 将最大的乘积保存下来                    if (x * y == ans)                        System.out.println(x + &quot; * &quot; + y + &quot; == &quot; + ans);                &#125;            &#125;            return;        &#125;        for (int i = m; i &lt; 9; i++) &#123;            swap(i, m);            dfs(m + 1);            swap(i, m);        &#125;    &#125;    static void swap(int i, int j) &#123;        int t = a[i];        a[i] = a[j];        a[j] = t;    &#125;&#125;\n 整理玩具\n题目：\n小明有一套玩具，一共包含 NxM 个部件。这些部件摆放在一个包含 NxM 个小格子的玩具盒中，每个小格子中恰好摆放一个部件。\n每一个部件上标记有一个 0~9 的整数，有可能有多个部件标记相同的整数。\n小明对玩具的摆放有特殊的要求：标记相同整数的部件必须摆在一起，组成一个矩形形状。\n如以下摆放是满足要求的：\n\n00022\n\n00033\n44444\n\n12244\n\n12244\n12233\n\n01234\n\n56789\n以下摆放不满足要求：\n\n11122\n\n11122\n33311\n\n111111\n\n122221\n111111\n\n11122\n\n11113\n33333\n输入\n输入包含多组数据。\n第一行包含一个整数 T，代表数据组数。 (1 &lt;= T &lt;= 10)\n以下包含 T 组数据。\n每组数据第一行包含两个整数 N 和 M。 (1 &lt;= N, M &lt;= 10)\n以下包含 N 行 M 列的矩阵，代表摆放方式。\n输出\n对于每组数据，输出 YES 或者 NO 代表是否符合小明的要求。\n【样例输入】\n\n3\n\n3 5\n00022\n00033\n44444\n3 5\n11122\n33311\n2 5\n01234\n56789\n【样例输出】\n\nYES\n\nNO\nYES\n思路：\n\n将数组中的数放到 HashSet 中去重，仅记录玩具的种类\n构造方法，用 Set 中的每一个值去判断，返回 Boolean 型\n\n记录当前数据从左上到右下的坐标点，然后再遍历矩阵范围内的所有数字是否相同即可\n判断方法可以把矩阵中的所有数字相加，然后根据矩阵下标求出个数，判断 sum==count*num 的值即可\n\n\n输入的数组没有空格，可以采用 toCharArray() 将其作为字符串存为字符数组，（Char 和 int 的自动转换）\n\n代码：\npublic class TidyupToys &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int t = sc.nextInt();// 输入组数        while (t-- &gt; 0) &#123;            int n = sc.nextInt();            int m = sc.nextInt();            HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();// 存放出现的数字（不重复）            char[][] arr = new char[n][m];            for (int i = 0; i &lt; n; i++) &#123;                arr[i] = sc.next().toCharArray();// 输入数组（按行输入）            &#125;            for (int i = 0; i &lt; arr.length; i++) &#123;                for (int j = 0; j &lt; arr[0].length; j++) &#123;                    set.add(arr[i][j]);                &#125;            &#125;            boolean flag = true;            for (Character c : set) &#123;// 判断每一个不同的数据（从左上往右下进行寻找）                if (!find(arr, c)) &#123;                    flag = false;                    break;                &#125;            &#125;            if (flag)                System.out.println(&quot;YES&quot;);            else                System.out.println(&quot;NO&quot;);        &#125;    &#125;    // 从左上角向右下角寻找，因为数据比较小，每个数字找到他第一次出现 (x1,y1) 和    // 最后出现的（x2,y2）, 然后遍历再 x1 x2 y1 y2 范围的数，如果符合是矩形    // 那么遍历的每一个数一定是相同的，如果不相同说明不符合条件。    static boolean find(char[][] arr, char res) &#123;        int minx = 0;        int miny = 0;        int maxx = 0;        int maxy = 0;        int temp = 0;        boolean flag = true;        for (int i = 0; i &lt; arr.length; i++) &#123;            for (int j = 0; j &lt; arr[0].length; j++) &#123;                if (arr[i][j] == res) &#123;// 寻找 set 中的字符在数组中的第一次出现                    if (temp == 0) &#123;                        minx = i;                        miny = j;                    &#125;                    temp++;                    maxx = Math.max(i, maxx);                    maxy = Math.max(j, maxy);// 找出它的左上点和右下点下标                &#125;            &#125;        &#125;        int sum = 0;        if (maxx == minx &amp;&amp; miny == maxy) &#123;            return true;// 只出现了一次必然不会出错        &#125;        int count = (maxx - minx + 1) * (1 + maxy - miny);// 记录应该出现的个数        // 在判断的时候每个数的大小 * 个数，看是否等于遍历和。        for (int i = minx; i &lt;= maxx; i++) &#123;            for (int j = miny; j &lt;= maxy; j++) &#123;                sum += arr[i][j];            &#125;        &#125;        if (sum != res * count) &#123;            flag = false;        &#125;        return flag;    &#125;&#125;\n 版本分支\n题目：\n公司一个奇怪的项目。这个项目的代码一直在不断分支 (branch) 但是从未发生过合并 (merge)。\n现在这个项目的代码一共有 N 个版本，编号 1~N，其中 1 号版本是最初的版本。\n除了 1 号版本之外，其他版本的代码都恰好有一个直接的父版本；即这 N 个版本形成了一棵以 1 为根的树形结构。\n如下图就是一个可能的版本树：\ngraph TB    1--&gt;2;    1--&gt;3;    2--&gt;5;    3--&gt;4;    3--&gt;6;\n现在小明需要经常检查版本 x 是不是版本 y 的祖先版本。你能帮助小明吗？\n输入\n第一行包含两个整数 N 和 Q，代表版本总数和查询总数。\n以下 N-1 行，每行包含 2 个整数 u 和 v，代表版本 u 是版本 v 的直接父版本。\n再之后 Q 行，每行包含 2 个整数 x 和 y，代表询问版本 x 是不是版本 y 的祖先版本。\n输出\n对于每个询问，输出 YES 或 NO 代表 x 是否是 y 的祖先。\n【样例输入】\n\n6 5\n\n1 2\n1 3\n2 5\n3 6\n3 4\n1 1\n1 4\n2 6\n5 2\n6 4\n【样例输出】\n\nYES\n\nYES\nNO\n思路：\n\n按数组进行关系的存放，每个版本下标中存放它的直接父节点\n如果在判断时 arr[y]==x, 那就是对应的直接父节点，如果不是就将它的 arr[y] 的值取出继续向上查找，一直到源点 1 结束\n\n代码：\npublic class VersionBranching &#123;    static int[] arr;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int N = sc.nextInt();        int Q = sc.nextInt();        arr = new int[N + 1];// 数组从 1 开始        for (int i = 1; i &lt;= N; i++) &#123;            arr[i] = i;        &#125;        for (int i = 1; i &lt; N; i++) &#123;            int x = sc.nextInt();            int y = sc.nextInt();            union(x, y);        &#125;        for (int i = 0; i &lt; Q; i++) &#123;            int x = sc.nextInt();            int y = sc.nextInt();            if (find(x, y)) &#123;                System.out.println(&quot;Yes&quot;);            &#125; else &#123;                System.out.println(&quot;No&quot;);            &#125;        &#125;        sc.close();    &#125;    // 寻找父节点    private static boolean find(int x, int y) &#123;        if (arr[y] == x)// 是直接父节点            return true;        int t = arr[y];        while (t != 1) &#123;// 没到源点，一直往上寻找            t = arr[t];            if (t == x)                return true;        &#125;        return false;    &#125;    private static void union(int x, int y) &#123;        if (arr[y] == y) &#123;            arr[y] = x;        &#125;    &#125;&#125;\n 2017 年\n 平方十位数\n题目：\n由 0~9 这 10 个数字不重复、不遗漏，可以组成很多 10 位数字。\n这其中也有很多恰好是平方数（是某个数的平方）。\n比如：1026753849，就是其中最小的一个平方数。\n请你找出其中最大的一个平方数是多少？\n思路：\n\n因为十位数的每位各不重复，所以可以采用 DFS 全排列，然后更改递归出口\n递归出口的判断条件有十位数和平方数两个\n\n代码：\npublic class SquareTen &#123;    static int[] arr = &#123;9, 8, 7, 6, 5, 4, 3, 2, 1, 0&#125;;// 因为求最大值，反向第一    static int ans = 0;// 平方数的个数    public static void main(String[] args) &#123;        dfs(0);        System.out.println(ans);    &#125;    static void dfs(int m) &#123;// 用 dfs 全排列枚举        if (m &gt;= 10) &#123;// 将递归出口定义为平方数            long res = 0;            for (int i = 0; i &lt; 10; i++)                res = 10 * res + arr[i];            long r = (long) Math.sqrt(res);            if ((&quot;&quot; + res).length() != 10)// 前边加空格转换为字符串判断长度                return;            if (r * r == res) &#123;// 是平方数                ans++;                System.out.println(res);            &#125;            return;        &#125;        for (int i = m; i &lt; 10; i++) &#123;// 全排列公式            swap(i, m);            dfs(m + 1);            swap(i, m);        &#125;    &#125;    static void swap(int a, int b) &#123;// 交换方法        int t = arr[a];        arr[a] = arr[b];        arr[b] = t;    &#125;&#125;\n 填字母游戏\n题目：\nK 大师在纸上画了一行 n 个格子，要小明和他交替往其中填入字母。\n\n\n轮到某人填的时候，只能在某个空格中填入 L 或 O\n谁先让字母组成了“LOL”的字样，谁获胜。\n如果所有格子都填满了，仍无法组成 LOL，则平局。\n\n\n本题的输入格式为：\n第一行，数字 n（n&lt;10），表示下面有 n 个初始局面。\n接下来，n 行，每行一个串，表示开始的局面。\n比如： ****** , 表示有 6 个空格。 L**** , 表示左边是一个字母 L，它的右边是 4 个空格。\n要求输出 n 个数字，表示对每个局面，如果小明先填，当 K 大师总是用最强着法的时候，小明的最好结果。\n1 表示能赢\n-1 表示必输\n0 表示可以逼平\n输入\n\n4\n\n\n***\n\n\nL**L\n\n\nL**L***L\n\n\nL*****L\n\n输出\n\n0\n\n-1\n1\n思路：\n\n判断方法，首先判断是否拿到时就出现 &quot;LOL&quot;，如果有说明已经输了（此判断还会在递归中判断是否填写成功）\n第二次判断是否还有’*' 存在，若没有就是平局\n然后模拟填数，将原本的’*' 赋值为’L’或者’O’然后递归到方法中判断\n\n代码：\npublic class FillLetters &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        while (n-- &gt; 0) &#123;            char[] a = sc.next().toCharArray();// 将字符串转换为字符数组存放            System.out.println(find(a));        &#125;    &#125;    static int find(char[] a) &#123;        String s = new String(a);// 将数组转换为字符串方便查找        if (s.contains(&quot;LOL&quot;))// 当拿到时就有了 &quot;LOL&quot; 直接失败，或者模拟填写时成功填写            return -1;        if (!s.contains(&quot;*&quot;))// 没有填写位置也没返回 LOL 说明平局            return 0;        int n = a.length;// 构建循环模拟填写过程        int dogfall = 0;// 平局记录        for (int i = 0; i &lt; n; i++) &#123;            if (a[i] == &#x27;*&#x27;) &#123;// 如果当前是空格可以填写，进行模拟                try &#123;// 可能出现异常                    a[i] = &#x27;L&#x27;;// 填入 L                    if (find(a) == -1)// 拿到时出现 LOL                        return 1;                    else if (find(a) == 0)                        dogfall = 1;                    a[i] = &#x27;O&#x27;;// 填入 O                    if (find(a) == -1)// 拿到时出现 LOL                        return 1;                    else if (find(a) == 0)                        dogfall = 1;                &#125; finally &#123;// 无视异常与否进行执行                    a[i] = &#x27;*&#x27;;                &#125;            &#125;        &#125;        if (dogfall == 1)// 填写中平局            return 0;        return -1;// 没在填数过程中返回 1 则必返回 0    &#125;&#125;\n 2016 年\n 愤怒小鸟\n题目：\n两辆相对的火车（A、B）以 10/ 秒的速度行驶，初始相距 1000，中间有一只小鸟以时速 50/ 秒的速度进行折返飞行（首先从 A 飞向 B）\n最后两辆车在相距 1 的位置停下，求这期间小鸟撞到 B 车多少次\n思路：\n\n利用距离与速度推导出相遇的时间，然后计数器加一，再用时间更新位置\n中间用 flag 变量的正负值确定方向\n\n代码：\npublic class AngryBirds &#123;    public static void main(String[] args) &#123;        double l = 0;//A        double r = 1000;//B        int count = 0;// 计数        double b = 0;// 小鸟        int flag = 1;// 用来判断飞向那个火车        double t;// 记录时间        while (r - l &gt; 1) &#123;// 两车未停            if (flag == 1) &#123;// 从 A 向 B 飞                t = (r - b) / 60.0;// 鸟和 B 火车相遇所用的时间                count++;// 只有和 B 相遇的时候才计数加                l += 10.0 * t;// 更新 A 这段时间走的                r -= 10.0 * t;// 更新 B                b += 50.0 * t;// 更新鸟的位置                flag = -1;// 下次应该向 A 走            &#125; else &#123;// 向火车 A 走                t = (b - l) / 60.0;                l += 10.0 * t;                r -= 10.0 * t;                b -= 50.0 * t;                flag = 1;            &#125;        &#125;        System.out.println(count);    &#125;&#125;\n 反幻方\n题目：\n将 1~9 填入九宫格，求每行每列和两个对角线上的值的和互不相等的情况\n旋转镜像算一种\n思路：\n\n全排列代码，将递归出口改为题意\n旋转看边，镜像一般为 2\n\n代码：\npublic class Permutation &#123;    static int[] arr = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;    static int ans = 0;    public static void main(String[] args) &#123;        dfs(0);        System.out.println(ans/8);// 旋转看边数，镜像一般为 2    &#125;    static void dfs(int m) &#123;        if (m &gt;= 9) &#123;// 一次排列完成，进行判断            int a=arr[0]+arr[1]+arr[2];            int b=arr[3]+arr[4]+arr[5];            int c=arr[6]+arr[7]+arr[8];            int x=arr[0]+arr[3]+arr[6];            int y=arr[1]+arr[4]+arr[7];            int z=arr[2]+arr[5]+arr[8];            int i=arr[0]+arr[4]+arr[8];            int j=arr[2]+arr[4]+arr[6];            if (a==b||a==c||a==x||a==y||a==z||a==i||a==j)                return;            if (b==c||b==x||b==y||b==z||b==i||b==j)                return;            if (c==x||c==y||c==z||c==i||c==j)                return;            if (x==y||x==z||x==i||x==j)                return;            if (y==z||y==i||y==j)                return;            if (z==i||z==j)                return;            if (i==j)                return;            ans++;        &#125;        for (int i = m; i &lt; arr.length; i++) &#123;            int t = arr[i];            arr[i] = arr[m];            arr[m] = t;            dfs(m + 1);            t = arr[i];            arr[i] = arr[m];            arr[m] = t;        &#125;    &#125;&#125;\n 路径之谜\n题目：\n假设城堡地面是 n x n 个方格。\n从西北角走到东南角，可以横向或纵向移动，但不能斜着走，也不能跳跃。\n每走到一个新方格，就要向正北方和正西方各射一箭（西和北各有 n 个靶子）\n同一个方格只允许经过一次。但不必做完所有的方格。\n如果只给出靶子上箭的数目，你能推断行走路线吗？\n有时是可以的，比如图中的例子。\n已知箭靶数字，求行走路径（测试数据保证路径唯一）\n输入\n第一行一个整数 N(0&lt;N&lt;20)，表示地面有 N x N 个方格\n第二行 N 个整数，空格分开，表示北边的箭靶上的数字（自西向东）\n第三行 N 个整数，空格分开，表示西边的箭靶上的数字（自北向南）\n输出\n一行若干个整数，表示骑士路径。\n为了方便表示，我们约定每个小格子用一个数字代表，从西北角开始编号：0, 1, 2, 3…\n比如，图中的方块编号为：\n\n0  1  2  3\n\n4  5  6  7\n8  9  10 11\n12 13 14 15\n样例输入\n\n4\n\n2 4 3 4\n4 3 3 3\n样例输出\n\n0 4 5 1 2 3 7 11 10 9 13 14 15\n\n思路：\n\n要想走相同的路线，可以设置为每走一步，拔掉北边和西边靶子上的箭，这样最后所以的靶子都清零，就表示路径是相同的\n使用 DFS 搜索\n需注意几点\n\n入口（0，0）为必经点，在放入方法时就要拔掉对应的箭\n路线不能重复，定义 flag 数组进行记录\n得到的结果放入 ArrayList 集合中便于模拟失败后删除\n\n\n\n代码：\npublic class MysteryPath &#123;    static int n;// 记录格数 n*n    static int[] west;// 西边的靶子    static int[] north;// 北边的靶子    static boolean[][] flag;// 标记是否走过    static int[] dx = new int[]&#123;1, 0, -1, 0&#125;;// 记录行走的方式    static int[] dy = new int[]&#123;0, 1, 0, -1&#125;;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        n = in.nextInt();        west = new int[n];        north = new int[n];        flag = new boolean[n][n];        for (int i = 0; i &lt; n; i++)            north[i] = in.nextInt();        for (int i = 0; i &lt; n; i++)            west[i] = in.nextInt();        west[0]--;// 左上角的方格为入口，必经        north[0]--;        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        list.add(0);        flag[0][0] = true;        dfs(0, 0, list);    &#125;    static void dfs(int x, int y, ArrayList&lt;Integer&gt; list) &#123;        if (x == n - 1 &amp;&amp; y == n - 1) &#123;// 到达右下的方格            for (int i = 0; i &lt; n; i++)                if (west[i] &gt; 0 || north[i] &gt; 0)// 模拟的路径若是相同所有的的靶子应该归零                    return;            //System.out.println(&quot;!&quot;+c[i]+&quot; &quot;+r[i]);            for (Integer integer : list) //==for (int i = 0; i &lt; list.size(); i++)// 符合条件将放入集合的路径变量读取出来                System.out.print(integer + &quot; &quot;);            System.out.println();            return;        &#125;        for (int i = 0; i &lt; 4; i++) &#123;// 四个方向            int row = x + dx[i];// 走出之后的行            int colum = y + dy[i];// 走出之后的列            if (row &gt;= 0 &amp;&amp; row &lt; n &amp;&amp; colum &gt;= 0 &amp;&amp; colum &lt; n &amp;&amp; !flag[row][colum] &amp;&amp; west[row] &gt; 0 &amp;&amp; north[colum] &gt; 0) &#123;                // 不能越界；不能重复；不能是没射过箭的                west[row]--;// 按原路走拔掉每一行的箭                north[colum]--;                list.add(row * n + colum);// 行号 * N+ 列号就是方格的下标，放入集合中                flag[row][colum] = true;// 标记走过                dfs(row, colum, list);// 继续下一步                //Reset in trace                flag[row][colum] = false;                list.remove(list.size() - 1);                west[row]++;                north[colum]++;            &#125;        &#125;    &#125;&#125;\n 2015 年\n 分机号\n题目：\n有一种三位数的号码，符合以下两种条件：\n降序排列且每位都不重复\n如符合条件的：732；641；520\n不符合条件的：660；123；201\n思路：\n\n三重循环嵌套进行枚举\n第一层循环的变量从 1 开始，三位数的百位不能为零\n降序且重复可以用 i &gt; j &amp;&amp; i &gt; k &amp;&amp; j &gt; k 进行判断\n\n代码：\npublic static void main(String[] args) &#123;    long ans = 0;    for (int i = 1; i &lt; 10; i++) &#123;// 百位不为零        for (int j = 0; j &lt; 10; j++) &#123;            for (int k = 0; k &lt; 10; k++) &#123;                if (i &gt; j &amp;&amp; i &gt; k &amp;&amp; j &gt; k) &#123;// 定义降序且不重复条件                    ans++;                    System.out.println(&quot;&quot; + i + j + k);                &#125;            &#125;        &#125;    &#125;    System.out.println(ans);&#125;\n 五星填数\n题目：\n五星图案节点填上数字：1~12，除去 7 和 11。\n要求每条直线上数字和相等。\n请你利用计算机搜索所有可能的填法有多少种。\n注意：旋转或镜像后相同的算同一种填法。\n思路：\n\n将 1~12 进行全排列，五个一组按照相应的下标相加，符合条件 ans++\n其中有 5 种旋转，2 种镜像，所以最后的结果 ans/10\ndfs 中的循环变量，要从 dfs 变量开始，否则越界\n\n代码：\npublic class FiveStars &#123;    static int[] arr = &#123;1, 2, 3, 4, 5, 6, 8, 9, 10, 12&#125;;    static int ans = 0;    public static void main(String[] args) &#123;        dfs(0);        System.out.println(ans / 10);// 最后的结果去掉旋转和镜像 5*2    &#125;    static void dfs(int m) &#123;        if (m == 10) &#123;// 完成一次全排列            if (arr[1] + arr[2] + arr[3] + arr[4] != arr[0] + arr[2] + arr[5] + arr[8])                return;            if (arr[1] + arr[2] + arr[3] + arr[4] != arr[0] + arr[3] + arr[6] + arr[9])                return;            if (arr[1] + arr[2] + arr[3] + arr[4] != arr[1] + arr[5] + arr[7] + arr[9])                return;            if (arr[1] + arr[2] + arr[3] + arr[4] != arr[4] + arr[6] + arr[7] + arr[8])                return;            ans++;// 符合就答案加一        &#125;        for (int i = m; i &lt; 10; i++) &#123;//i 从 m 开始            int t = arr[i];            arr[i] = arr[m];            arr[m] = t;            dfs(m + 1);            t = arr[i];            arr[i] = arr[m];            arr[m] = t;        &#125;    &#125;&#125;\n 立方变自身\n有一个数 N，若它的各位相加等于它本身\n\n83=512  5+1+2=8\n\n求总共有多少个这样的数\n代码：\npublic static void main(String[] args) &#123;    int ans = 0;    for (int i = 1; i &lt; 30; i++) &#123;// 最大到 27，实际运算中将范围扩大        int pow = (int) Math.pow(i, 3);        int sum = 0;        while (pow != 0) &#123;            sum += pow % 10;            pow /= 10;        &#125;        if (sum == i)            ans++;    &#125;    System.out.println(ans);&#125;\n 加法变乘法\n题目：\n1+2+3+4+···+49=1225\n将其中两个不相邻的加号变为乘号，使得结果变为 2015\n\n1+2+3+···+1011+12+···+2728+29+···+49=2015\n\n寻找另一个符合条件的答案，将左边的数进行提交\n思路：\n\n两个乘号也就是改变四个数，那可以设置两层循环进行控制\n首先定义 sum=1225，让 sum 减去第一层循环的 i 和 i+1，然后减去第二层的 j 和 j+1，得到的值再加上 i*(i+1) 和 j*(j+1)，若最后的结果 ==2015，输出 i 即可\n\n代码：\npublic static void main(String[] args) &#123;    for (int i = 1; i &lt;= 49; i++) &#123;        for (int j = i + 1; j &lt;= 49; j++) &#123;//i 要与后边的数相乘，所以 j 从 i+1 开始            int ans = 1225;            ans -= i + (i + 1);            ans -= j + (j + 1);            ans += i * (i + 1) + j * (j + 1);            if (ans == 2015)                System.out.println(i + &quot; &quot; + j);        &#125;    &#125;&#125;\n 穿越雷区\n题目：\n坦克必须交替地穿越正能量辐射区和负能量辐射区才能保持正常运转，否则将报废。\n某坦克需要从 A 区到 B 区去（A，B 区本身是安全区，没有正能量或负能量特征），怎样走才能路径最短？\n已知的地图是一个方阵，上面用字母标出了 A，B 区，其它区都标了正号或负号分别表示正负能量辐射区。\n例如：\n\nA + - + -\n\n\n- + - - +\n\n\n- + + + -\n\n\n+ - + - +\n\n\nB + - + -\n\n坦克车只能水平或垂直方向上移动到相邻的区。\n数据格式要求：\n输入第一行是一个整数 n，表示方阵的大小， 4&lt;=n&lt;100\n接下来是 n 行，每行有 n 个数据，可能是 A，B，+，- 中的某一个，中间用空格分开。\nA，B 都只出现一次。\n要求输出一个整数，表示坦克从 A 区到 B 区的最少移动步数。\n如果没有方案，则输出 -1\n样例输入\n\n5\n\n\nA + - + -\n\n\n- + - - +\n\n\n- + + + -\n\n\n+ - + - +\n\n\nB + - + -\n\n样例输出\n10\n思路：\n\n最短路径用 BFS 较好，但需要考虑优先队列的使用，这里采用 DFS+ 最大值比较的方式\n需要设置的有，标记数组 flag 和前进数组 next\ndfs 出口可以采用 String 自带的。equals 比较，判断当前数组的内容是否为 &quot;B&quot;，寻找所有的路径进行比较，只保留最小值\nDFS 体，需要考虑越界和是否正负极连续以及标记数组是否为零\n\n代码：\npublic class AcrossMinefield &#123;    static int[][] next = &#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;;// 下一步的方向，分别为：上，下，左，右    static int ans = Integer.MAX_VALUE;// 取最小，先赋予一个较大值    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        String[][] map = new String[n][n];// 记录地图        int[][] flag = new int[n][n];// 1 代表访问过，0 代表未访问过        int x = 0;        int y = 0;// 入口坐标        for (int i = 0; i &lt; map.length; i++) &#123;            for (int j = 0; j &lt; map[i].length; j++) &#123;                map[i][j] = sc.next();// 用空格分割，按字符串存储                if (map[i][j].equals(&quot;A&quot;)) &#123;                    x = i;                    y = j;                &#125;            &#125;        &#125;        dfs(map, flag, x, y, 0);        System.out.println(ans);        sc.close();    &#125;    public static void dfs(String[][] map, int[][] visit, int row, int col, int step) &#123;        if (map[row][col].equals(&quot;B&quot;)) &#123;// 到达 B 为出口            if (step &lt; ans)                ans = step;            return;        &#125;        visit[row][col] = 1;// 将走过的点标记        for (int i = 0; i &lt; next.length; i++) &#123;            int nextRow = row + next[i][0];            int nextCol = col + next[i][1];// 下一步            if (nextRow &lt; 0 || nextRow &gt;= map.length || nextCol &lt; 0 || nextCol &gt;= map.length)                continue;// 越界直接进入下一层循环            if (visit[nextRow][nextCol] == 0) &#123;// 没有走过                visit[nextRow][nextCol] = 1;                if (!map[nextRow][nextCol].equals(map[row][col]))// 不能相等，必须 +- 交替                    dfs(map, visit, nextRow, nextCol, step + 1);                visit[nextRow][nextCol] = 0;// Reset in trace            &#125;        &#125;    &#125;&#125;\n 表格计算\n题目：\n某次无聊中， atm 发现了一个很老的程序。这个程序的功能类似于 Excel ，它对一个表格进行操作。\n不妨设表格有 n 行，每行有 m 个格子。\n每个格子的内容可以是一个正整数，也可以是一个公式。\n公式包括三种：\n\nSUM(x1,y1:x2,y2) 表示求左上角是第 x1 行第 y1 个格子，右下角是第 x2 行第 y2 个格子这个矩形内所有格子的值的和。\nAVG(x1,y1:x2,y2) 表示求左上角是第 x1 行第 y1 个格子，右下角是第 x2 行第 y2 个格子这个矩形内所有格子的值的平均数。\nSTD(x1,y1:x2,y2) 表示求左上角是第 x1 行第 y1 个格子，右下角是第 x2 行第 y2 个格子这个矩形内所有格子的值的标准差。\n\n\n标准差即为方差的平方根。\n\n方差就是：每个数据与平均值的差的平方的平均值，用来衡量单个数据离开平均数的程度。\n公式都不会出现嵌套。\n如果这个格子内是一个数，则这个格子的值等于这个数，否则这个格子的值等于格子公式求值结果。\n输入这个表格后，程序会输出每个格子的值\n输入格式\n第一行两个数 n, m 。\n接下来 n 行输入一个表格。每行 m 个由空格隔开的字符串，分别表示对应格子的内容。\n输入保证不会出现循环依赖的情况，即不会出现两个格子 a 和 b 使得 a 的值依赖 b 的值且 b 的值依赖 a 的值。\n输出格式\n输出一个表格，共 n 行，每行 m 个保留两位小数的实数。\n数据保证不会有格子的值超过 1e6 。\n样例输入\n\n3 2\n\n1 SUM(2, 1:3, 1)\n2 AVG(1, 1:1, 2)\nSUM(1, 1:2, 1) STD(1, 1:2, 2)\n样例输出\n\n1.00 5.00\n\n2.00 3.00\n3.00 1.48\n思路：\n\n因为有 SUM(2,1:3,1) 这种形式的输入，所以必须用字符串进行存储，定义一个string[][]\n存储完成后进行遍历，对每个数组的第一位进行检查，不是数字则放入方法中进行检查\n检查方法，首先要将括号中的坐标进行记录，可以用 int[] 记录对下标为 4、6、8、10 进行 -'0’处理转换为整型\n然后截取前三位进行字母比较判断其是哪种方法，然后分情况进行处理\n\n代码：\npublic class TableCalculation &#123;    static int n, m;// 表格规模    static String[][] s = new String[55][55];    static double[][] val = new double[55][55];    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        n = sc.nextInt();        m = sc.nextInt();        for (int i = 1; i &lt;= n; i++) &#123;            for (int j = 1; j &lt;= m; j++) &#123;                s[i][j] = sc.next();            &#125;        &#125;        for (int i = 1; i &lt;= n; i++) &#123;            for (int j = 1; j &lt;= m; j++) &#123;                if (s[i][j].charAt(0) &lt; &#x27;0&#x27; || s[i][j].charAt(0) &gt; &#x27;9&#x27;) &#123;                    val[i][j] = convert(s[i][j]);// 如果数组中存放的不是正常数字，就放到转换方法中                &#125; else &#123;                    val[i][j] = Double.parseDouble(s[i][j]);// 是的话转换为 double 型                &#125;            &#125;        &#125;        for (int i = 1; i &lt;= n; i++) &#123;            for (int j = 1; j &lt; m; j++) &#123;                System.out.printf(&quot;%.2f &quot;, val[i][j]);            &#125;            System.out.printf(&quot;%.2f\\n&quot;, val[i][m]);        &#125;    &#125;    static int[] sub(String s) &#123;// 找到方法中坐标的值，放入 c[1]~c[4]        int[] c = new int[6];        for (int i = 0; i &lt; c.length; i++)            c[i] = 0;        c[1] = s.charAt(4) - &#x27;0&#x27;;        c[2] = s.charAt(6) - &#x27;0&#x27;;        c[3] = s.charAt(8) - &#x27;0&#x27;;        c[4] = s.charAt(10) - &#x27;0&#x27;;        return c;    &#125;    static double convert(String string) &#123;// 将公式进行判断转换        int c[] = sub(string);        if (string.substring(0, 3).equals(&quot;SUM&quot;)) &#123;            return sum(c);        &#125; else if (string.substring(0, 3).equals(&quot;STD&quot;)) &#123;            return std(c);        &#125; else            return avg(c);    &#125;    static double sum(int a[]) &#123;        double ans = 0;        for (int i = a[1]; i &lt;= a[3]; i++) &#123;            for (int j = a[2]; j &lt;= a[4]; j++) &#123;// 根据坐标范围就所有的集合                if (s[i][j].charAt(0) &lt; &#x27;0&#x27; || s[i][j].charAt(0) &gt; &#x27;9&#x27;)                    ans += convert(s[i][j]);                else                    ans += Double.parseDouble(s[i][j]);// 转换为 double 型            &#125;        &#125;        return ans;    &#125;    static double avg(int a[]) &#123;        double ans = sum(a);        double cnt = (a[3] - a[1] + 1) * (a[4] - a[2] + 1);// 根据方格数求出个数        return ans / cnt;    &#125;    static double std(int a[]) &#123;// 求方差        double ans = 0;        double ave = avg(a);        double cnt = (a[3] - a[1] + 1) * (a[4] - a[2] + 1);        for (int i = a[1]; i &lt;= a[3]; i++) &#123;            for (int j = a[2]; j &lt;= a[4]; j++) &#123;                if (s[i][j].charAt(0) &lt; &#x27;0&#x27; || s[i][j].charAt(0) &gt; &#x27;9&#x27;)                    ans += (convert(s[i][j]) - ave) * (convert(s[i][j]) - ave);                else                    ans += (Double.parseDouble(s[i][j]) - ave) * (Double.parseDouble(s[i][j]) - ave);            &#125;        &#125;        return Math.sqrt(ans / cnt);    &#125;&#125;\n 2014 年\n 国王的遗产\n题目：\n国王 K 有 6 个儿子。在临终前，K 国王立下遗嘱：国王的一批牛作为遗产要分给他的 6 个儿子。\n其中，大儿子分 1/4，二儿子 1/5，三儿子 1/6，…\n直到小儿子分 1/9。\n牛是活的，不能把一头牛切开分。\n最后还剩下 11 头牛，分给管家。\n请计算国王这批遗产中一共有多少头牛。\n思路：\n\n首先牛必须是整只，所以用最后的数取整，但比例必须用双精度存储\n用 1 减去每个儿子所占的比例，就是最后 11 头牛剩余的，用11/ 所占比 = 总数\n\n代码：\npublic static void main(String[] args) &#123;    double m = 1 - 1 / 4.0 - 1 / 5.0 - 1 / 6.0 - 1 / 7.0 - 1 / 8.0 - 1 / 9.0;//11 头牛所占的比例    System.out.println(11 / m);//11 除以自身的比例等于全部&#125;\n 六角幻方\n题目：\n把 1 2 3 … 19 共 19 个整数排列成六角形状，如下：\n要求每个直线上的数字之和必须相等。共有 15 条直线哦！\n预先填好了 2 个数字，第一行的头两个数字是：15 13。\n请你填写出中间一行的 5 个数字。数字间用空格分开\n思路：\n\n在不改变前两个数字的情况下进行全排列\n剪枝，每遍历完一行，就进行横向和斜向的对比\n\n代码：\npublic class MagicHexagon &#123;    static int[] a = new int[]&#123;15, 13, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 16, 17, 18, 19&#125;;    static int ans = 0;    public static void main(String[] args) &#123;        dfs(2);        System.out.println(ans);    &#125;    static void dfs(int m) &#123;        if (m == 7) &#123;            if (a[0] + a[1] + a[2] != a[3] + a[4] + a[5] + a[6])                return;        &#125;        if (m == 12) &#123;            if (a[0] + a[1] + a[2] != a[7] + a[8] + a[9] + a[10] + a[11])                return;            if (a[0] + a[1] + a[2] != a[0] + a[3] + a[7])                return;            if (a[0] + a[1] + a[2] != a[2] + a[6] + a[11])                return;        &#125;        if (m == 16) &#123;            if (a[0] + a[1] + a[2] != a[12] + a[13] + a[14] + a[15])                return;            if (a[0] + a[1] + a[2] != a[1] + a[4] + a[8] + a[12])                return;            if (a[0] + a[1] + a[2] != a[1] + a[5] + a[10] + a[15])                return;        &#125;        if (m == 19) &#123;            if (a[0] + a[1] + a[2] != a[16] + a[17] + a[18])                return;            if (a[0] + a[1] + a[2] != a[7] + a[12] + a[16])                return;            if (a[0] + a[1] + a[2] != a[3] + a[8] + a[13] + a[17])                return;            if (a[0] + a[1] + a[2] != a[0] + a[4] + a[9] + a[14] + a[18])                return;            if (a[0] + a[1] + a[2] != a[11] + a[15] + a[18])                return;            if (a[0] + a[1] + a[2] != a[6] + a[10] + a[14] + a[17])                return;            if (a[0] + a[1] + a[2] != a[2] + a[5] + a[9] + a[13] + a[16])                return;        &#125;        if (m &gt;= 19) &#123;            for (int i = 7; i &lt;= 11; i++)                System.out.print(a[i] + &quot; &quot;);            System.out.println();            ans++;            return;        &#125;        for (int i = m; i &lt; 19; i++) &#123;            int t = a[i];            a[i] = a[m];            a[m] = t;            dfs(m + 1);            t = a[i];            a[i] = a[m];            a[m] = t;        &#125;    &#125;&#125;\n 排列序数\n题目：\n如果用 a b c d 这 4 个字母组成一个串，有 4!=24 种，如果把它们排个序，每个串都对应一个序号：\n\nabcd 0\n\nabdc 1\nacbd 2\nacdb 3\nadbc 4\nadcb 5\nbacd 6\nbadc 7\nbcad 8\nbcda 9\nbdac 10\nbdca 11\ncabd 12\ncadb 13\ncbad 14\ncbda 15\ncdab 16\ncdba 17\n现在有不多于 10 个两两不同的小写字母，给出它们组成的串，你能求出该串在所有排列中的序号吗？\n【输入格式】\n一行，一个串。\n【输出格式】\n一行，一个整数，表示该串在其字母所有排列生成的串中的序号。注意：最小的序号是 0。\n输入：\nbdca\n程序应该输出：\n11\n输入：\ncedab\n程序应该输出：\n70\n思路：\n\n先用递归进行模拟，从 ACSII 码 97（全小写字母）开始遍历，记录 97+length 的 n 个字符，然后与输入的字符串进行比对\n先模拟再放入递归中，以便于反向调换不至于影响顺序\n\n代码：\npublic class ArrangeNumber &#123;    static int len = 0;    static char[] res = new char[10];    static int[] mark = new int[150];    static long count = -1;// 序号从零开始，所以计数初始值为 -1    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        String str = sc.next();        len = str.length();// 记录字符串的长度        dfs(0, str);        sc.close();    &#125;    public static void dfs(int n, String end) &#123;        if (len == n) &#123;            count++;// 序号 +1            String str = String.valueOf(res).trim();// 将字符数组转换为字符串，没有 trim 会错误            if (str.equals(end)) &#123;// 等于输入的值说明模拟成功                System.out.println(count);            &#125;            return;        &#125;        for (int i = 97; i &lt; 97 + len; i++) &#123;// 字母全小写，从 ASCII 值 97 开始            if (mark[i] == 0) &#123;// 标记是否使用，防止一串字符中出现相同的字母                res[n] = ((char) i);                mark[i] = 1;                dfs(n + 1, end);// 先模拟后递归，到达出口后反向调换                mark[i] = 0;            &#125;        &#125;    &#125;&#125;\n 2013 年\n 猜灯谜\n题目：\n有一个灯谜公式：\n\n请猜谜 * 请猜谜 = 请边赏灯边猜\n\n若是用数字代替汉字，那么符合公式条件的“请猜谜”的三位数字是哪一个\n思路：\n\n读入数字可以采用每位分开多层循环嵌套，方便后续的计算\n枚举法对范围的判定：请猜谜的平方是一个六位数，所以从 317 开始至 999\n取余法将六位数的所需判断位保存下来（取 X 位，就用 N%(X+1)/X）\n在输出语句前加上双引号，使得整型直接按字符串输出System.out.println(&quot;&quot; + a + b + c);\n\n代码：\npublic static void main(String[] args) &#123;    Scanner sc = new Scanner(System.in);    for (int a = 3; a &lt;= 9; a++) &#123;// 从 317 开始结果才可能为六位        for (int b = 0; b &lt;= 9; b++) &#123;            if (a != b) &#123;//&quot; 请 &quot; 和 &quot; 猜 &quot; 必须不相同                for (int c = 0; c &lt;= 9; c++) &#123;                    int num = a * 100 + b * 10 + c;                    int pownum = num * num;                    int shiwan = pownum / 100000;                    int wan = pownum % 100000 / 10000;                    int shi = pownum % 100 / 10;                    int ge = pownum % 10;// 取 X 位，就用 N%(X+1)/X                    if (a == shiwan &amp;&amp; b == ge &amp;&amp; wan == shi)                        System.out.println(&quot;&quot; + a + b + c);// 通过加 &quot;&quot; 使 int 型输出为 String                &#125;            &#125;        &#125;    &#125;&#125;\n 连续奇数的和\n题目：\n任何数的立方都可以表示为连续奇数的和\n\n23=8=3+5\n\n33=27=7+9+11\n43=64=1+3+···+15\n那么 1113的连续奇数和表示法的第一个数字为？\n思路：\n\n设立双循环嵌套，每个循环的变量为i+=2，这样确保每次的都是奇数，定义 sum 将第二层循环的变量全部相加，当与 pow(111,3) 相等时，便输出第一层循环的变量值\n采用等差数列的思维，奇数的求和公式为Sn=n*n，当全部的数列和减去前 N 项数列和的值与 pow(111,3) 相等时，就可以确定 N 为第几项，然后用奇数等差数列的求项公式An=2*n-1, 将起始项（第 N 项）的值求出\n循环中进行判断当输出之后就可结束程序：System.exit(0);\n\n代码：\npublic static void main(String[] args) &#123;    int n = (int) Math.pow(111, 3);    // 方法一：枚举所有奇数项    for (int i = 1; i &lt;= n; i += 2) &#123;//i 每次加 2 确保为奇数        int sum = 0;        for (int j = i; j &lt;= n; j += 2) &#123;// 让 j 的初始值等于 i            sum += j;// 只要 sum&lt;=n 便一直加后边的奇数            if (sum &gt; n)                break;            if (sum == n) &#123;                System.out.println(i);                System.exit(0);// 直接退出            &#125;        &#125;    &#125;        // 方法二：利用奇数等差数列    // 奇数等差数列的求和公式：Sn=n*n; 求项：An=2*n-1;    // 将所有的奇数排列在一起：1，3，5，7···，end    // 从第 n 位开始一直到 end 的和 ==pow(111,3)，也就是 sum(1-end)-sum(1-(n-1))==pow(111,3)    // 由此可以确定第 n 项的值，根据 An=2*n-1 得出具体的数字    for (int i = 1; i &lt; 3000; i++) &#123;        for (int j = i; j &lt; 3000; j++) &#123;            if (j * j - (i - 1) * (i - 1) == n) &#123;                System.out.println(2 * i - 1);                System.exit(0);            &#125;        &#125;    &#125;&#125;\n 迷宫\n题目：\n定义一个 x*y 的地图，其中 0 表示通路，1 表示死路\n代码：\n/**    * DFS 算法解决走迷宫问题    * 0: 表示通路    * 1: 表示死路    */static String path = &quot;&quot;;static String shortestPath = &quot;&quot;;public static void main(String[] args) &#123;    // 初始化一个迷宫地图    // 0: 表示通路    // 1: 表示死路    Scanner sc = new Scanner(System.in);    int x = sc.nextInt();    int y = sc.nextInt();    int count = 0;    int[][] map = new int[x][y];    for (int i = 0; i &lt; x; i++)        for (int j = 0; j &lt; y; j++)            map[i][j] = sc.nextInt();    /*        * 从矩阵的左上角位置开始搜索        * */    dfs(0, 0, map);    if (shortestPath.length() != 0)        System.out.println(&quot; 最短路线为：&quot; + shortestPath);    else        System.out.println(&quot; 没有找到路线！&quot;);    char[] s = shortestPath.toCharArray();    for (char c : s) &#123;        if (c == &#x27;-&#x27;)            count++;    &#125;    System.out.println(count);&#125;public static void dfs(int x, int y, int[][] map) &#123;    /*        * 获得矩阵的大小        * */    int m = map.length;    int n = map[0].length;    // 设置结束条件    if (x &lt; 0 || y &lt; 0)        return;    // 如果坐标越界，或者 maze[x][y]==1 表示遇到障碍    if (x &gt; m - 1 || y &gt; n - 1)        return;    // 表示遇到障碍    if (map[x][y] == 1)        return; // 判断是否通路和越界    if (x == m - 1 &amp;&amp; y == n - 1) &#123; // 判断是否抵达出口        path = path + &quot;(&quot; + x + &quot;,&quot; + y + &quot;)&quot;;        if (shortestPath.length() == 0 || shortestPath.length() &gt; path.length())            shortestPath = path;        System.out.println(&quot; 找到路线：&quot; + path);        return;    &#125;    String temp = path;    path = path + &quot;(&quot; + x + &quot;,&quot; + y + &quot;)&quot; + &quot;-&quot;; // 记录路线    map[x][y] = 1; // 将走过的路标记    // 向四个方向搜索    dfs(x + 1, y, map);  // 向右搜索    dfs(x, y + 1, map);  // 向下搜索    dfs(x, y - 1, map);  // 向上搜索    dfs(x - 1, y, map);  // 向左搜索    // 将路线和标记恢复成上一次的状态    map[x][y] = 0;    // 清除    path = temp;&#125;\n 背包\n 0-1 背包\n题目：\n有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。\n第 i 件物品的体积是 Ui，价值是 Wi。\n求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。\n输入格式\n第一行两个整数，N， V，用空格隔开，分别表示物品数量和背包容积。\n接下来 N 行，每行两个整数 u, w; ，用空格隔开，分别表示第 i 件物品的体积和价值。\n输出格式\n输出一个整数，表示最大价值。\n输入样例\n\n4 5\n\n1 2\n2 4\n3 4\n4 5\n输出样例\n\n8\n\n代码：\nimport java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner sc=new Scanner(System.in);        int N=sc.nextInt();        int V=sc.nextInt();        int[] v=new int[N];        int[] w=new int[N];        for(int i=0;i&lt;N;i++)&#123;            v[i]=sc.nextInt();            w[i]=sc.nextInt();        &#125;        // int[][] dp=new int[N+1][V+1];        // for(int i=1;i&lt;=N;i++)&#123;        //     for(int j=0;j&lt;=V;j++)&#123;        //         dp[i][j]=dp[i-1][j];        //         if(j-v[i-1]&gt;=0)&#123;        //             dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-v[i-1]]+w[i-1]);        //         &#125;        //     &#125;        // &#125;        //  System.out.println(dp[N][V]);        int[] dp=new int[V+1];        for(int i=1;i&lt;=N;i++)&#123;            // 从大到小遍历            for(int j=V;j&gt;=0;j--)&#123;                if(j&gt;=v[i-1])&#123;                    dp[j]=Math.max(dp[j],dp[j-v[i-1]]+w[i-1]);                &#125;            &#125;        &#125;        System.out.println(dp[V]);    &#125;&#125;\n 完全背包\n题目：\n有 N 件物品和一个容量是 V 的背包。每件物品有无数件。\n第 i 件物品的体积是 Ui，价值是 Wi。\n求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。\n输入格式\n第一行两个整数，N， V，用空格隔开，分别表示物品数量和背包容积。\n接下来 N 行，每行两个整数 u, w; ，用空格隔开，分别表示第 i 件物品的体积和价值。\n输出格式\n输出一个整数，表示最大价值。\n输入样例\n\n4 5\n\n1 2\n2 4\n3 4\n4 5\n输出样例\n\n10\n\n代码：\nimport java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner sc=new Scanner(System.in);        int N=sc.nextInt();        int V=sc.nextInt();        int[] v=new int[N];        int[] w=new int[N];        for(int i=0;i&lt;N;i++)&#123;            v[i]=sc.nextInt();            w[i]=sc.nextInt();        &#125;        int[] dp=new int[V+1];        for(int i=0;i&lt;N;i++)&#123;            // 代码与 01 背包的区别，从小到大遍历            for(int j=0;j&lt;=V;j++)&#123;                if(j&gt;=v[i])&#123;                    dp[j]=Math.max(dp[j],dp[j-v[i]]+w[i]);                &#125;            &#125;        &#125;        System.out.println(dp[V]);    &#125;&#125;\n 多重背包（普通）\n每件物品有了个数，输入时输入三个值：体积、价值、数量\n代码：\nimport java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner sc=new Scanner(System.in);        int N=sc.nextInt();        int V=sc.nextInt();        int[] v=new int[N];        int[] w=new int[N];        int[] s=new int[N];        for(int i=0;i&lt;N;i++)&#123;            v[i]=sc.nextInt();            w[i]=sc.nextInt();            s[i]=sc.nextInt();        &#125;        // int[][] dp=new int[N+1][V+1];        // for(int i=1;i&lt;=N;i++)&#123;        //     for(int j=0;j&lt;=V;j++)&#123;        //         for(int k=0;k&lt;=s[i-1];k++)&#123;        //             if(j&gt;=k*v[i-1])&#123;        //                 dp[i][j]=Math.max(dp[i][j],dp[i-1][j-k*v[i-1]]+k*w[i-1]);        //             &#125;        //         &#125;        //     &#125;        // &#125;        // System.out.println(dp[N][V]);        int[] dp=new int[V+1];        for(int i=1;i&lt;=N;i++)&#123;            // 01 背包扩展，体积从大到小遍历            for(int j=V;j&gt;=0;j--)&#123;                // 对物品数量进行遍历                for(int k=0;k&lt;=s[i-1];k++)&#123;                    if(j&gt;=k*v[i-1])&#123;                        dp[j]=Math.max(dp[j],dp[j-k*v[i-1]]+k*w[i-1]);                    &#125;                &#125;            &#125;        &#125;        System.out.println(dp[V]);    &#125;&#125;\n 多重背包（大型数据）\n代码：\nimport java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner sc=new Scanner(System.in);        int N=sc.nextInt();        int V=sc.nextInt();        int[] v=new int[N];        int[] w=new int[N];        int[] s=new int[N];        for(int i=0;i&lt;N;i++)&#123;            v[i]=sc.nextInt();            w[i]=sc.nextInt();            s[i]=sc.nextInt();        &#125;        List&lt;good&gt; goods=new ArrayList&lt;&gt;();        // 转化为 01 背包问题，把物品数量拆成二进制组合，组合数能取到 0~s 中任意一个数        for(int i=0;i&lt;N;i++)&#123;            for(int k=1;k&lt;=s[i];k=k*2)&#123;                s[i]=s[i]-k;                goods.add(new good(k*v[i],k*w[i]));            &#125;            if(s[i]&gt;0)&#123;                goods.add(new good(s[i]*v[i],s[i]*w[i]));            &#125;        &#125;        int[] dp=new int[V+1];        for(int i=1;i&lt;=goods.size();i++)&#123;            for(int j=V;j&gt;=0;j--)&#123;                if(j&gt;=goods.get(i-1).v)&#123;                    dp[j]=Math.max(dp[j],dp[j-goods.get(i-1).v]+goods.get(i-1).w);                &#125;            &#125;        &#125;        System.out.println(dp[V]);    &#125;&#125;class good&#123;    int v;    int w;    public good(int v,int w)&#123;        this.v=v;        this.w=w;    &#125;&#125;\n 混合背包\n题目：\n有 N 件物品和一个容量是 V 的背包。\n物品一共有三类\n\n第一类物品只能用一次\n第二类物品可以用无限次\n第三类物品可以用 i 次\n\n求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。\n输入格式\n第一行两个整数，N， V，用空格隔开，分别表示物品数量和背包容积。\n接下来 N 行，每行两个整数 u, w, s; ，用空格隔开，分别表示第 i 件物品的体积、价值和数量。\n\ns==-1, 表示物品只能用一次\ns==0, 表示物品可以用无限次\ns&gt;0, 表示物品可以使用 s 次\n\n输出格式\n输出一个整数，表示最大价值。\n输入样例\n\n4 5\n\n1 2 -1\n2 4 1\n3 4 0\n4 5 2\n输出样例\n\n8\n\n代码：\nimport java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner sc=new Scanner(System.in);        int N=sc.nextInt();        int V=sc.nextInt();        List&lt;Thing&gt; things=new ArrayList&lt;&gt;();        for(int i=0;i&lt;N;i++)&#123;            int v=sc.nextInt();            int w=sc.nextInt();            int s=sc.nextInt();            if(s&lt;0)&#123;                things.add(new Thing(-1,v,w));            &#125;else if(s==0)&#123;                things.add(new Thing(0,v,w));            // 多重背包转化为 01 背包            &#125;else&#123;                for(int k=1;k&lt;=s;k=k*2)&#123;                    s=s-k;                    things.add(new Thing(-1,k*v,k*w));                &#125;                if(s&gt;0)&#123;                    things.add(new Thing(-1,s*v,s*w));                &#125;            &#125;        &#125;        int[] dp=new int[V+1];        for(int i=1;i&lt;=things.size();i++)&#123;            int kind=things.get(i-1).kind;            if(kind&lt;0)&#123;                // 01 背包，体积从大到小遍历                for(int j=V;j&gt;=things.get(i-1).v;j--)&#123;                    dp[j]=Math.max(dp[j],dp[j-things.get(i-1).v]+things.get(i-1).w);                &#125;            &#125;else&#123;                // 完全背包，体积从小到大遍历                for(int j=things.get(i-1).v;j&lt;=V;j++)&#123;                    dp[j]=Math.max(dp[j],dp[j-things.get(i-1).v]+things.get(i-1).w);                &#125;            &#125;        &#125;        System.out.println(dp[V]);    &#125;&#125;class Thing&#123;    int kind;    int v;    int w;    public Thing(int kind,int v,int w)&#123;        this.kind=kind;        this.v=v;        this.w=w;    &#125;&#125;\n","categories":["算法"],"tags":["Java"]},{"title":"PAT 甲级 - 模板库","url":"/pat_level_a-stl/","content":"\n\nC++ 中为使用者提供了标准的模板库也叫 STL，其中封装了大部分刷题所要用到的容器，而我在之前写过一篇《C++ STL》，所以这里就是单纯的记录一些类型题的解题思路，并不重复赘述具体的使用和含义 \n话说 C++ 中的容器在易用性和速度上做出的平衡要比其他语言强的不是一星半点，之前看过侯捷老师的手撕 STL 源码，后来转 Java 没能坚持看完，但仍感觉受益匪浅（虽说时间一长忘干净了），不知道什么原因 B 站上找不到了 \n\n vector\n 1039\n 题目：Course List for Student\nZhejiang University has 40000 students and provides 2500 courses. Now given the student name lists of all the courses, you are supposed to output the registered course list for each student who comes for a query.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains 2 positive integers: N (≤40, 000), the number of students who look for their course lists, and K (≤2, 500), the total number of courses. Then the student name lists are given for the courses (numbered from 1 to K) in the following format: for each course i, first the course index i and the number of registered students Ni (≤200) are given in a line. Then in the next line, Ni student names are given. A student name consists of 3 capital English letters plus a one-digit number. Finally the last line contains the N names of students who come for a query. All the names and numbers in a line are separated by a space.\nOutput Specification:\nFor each test case, print your results in N lines. Each line corresponds to one student, in the following format: first print the student’s name, then the total number of registered courses of that student, and finally the indices of the courses in increasing order. The query results must be printed in the same order as input. All the data in a line must be separated by a space, with no extra space at the end of the line.\nSample Input:\n\n11 5\n4 7\nBOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1\n1 4\nANN0 BOB5 JAY9 LOR6\n2 7\nANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR6\n3 1\nBOB5\n5 9\nAMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1\nZOE1 ANN0 BOB5 JOE4 JAY9 FRA8 DON2 AMY7 KAT3 LOR6 NON9\n\nSample Output:\n\nZOE1 2 4 5\nANN0 3 1 2 5\nBOB5 5 1 2 3 4 5\nJOE4 1 2\nJAY9 4 1 2 4 5\nFRA8 3 2 4 5\nDON2 2 4 5\nAMY7 1 5\nKAT3 3 2 4 5\nLOR6 4 1 2 4 5\nNON9 0\n\n 思路： 使用 map 搭配 vector 动态数组进行课程编号和姓名的映射存放，因数据规模过大，不要使用 cin 和 cout，姓名使用 char 数组存储，避免使用字符串，查询输出时，进行编号的排序 \n 代码：\n#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std; int main()&#123;    int n, k;    scanf(&quot;%d %d&quot;, &amp;n, &amp;k);    map&lt;string, vector&lt;int&gt;&gt; list;// 建立集合，用姓名映射课程的方式     char name[5];// 直接输入字符串会超时，使用字符数组的方式     for (int i = 0; i &lt; k; i++)    &#123;        int id, cnt;        scanf(&quot;%d %d&quot;, &amp;id, &amp;cnt);        for (int j = 0; j &lt; cnt; j++)        &#123;            scanf(&quot;%s&quot;, name);            list[name].push_back(id);// 根据姓名将课程 ID 放入         &#125;    &#125;    for (int i = 0; i &lt; n; i++)    &#123;        scanf(&quot;%s&quot;, name);        vector&lt;int&gt; v = list[name];// 查询时放入临时数组         printf(&quot;%s %d&quot;, name, v.size());        sort(v.begin(), v.end());// 排序后输出         for (int j = 0; j &lt; v.size(); j++)        &#123;            printf(&quot; %d&quot;, v[j]);        &#125;        printf(&quot;\\n&quot;);    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1047\n 题目：Student List for Course\nZhejiang University has 40,000 students and provides 2,500 courses. Now given the registered course list of each student, you are supposed to output the student name lists of all the courses.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains 2 numbers: N (≤40,000), the total number of students, and K (≤2,500), the total number of courses. Then N lines follow, each contains a student’s name (3 capital English letters plus a one-digit number), a positive number C (≤20) which is the number of courses that this student has registered, and then followed by C course numbers. For the sake of simplicity, the courses are numbered from 1 to K.\nOutput Specification:\nFor each test case, print the student name lists of all the courses in increasing order of the course numbers. For each course, first print in one line the course number and the number of registered students, separated by a space. Then output the students’ names in alphabetical order. Each name occupies a line.\nSample Input:\n\n10 5\nZOE1 2 4 5\nANN0 3 5 2 1\nBOB5 5 3 4 2 1 5\nJOE4 1 2\nJAY9 4 1 2 5 4\nFRA8 3 4 2 5\nDON2 2 4 5\nAMY7 1 5\nKAT3 3 5 4 2\nLOR6 4 2 4 1 5\n\nSample Output:\n\n1 4\nANN0\nBOB5\nJAY9\nLOR6\n2 7\nANN0\nBOB5\nFRA8\nJAY9\nJOE4\nKAT3\nLOR6\n3 1\nBOB5\n4 7\nBOB5\nDON2\nFRA8\nJAY9\nKAT3\nLOR6\nZOE1\n5 9\nAMY7\nANN0\nBOB5\nDON2\nFRA8\nJAY9\nKAT3\nLOR6\nZOE1\n\n 思路： 使用 map 映射 vector 字符串数组即可 \n 代码：\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;/*int main()&#123;    int n, m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    map&lt;int, vector&lt;string&gt;&gt; list;    char name[5];    for (int i = 0; i &lt; n; i++)    &#123;        int k;        scanf(&quot;%s %d&quot;, name, &amp;k);        for (int j = 0; j &lt; k; j++)        &#123;            int temp;            scanf(&quot;%d&quot;, &amp;temp);            list[temp].push_back(name);        &#125;    &#125;    for (int i=1;i&lt;=m;i++)    &#123;        vector&lt;string&gt; str = list[i];        printf(&quot;%d %d\\n&quot;, i, str.size());        sort(str.begin(), str.end());        for (int j = 0; j &lt; str.size(); j++)        &#123;            printf(&quot;%s\\n&quot;,str[j].c_str());        &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;*/int n, k, c, idx;vector&lt;vector&lt;string&gt;&gt; course;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    course.resize(k + 1);    for (int i = 0; i &lt; n; ++i)    &#123;        string name;        cin &gt;&gt; name &gt;&gt; c;        for (int j = 0; j &lt; c; ++j)        &#123;            scanf(&quot;%d&quot;, &amp;idx);            course[idx].push_back(name);        &#125;    &#125;    for (int i = 1; i &lt;= k; ++i)    &#123;        printf(&quot;%d %d\\n&quot;, i, course[i].size());        sort(course[i].begin(), course[i].end());        for (int j = 0; j &lt; course[i].size(); ++j)            printf(&quot;%s\\n&quot;, course[i][j].c_str());    &#125;    return 0;&#125;\n set\n 1063\n 题目：Set Similarity\nGiven two sets of integers, the similarity of the sets is defined to be Nc/Nt×100%, where Nc is the number of distinct common numbers shared by the two sets, and Nt is the total number of distinct numbers in the two sets. Your job is to calculate the similarity of any given pair of sets.\nInput Specification:\nEach input file contains one test case. Each case first gives a positive integer N (≤50) which is the total number of sets. Then N lines follow, each gives a set with a positive M(≤104)M (≤10^4)M(≤104) and followed by M integers in the range [0, 109]. After the input of sets, a positive integer K (≤2000) is given, followed by K lines of queries. Each query gives a pair of set numbers (the sets are numbered from 1 to N). All the numbers in a line are separated by a space.\nOutput Specification:\nFor each query, print in one line the similarity of the sets, in the percentage form accurate up to 1 decimal place.\nSample Input:\n\n3\n3 99 87 101\n4 87 101 5 87\n7 99 101 18 5 135 18 99\n2\n1 2\n1 3\n\nSample Output:\n\n50.0%\n33.3%\n\n 思路： 相似性的计算就是在集合 B 中出现过的集合 A 的元素除以所有不重复的元素和；注意：集合变量的名称不能时模板类的名称 \n 代码：\n#include &lt;iostream&gt;#include &lt;set&gt;using namespace std; int n, m; set&lt;int&gt; st[51]; void compare(int a, int b) // 将比较方法独立出来 &#123;    int samenum = 0, totalnum = st[b].size();    for (auto it = st[a].begin(); it != st[a].end(); it++)    &#123;        if (st[b].find(*it) != st[b].end())        &#123;            samenum++;        &#125;        else        &#123;            totalnum++;        &#125;    &#125;    printf(&quot;%.1f%\\n&quot;, samenum * 100.00 / totalnum); // 输出保留一位小数 &#125;int main()&#123;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)    &#123;        int size, temp;        cin &gt;&gt; size;        for (int j = 0; j &lt; size; j++)        &#123;            cin &gt;&gt; temp;            st[i].insert(temp); // 存储到 set 数组中         &#125;    &#125;    cin &gt;&gt; m;    for (int i = 0; i &lt; m; i++)    &#123;        int a, b;        cin &gt;&gt; a &gt;&gt; b;        compare(a, b); // 通过查找编号调用方法     &#125;    return 0;&#125;\n string\n 1060\n 题目：Are They Equal\nIf a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123×105 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine.\nInput Specification:\nEach input file contains one test case which gives three numbers N, A and B, where N (&lt;100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10100, and that its total digit number is less than 100.\nOutput Specification:\nFor each test case, print in a line YES if the two numbers are treated equal, and then the number in the standard form 0.d[1]...d[N]*10^k (d[1]&gt;0 unless the number is 0); or NO if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line.\nNote: Simple chopping is assumed without rounding.\nSample Input 1:\n\n3 12300 12358.9\n\nSample Output 1:\n\nYES 0.123*10^5\n\nSample Input 2:\n\n3 120 128\n\nSample Output 2:\n\nNO 0.12010^3 0.12810^3\n\n 思路： 只需判断保存有效数字的字符串和指数位数是否相同即可保证一对数字的相同，根据不同情况的处理封装在方法中 \n\n\n 指数在 main 方法中定义，使用 int&amp; e 的方式处理同一变量，否则无法返回两个变量 \n\n\n 在方法中首先去掉前导零，去掉后有三种情况，首字符为小数点为小数，否则为正数，若字符串长度为 0，为 0\n\n\n 当为小数时，去掉小数点，小数点后面 0 的个数即为指数 e 的值 \n\n\n 为正数时，向后寻找小数点或末尾，非 0 或末尾，指数 e++\n\n\n 最后根据输入 N 的值每次放入一个有效字符，不足补 0，返回判断即可 \n\n\n 代码：\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int n;string deal(string str, int &amp;e) // 字符串处理方法，指数 e 为恒定地址变量 &#123;    int k = 0;    while (str.length() &gt; 0 &amp;&amp; str[0] == &#x27;0&#x27;) // 将前导 0 去除     &#123;        str.erase(str.begin());    &#125;    if (str[0] == &#x27;.&#x27;) // 去掉 0 为小数点说明为小数     &#123;        str.erase(str.begin());        while (str.length() &gt; 0 &amp;&amp; str[0] == &#x27;0&#x27;) // 通过小数点后边 0 的个数获得指数的负数值         &#123;            str.erase(str.begin());            e--;        &#125;    &#125;    else // 不是小数点即为整数     &#123;        while (k &lt; str.length() &amp;&amp; str[k] != &#x27;.&#x27;) // 小数点之前的位数为指数值         &#123;            k++;            e++;        &#125;        if (k &lt; str.length()) // 最后 k 的值小于字符串长度说明有小数点，将其去掉         &#123;            str.erase(str.begin() + k);        &#125;    &#125;    if (str.length() == 0) // 如果去掉 0，字符串长度为 0，说明指数也为 0    &#123;        e = 0;    &#125;    int num = 0;    k = 0;    string dealed;    while (num &lt; n) // 保存 n 个有效数字     &#123;        if (k &lt; str.length())        &#123;            dealed += str[k++];        &#125;        else        &#123;            dealed += &#x27;0&#x27;;        &#125;        num++;    &#125;    return dealed;&#125;int main()&#123;    string s1, s2, s3, s4;    cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2;    int e1 = 0, e2 = 0;    s3 = deal(s1, e1);    s4 = deal(s2, e2);    if (s3 == s4 &amp;&amp; e1 == e2) // 通过有效数字和指数判断科学计数法是否相同     &#123;        cout &lt;&lt; &quot;YES 0.&quot; &lt;&lt; s3 &lt;&lt; &quot;*10^&quot; &lt;&lt; e1;    &#125;    else    &#123;        cout &lt;&lt; &quot;NO 0.&quot; &lt;&lt; s3 &lt;&lt; &quot;*10^&quot; &lt;&lt; e1 &lt;&lt; &quot; 0.&quot; &lt;&lt; s4 &lt;&lt; &quot;*10^&quot; &lt;&lt; e2;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n map\n 1100\n 题目：Mars Numbers\nPeople on Mars count their numbers with base 13:\n\n\nZero on Earth is called “tret” on Mars.\n\n\nThe numbers 1 to 12 on Earth is called “jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec” on Mars, respectively.\n\n\nFor the next higher digit, Mars people name the 12 numbers as “tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou”, respectively.\n\n\nFor examples, the number 29 on Earth is called “hel mar” on Mars; and “elo nov” on Mars corresponds to 115 on Earth. In order to help communication between people from these two planets, you are supposed to write a program for mutual translation between Earth and Mars number systems.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains a positive integer N (&lt;100). Then N lines follow, each contains a number in [0, 169), given either in the form of an Earth number, or that of Mars.\nOutput Specification:\nFor each number, print in a line the corresponding number in the other language.\nSample Input:\n\n4\n29\n5\nelo nov\ntam\n\nSample Output:\n\nhel mar\nmay\n115\n13\n\n 思路： 因为数据不会超过 169，直接采用打表的方式将每个数字与其“火星文”形式对应起来 \n\n\n 字符串数组对应数字转“火星文”，map&lt;string, int&gt; 对应“火星文”转数字 \n\n\n 打表将个位和整十位分为一种情况，其他分为一种情况，进行运算赋值即可 \n\n\n 代码：\n#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cstring&gt;using namespace std; string unitDigit[13] = &#123;&quot;tret&quot;, &quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;, &quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;&#125;; string tenDigit[13] = &#123;&quot;tret&quot;, &quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;, &quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;&#125;; // 将个位十位保存 string numToStr[170]; // 通过数字作为下标输出字符串 map&lt;string, int&gt; strToNum; // 通过字符串映射到数字 void init()&#123;    for (int i = 0; i &lt; 13; i++)    &#123;        numToStr[i] = unitDigit[i];        strToNum[unitDigit[i]] = i; // 存储个位的互相对应         numToStr[i * 13] = tenDigit[i];        strToNum[tenDigit[i]] = i * 13; // 存储整十位的互相对应     &#125;    for (int i = 1; i &lt; 13; i++)    &#123; // 每位的对应         for (int j = 1; j &lt; 13; j++)        &#123;            string str = tenDigit[i] + &quot; &quot; + unitDigit[j];            numToStr[i * 13 + j] = str;            strToNum[str] = i * 13 + j;        &#125;    &#125;&#125;int main()&#123;    init(); // 调用打表     int n;    cin &gt;&gt; n;    string query;    getchar();    for (int i = 0; i &lt; n; i++)    &#123;        getline(cin, query);        if (query[0] &gt;= &#x27;0&#x27; &amp;&amp; query[0] &lt;= &#x27;9&#x27;)        &#123;            int num = stoi(query); // 将属于数字的转换为 int 型             cout &lt;&lt; numToStr[num] &lt;&lt; endl;        &#125;        else        &#123;            cout &lt;&lt; strToNum[query] &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;\n 1054\n 题目：The Dominant Color\nBehind the scenes in the computer’s memory, color is always talked about as a series of 24 bits of information for each pixel. In an image, the color with the largest proportional area is called the dominant color. A strictly dominant color takes more than half of the total area. Now given an image of resolution M by N (for example, 800×600), you are supposed to point out the strictly dominant color.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains 2 positive numbers: M (≤800) and N (≤600) which are the resolutions of the image. Then N lines follow, each contains M digital colors in the range [0,224). It is guaranteed that the strictly dominant color exists for each input image. All the numbers in a line are separated by a space.\nOutput Specification:\nFor each test case, simply print the dominant color in a line.\nSample Input:\n\n5 3\n0 0 255 16777215 24\n24 24 0 0 24\n24 0 24 24 24\n\nSample Output:\n\n24\n\n 思路： map&lt;int,int&gt; 集合映射颜色与出现次数，当次数超过 M∗N/2M*N/2M∗N/2 时输出 \n 代码：\n#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main()&#123;    int m, n;    scanf(&quot;%d %d&quot;, &amp;m, &amp;n);    map&lt;int, int&gt; arr;    int half = m * n / 2;    for (int i = 0; i &lt; n; i++)    &#123;        for (int j = 0; j &lt; m; j++)        &#123;            int temp;            scanf(&quot;%d&quot;, &amp;temp);            arr[temp]++;            if (arr[temp] &gt; half)            &#123;                printf(&quot;%d&quot;, temp);                return 0;            &#125;        &#125;    &#125;    return 0;&#125;\n 1071\n 题目：Speech Patterns\nPeople often have a preference among synonyms of the same word. For example, some may prefer “the police”, while others may prefer “the cops”. Analyzing such patterns can help to narrow down a speaker’s identity, which is useful when validating, for example, whether it’s still the same person behind an online avatar.\nNow given a paragraph of text sampled from someone’s speech, can you find the person’s most commonly used word?\nInput Specification:\nEach input file contains one test case. For each case, there is one line of text no more than 1048576 characters in length, terminated by a carriage return \\n . The input contains at least one alphanumerical character, i.e., one character from the set [0-9 A-Z a-z ].\nOutput Specification:\nFor each test case, print in one line the most commonly occurring word in the input text, followed by a space and the number of times it has occurred in the input. If there are more than one such words, print the lexicographically smallest one. The word should be printed in all lower case. Here a “word” is defined as a continuous sequence of alphanumerical characters separated by non-alphanumerical characters or the line beginning/end.\nNote that words are case insensitive.\nSample Input:\n\nCan1: “Can a can can a can?  It can!”\n\nSample Output:\n\ncan 5\n\n 思路： 判断是否属于有效字符，遇到非法字符便截取之前有效的字符放到 map 集合中，注意：最后一位时，即便属于非法字符也要放入 \n 代码：\n#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cctype&gt;using namespace std; int main()&#123;    string str, temp;    map&lt;string, int&gt; mcount;    getline(cin, str);    for (int i = 0; i &lt; str.length(); i++)    &#123;        if (isalnum(str[i])) // 属于数字和字母         &#123;            if (isupper(str[i]))            &#123; // 大写转换为小写                 str[i] = tolower(str[i]);            &#125;            temp += str[i];        &#125;        if (!isalnum(str[i]) || i == str.length() - 1) // 非法字符或最后一位         &#123;            if (temp.length() != 0)            &#123;                mcount[temp]++; // 不为空便自增             &#125;            temp.clear();        &#125;    &#125;    int max = 0;    string ans;    for (auto it = mcount.begin(); it != mcount.end(); it++)    &#123;        if (it-&gt;second &gt; max)        &#123;            max = it-&gt;second;            ans = it-&gt;first; // 遍历求次数最大，记录输出         &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; &quot; &quot; &lt;&lt; max &lt;&lt; endl;    return 0;&#125;\n 1022\n 题目：Digital Library\nA Digital Library contains millions of books, stored according to their titles, authors, key words of their abstracts, publishers, and published years. Each book is assigned an unique 7-digit number as its ID. Given any query from a reader, you are supposed to output the resulting books, sorted in increasing order of their ID’s.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains a positive integer N (≤104) which is the total number of books. Then N blocks follow, each contains the information of a book in 6 lines:\n\n\nLine #1: the 7-digit ID number;\n\n\nLine #2: the book title – a string of no more than 80 characters;\n\n\nLine #3: the author – a string of no more than 80 characters;\n\n\nLine #4: the key words – each word is a string of no more than 10 characters without any white space, and the keywords are separated by exactly one space;\n\n\nLine #5: the publisher – a string of no more than 80 characters;\n\n\nLine #6: the published year – a 4-digit number which is in the range [1000, 3000].\n\n\nIt is assumed that each book belongs to one author only, and contains no more than 5 key words; there are no more than 1000 distinct key words in total; and there are no more than 1000 distinct publishers.\nAfter the book information, there is a line containing a positive integer M (≤1000) which is the number of user’s search queries. Then M lines follow, each in one of the formats shown below:\n\n\n1: a book title\n\n\n2: name of an author\n\n\n3: a key word\n\n\n4: name of a publisher\n\n\n5: a 4-digit number representing the year\n\n\nOutput Specification:\nFor each query, first print the original query in a line, then output the resulting book ID’s in increasing order, each occupying a line. If no book is found, print Not Found instead.\nSample Input:\n31111111The Testing BookYue Chentest code debug sort keywordsZUCS Print20113333333Another Testing BookYue Chentest code sort keywordsZUCS Print220122222222The Testing BookCYLLkeywords debug bookZUCS Print2201161: The Testing Book2: Yue Chen3: keywords4: ZUCS Print5: 20113: blablabla\nSample Output:\n1: The Testing Book111111122222222: Yue Chen111111133333333: keywords1111111222222233333334: ZUCS Print11111115: 2011111111122222223: blablablaNot Found\n 思路：\n\n\n 对除了 id 之外的其他信息都建立一个 map&lt;string, set&gt;，把相应的 id 插入对应搜索词的 map 的集合里面，形成一个信息对应一个集合，集合里面是复合条件的书的 id\n\n\n 因为对于输入的关键词（可以重复，算是书本对应的 tag 标签）没有给定关键词的个数，可以使用 while(cin &gt;&gt; s) 并且判断 c = getchar()，c 是否等于、n，如果是再退出循环 \n\n\n 建立 query，通过传参的形式可以将不同的 map 名称统一化，先要判断 map.find() 和 m.end() 是否相等，如果不等再去遍历整个 map，输出所有满足条件的 id，如果相等就说明不存在这个搜索词对应的 id，那么就要输出 Not Found\n\n\n 传参一定要用引用，否则最后一组数据可能会超时 \n\n\n 代码：\n#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;map&lt;string, set&lt;int&gt;&gt; title, author, key, pub, year; // 每类信息建立一个 map 集合映射 IDvoid query(map&lt;string, set&lt;int&gt;&gt; &amp;m, string &amp;str) // 查询方法使用引用的形式，防止大数据超市 &#123;    if (m.find(str) != m.end())    &#123;        for (auto it = m[str].begin(); it != m[str].end(); it++)            printf(&quot;%07d\\n&quot;, *it);    &#125;    else        cout &lt;&lt; &quot;Not Found\\n&quot;;&#125;int main()&#123;    int n, m, id, num;    scanf(&quot;%d&quot;, &amp;n);    string ttitle, tauthor, tkey, tpub, tyear;    for (int i = 0; i &lt; n; i++)    &#123;        scanf(&quot;%d\\n&quot;, &amp;id);        getline(cin, ttitle);        title[ttitle].insert(id);        getline(cin, tauthor);        author[tauthor].insert(id);        while (cin &gt;&gt; tkey) // 关键字使用分隔输入的形式         &#123;            key[tkey].insert(id);            char c = getchar();            if (c == &#x27;\\n&#x27;)                break;        &#125;        getline(cin, tpub);        pub[tpub].insert(id);        getline(cin, tyear);        year[tyear].insert(id);    &#125;    scanf(&quot;%d&quot;, &amp;m);    for (int i = 0; i &lt; m; i++)    &#123;        scanf(&quot;%d: &quot;, &amp;num);        string temp;        getline(cin, temp);        cout &lt;&lt; num &lt;&lt; &quot;: &quot; &lt;&lt; temp &lt;&lt; &quot;\\n&quot;;        if (num == 1) // 根据查询类型判断方法引用的集合             query(title, temp);        else if (num == 2)            query(author, temp);        else if (num == 3)            query(key, temp);        else if (num == 4)            query(pub, temp);        else if (num == 5)            query(year, temp);    &#125;    return 0;&#125;\n stack\n 1051\n 题目：Pop Sequence\nGiven a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.\nOutput Specification:\nFor each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.\nSample Input:\n\n5 7 5\n1 2 3 4 5 6 7\n3 2 1 7 5 6 4\n7 6 5 4 3 2 1\n5 6 4 3 7 2 1\n1 7 6 5 4 3 2\n\nSample Output:\n\nYES\nNO\nYES\nNO\n\n 思路： 使用 stack 模板模拟入栈，每放入一个元素后判断其与输出序列要输出的元素是否相同，相同后出栈，位数后移；\n有两种情况表示出栈顺序不对：1、当前入栈的元素超过栈的容量；2、模拟完成后栈不为空 \n 代码：\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std; stack&lt;int&gt; st; int main()&#123;    int m, n, k, arr[1001]; // 保存序列     cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;    while (k--)    &#123;        while (!st.empty()) // 将栈清空         &#123;            st.pop();        &#125;        for (int i = 1; i &lt;= n; i++)        &#123;            cin &gt;&gt; arr[i]; // 保存序列         &#125;        int current = 1;        bool flag = true;        for (int i = 1; i &lt;= n; i++)        &#123;            st.push(i);            if (st.size() &gt; m) // 当前个数超过容量             &#123;                flag = false;                break;            &#125;            while (!st.empty() &amp;&amp; st.top() == arr[current]) // 每放入一个元素判断出栈             &#123;                st.pop();                current++;            &#125;        &#125;        if (st.empty() &amp;&amp; flag) // 模拟完成后栈空和容量未超表示正确         &#123;            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;        &#125;        else        &#123;            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;\n queue\n 1056\n 题目：Mice and Rice\nMice and Rice is the name of a programming contest in which each programmer must write a piece of code to control the movements of a mouse in a given map. The goal of each mouse is to eat as much rice as possible in order to become a FatMouse.\nFirst the playing order is randomly decided for NP programmers. Then every NG programmers are grouped in a match. The fattest mouse in a group wins and enters the next turn. All the losers in this turn are ranked the same. Every NG winners are then grouped in the next match until a final winner is determined.\nFor the sake of simplicity, assume that the weight of each mouse is fixed once the programmer submits his/her code. Given the weights of all the mice and the initial playing order, you are supposed to output the ranks for the programmers.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains 2 positive integers: NP and NG (≤1000), the number of programmers and the maximum number of mice in a group, respectively. If there are less than NG mice at the end of the player’s list, then all the mice left will be put into the last group. The second line contains NP distinct non-negative numbers Wi (i=0,⋯,NP−1) where each Wi is the weight of the i-th mouse respectively. The third line gives the initial playing order which is a permutation of 0,⋯,NP−1 (assume that the programmers are numbered from 0 to NP−1). All the numbers in a line are separated by a space.\nOutput Specification:\nFor each test case, print the final ranks in a line. The i-th number is the rank of the i-th programmer, and all the numbers must be separated by a space, with no extra space at the end of the line.\nSample Input:\n\n11 3\n25 18 0 46 37 3 19 22 57 56 10\n6 0 8 7 10 5 9 1 4 2 3\n\nSample Output:\n\n5 5 5 2 5 5 5 3 1 3 5\n\n 思路： 根据输入重量时的顺序作为编号，保存到结构体的 weight 中，并将排列规则放入队列中，分组进行比较之后将每组的获胜者放入队列最后，判断一个便出队一个，当进行一轮的比较之后，队列后的就是下一轮的排列顺序，继续分组重复操作；每轮中个人的排名就是当前轮的组数 +1，进入下一轮的人员继续更新排名直到只剩一人时退出循环 \n 代码：\n#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct Mouse // 建立老鼠结构体 &#123;    int weight, rank;&#125;;int main()&#123;    Mouse mouse[1001];    int Np, Ng;    cin &gt;&gt; Np &gt;&gt; Ng;    for (int i = 0; i &lt; Np; i++) // 按输入顺序为其编号     &#123;        cin &gt;&gt; mouse[i].weight;    &#125;    queue&lt;int&gt; qu;    int order;    for (int i = 0; i &lt; Np; i++)    &#123;        cin &gt;&gt; order;        qu.push(order); // 将排列顺序放入队列中     &#125;    int temp = Np, group;  //temp 表示此轮的人员，group 表示分成几组     while (qu.size() != 1) // 角逐到只剩一个     &#123;        if (temp % Ng == 0)        &#123;            group = temp / Ng;        &#125;        else        &#123;            group = temp / Ng + 1;        &#125;        for (int i = 0; i &lt; group; i++)        &#123;            int k = qu.front(); //k 表示小组的胜出者             for (int j = 0; j &lt; Ng; j++)            &#123;                if (i * Ng + j &gt;= temp) // 存在最后一组数量不够的情况                 &#123;                    break;                &#125;                int front = qu.front();                if (mouse[front].weight &gt; mouse[k].weight)                &#123;                    k = front;                &#125;                mouse[front].rank = group + 1; // 每次都更新排名                 qu.pop();            &#125;            qu.push(k); // 每组最大的放到队列中进入下一轮         &#125;        temp = group; // 新一轮的成员数就是上一轮的组数     &#125;    mouse[qu.front()].rank = 1;    for (int i = 0; i &lt; Np; i++)    &#123;        cout &lt;&lt; mouse[i].rank;        if (i &lt; Np - 1)        &#123;            cout &lt;&lt; &quot; &quot;;        &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n linklist\n 1074\n 题目：Reversing Linked List\nGiven a constant K and a singly linked list L, you are supposed to reverse the links of every K elements on L. For example, given L being 1→2→3→4→5→6, if K=3, then you must output 3→2→1→6→5→4; if K=4, you must output 4→3→2→1→5→6.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains the address of the first node, a positive N (≤105) which is the total number of nodes, and a positive K (≤N) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.\nThen N lines follow, each describes a node in the format:\n\nAddress Data Next\n\nwhere Address is the position of the node, Data is an integer, and Next is the position of the next node.\nOutput Specification:\nFor each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.\nSample Input:\n\n00100 6 4\n00000 4 99999\n00100 1 12309\n68237 6 -1\n33218 3 00000\n99999 5 68237\n12309 2 33218\n\nSample Output:\n\n00000 4 33218\n33218 3 12309\n12309 2 00100\n00100 1 99999\n99999 5 68237\n68237 6 -1\n\n 思路： 建立链表的节点结构体，根据 next 的数据为其排序规则从小到大赋值，根据规则排序，就可以模拟链表的连接；处理完链表后根据分组的单组容量构建输出规则进行输出 \n**tips：** 整数型不管前导零有多少，始终存储有效数组，如：输入 00100，存储为 100\n 代码：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std; const int edge = 100010; struct Node // 定义链表的结点结构体 &#123;    int address, data, next;    int order; // 定义位置，后续排序 &#125;; bool cmp(Node a, Node b) // 排序规则 &#123;    return a.order &lt; b.order;&#125;int main()&#123;    Node node[edge];    for (int i = 0; i &lt; edge; i++)    &#123;        node[i].order = edge; // 将所有的规则定义为一个较大值     &#125;    int begin, n, k;    cin &gt;&gt; begin &gt;&gt; n &gt;&gt; k;    int address;    for (int i = 0; i &lt; n; i++) // 读入数据     &#123;        cin &gt;&gt; address;        cin &gt;&gt; node[address].data &gt;&gt; node[address].next;        node[address].address = address;    &#125;    int count = 0;    while (begin != -1)    &#123;        node[begin].order = count++; // 将规则的先后顺序定义         begin = node[begin].next;    &#125;    sort(node, node + edge, cmp);       // 排序连接起来     for (int i = 0; i &lt; count / k; i++) // 分块进行输出     &#123;        for (int j = (i + 1) * k - 1; j &gt; i * k; j--)        &#123;            printf(&quot;%05d %d %05d\\n&quot;, node[j].address, node[j].data, node[j - 1].address);        &#125;        // 每一组的最后一个数据进行判断输出         printf(&quot;%05d %d &quot;, node[i * k].address, node[i * k].data); // 输出数据         if (i &lt; count / k - 1)                                     // 如果不是最后一组         &#123;            printf(&quot;%05d\\n&quot;, node[(i + 2) * k - 1].address); // 输出越组后的最后一个（倒序的第一个）        &#125;        else        &#123;            if (count % k == 0) // 如果能整分组，输出 -1            &#123;                printf(&quot;-1\\n&quot;);            &#125;            else // 不能整分             &#123;                printf(&quot;%05d\\n&quot;, node[(i + 1) * k].address); // 不能分组的第一个的地址                 for (int l = count / k * k; l &lt; count; l++)  // 将其照常输出即可                 &#123;                    printf(&quot;%05d %d &quot;, node[l].address, node[l].data);                    if (l &lt; count - 1)                    &#123;                        printf(&quot;%05d\\n&quot;, node[l + 1].address);                    &#125;                    else                    &#123;                        printf(&quot;-1\\n&quot;);                    &#125;                &#125;            &#125;        &#125;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n 1032\n** 题目：Sharing **\nTo store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words share the same sublist if they share the same suffix. For example, loading and being are stored as showed in Figure 1.\nYou are supposed to find the starting position of the common suffix (e.g. the position of i in Figure 1).\nInput Specification:\nEach input file contains one test case. For each case, the first line contains two addresses of nodes and a positive N(≤105)N (≤10^5)N(≤105), where the two addresses are the addresses of the first nodes of the two words, and N is the total number of nodes. The address of a node is a 5-digit positive integer, and NULL is represented by −1.\nThen N lines follow, each describes a node in the format:\nAddress Data Next\nwhereAddress is the position of the node, Data is the letter contained by this node which is an English letter chosen from {a-z, A-Z}, and Next is the position of the next node.\nOutput Specification:\nFor each case, simply output the 5-digit starting position of the common suffix. If the two words have no common suffix, output -1 instead.\nSample Input 1:\n\n11111 22222 9\n67890 i 00002\n00010 a 12345\n00003 g -1\n12345 D 67890\n00002 n 00003\n22222 B 23456\n11111 L 00001\n23456 e 67890\n00001 o 00010\n\nSample Output 1:\n\n67890\n\n 思路： 建立一个范围足够的静态链表，遍历第一条链表，将出现过的节点标记，在遍历第二条时出现标记过的节点则输出下标 \n 代码：\n#include &lt;iostream&gt;using namespace std;const int edge = 100001;struct Node // 定义结构体 &#123;    char data;    int next;    bool flag; // 对第一条链表的出现的节点赋予正值 &#125;;int main()&#123;    Node node[edge];    for (int i = 0; i &lt; edge; i++)    &#123;        node[i].flag = false; // 将每一个节点初始设置为未出现     &#125;    int begin1, begin2, total;    cin &gt;&gt; begin1 &gt;&gt; begin2 &gt;&gt; total;    int address, next;    char data;    for (int i = 0; i &lt; total; i++)    &#123;        cin &gt;&gt; address &gt;&gt; data &gt;&gt; next;        node[address].data = data;        node[address].next = next;    &#125;    while (begin1 != -1) // 遍历第一条，对每一个节点做标记     &#123;        node[begin1].flag = true;        begin1 = node[begin1].next;    &#125;    while (begin2 != -1)    &#123;        if (node[begin2].flag)        &#123;            break; // 在第二条中出现被标记的节点跳出         &#125;        begin2 = node[begin2].next;    &#125;    if (begin2 != -1)    &#123;        printf(&quot;%05d&quot;, begin2);    &#125;    else    &#123;        printf(&quot;-1&quot;);    &#125;    return 0;&#125;\n 1052\n 题目：Linked List Sorting\nA linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer key and a Next pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains a positive N (&lt;105) and an address of the head node, where N is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by −1.\nThen N lines follow, each describes a node in the format:\nAddress Key Next\nwhere Address is the address of the node in memory, Key is an integer in [−105, 105], and Next is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node.\nOutput Specification:\nFor each test case, the output format is the same as that of the input, where N is the total number of nodes in the list and all the nodes must be sorted order.\nSample Input:\n\n5 00001\n11111 100 -1\n00001 0 22222\n33333 100000 11111\n12345 -1 33333\n22222 1000 12345\n\nSample Output:\n\n5 12345\n12345 -1 00001\n00001 0 11111\n11111 100 22222\n22222 1000 33333\n33333 100000 -1\n\n 思路： 题目要求只输出能够连接的节点，所以对节点结构体定义同一个标记变量，将有效的节点根据 data 的大小进行升序排序 \n 代码：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std; const int edge = 100001; struct Node&#123;    int address, data, next;    bool flag; // 存在无法连接的节点，创建标记属性 &#125;; bool cmp(Node a, Node b) // 根据数据大小进行排序 &#123;    if (a.flag == false || b.flag == false) // 只要 a 或 b 有一个不符合条件，就将其放置到最后     &#123;        return a.flag &gt; b.flag;    &#125;    else    &#123;        return a.data &lt; b.data; // 其他根据数据大小进行排序     &#125;&#125;int main()&#123;    Node node[edge];    for (int i = 0; i &lt; edge; i++)    &#123;        node[i].flag = false; // 先将所有节点的标记置为 false    &#125;    int N, begin;    cin &gt;&gt; N &gt;&gt; begin;    int address;    for (int i = 0; i &lt; N; i++)    &#123;        cin &gt;&gt; address;        cin &gt;&gt; node[address].data &gt;&gt; node[address].next;        node[address].address = address;    &#125;    int count = 0;    while (begin != -1)    &#123;        node[begin].flag = true; // 将能够连接的节点标记为 true        count++;                 // 记录有效节点的个数         begin = node[begin].next;    &#125;    if (count == 0) // 没有有效节点直接进行输出     &#123;        cout &lt;&lt; &quot;0 -1&quot;;    &#125;    else    &#123;        sort(node, node + edge, cmp);                // 进行排序         printf(&quot;%d %05d\\n&quot;, count, node[0].address); // 输出有效节点的个数和起始位置         for (int i = 0; i &lt; count; i++)        &#123;            if (i &lt; count - 1)            &#123;                printf(&quot;%05d %d %05d\\n&quot;, node[i].address, node[i].data, node[i + 1].address);            &#125;            else            &#123;                printf(&quot;%05d %d -1\\n&quot;, node[i].address, node[i].data);            &#125;        &#125;    &#125;    return 0;&#125;\n 1097\n 题目：Deduplication on a Linked List\nGiven a singly linked list L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each value K, only the first node of which the value or absolute value of its key equals K will be kept. At the mean time, all the removed nodes must be kept in a separate list. For example, given L being 21→-15→-15→-7→15, you must output 21→-15→-7, and the removed list -15→15.\nInput Specification:\nEach input file contains one test case. For each case, the first line contains the address of the first node, and a positive N (≤105) which is the total number of nodes. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1.\nThen N lines follow, each describes a node in the format:\nAddress Key Next\nwhere Address is the position of the node, Key is an integer of which absolute value is no more than 104, and Next is the position of the next node.\nOutput Specification:\nFor each case, output the resulting linked list first, then the removed list. Each node occupies a line, and is printed in the same format as in the input.\nSample Input:\n\n00100 5\n99999 -7 87654\n23854 -15 00000\n87654 15 -1\n00000 -15 99999\n00100 21 23854\n\nSample Output:\n\n00100 21 23854\n23854 -15 99999\n99999 -7 -1\n00000 -15 87654\n87654 15 -1\n\n 思路： 将数据绝对值相同的节点按照输入顺序放置到最后分别控制有效位和无效位单独输出，排序的标记变量初始置为数据规模的两倍放置中间存放无效位时溢出，输出时注意两类的最后一个节点的 next 为 -1\n 代码：\n#include &lt;cstdio&gt;#include &lt;stdlib.h&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100000;struct NODE&#123;    int address, key, next, num = 2 * maxn; //num 让其数时数据规模的两倍，中间留出充足的空间进行分类放置 &#125; node[maxn];bool exist[maxn] = &#123;false&#125;;int cmp(NODE a, NODE b)&#123;    return a.num &lt; b.num;&#125;int main()&#123;    int begin, n, cnt1 = 0, cnt2 = 0, a; //cnt1 表示有效的，cnt2 表示被删除的     scanf(&quot;%d%d&quot;, &amp;begin, &amp;n);    for (int i = 0; i &lt; n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;a);        scanf(&quot;%d%d&quot;, &amp;node[a].key, &amp;node[a].next);        node[a].address = a;    &#125;    for (int i = begin; i != -1; i = node[i].next) // 遍历     &#123;        if (exist[abs(node[i].key)] == false) // 如果这个数的绝对值没有出现过         &#123;            exist[abs(node[i].key)] = true; // 表示出现             node[i].num = cnt1++;           // 为其赋予第几个有效位         &#125;        else        &#123;            node[i].num = maxn + cnt2++; // 为其赋予第几个无效位         &#125;    &#125;    sort(node, node + maxn, cmp);    int cnt = cnt1 + cnt2;    for (int i = 0; i &lt; cnt; i++)    &#123;        if (i != cnt1 - 1 &amp;&amp; i != cnt - 1) // 不是两类的最后一个节点         &#123;            printf(&quot;%05d %d %05d\\n&quot;, node[i].address, node[i].key, node[i + 1].address);        &#125;        else        &#123;            printf(&quot;%05d %d -1\\n&quot;, node[i].address, node[i].key);        &#125;    &#125;    return 0;&#125;\n","categories":["算法"],"tags":["C/C++"]},{"title":"校招后端面试算法题 —— Java 实现","url":"/school_interview-exam/","content":"\n\n 自己参加秋招时做过的算法题（包括面试、笔试），这里贴出来做一个记录，代码够清晰了，所以也就没写注释，以后也尽量改掉一行注释一行代码的习惯，毕竟能够靠代码自己表达的东西就没必要啰嗦了 \n\n 度小满金融 \n 秋招开始第一次做笔试题，因为不能在自己的 IDE 上写，可给我难受坏了，第一次做的时候发挥的一塌糊涂，后来应该是邮件重复了又给我发了一次笔试邀请，想着闲着也是闲着就又参加了一次，第二次感觉还不错，第一次笔试之后有事耽误了总结，这里只贴第二次笔试的代码 \n 变形的约瑟夫环 \n 题目：\n1, ···, n 这 n 个人按编号排成一个圆圈，从数字 1 开始报数，报出的数字为 a 的人出局，下一个人继续从 1 开始报数，报出 b 的人出局，也就是奇数次出局的为报 a 的人，偶数次出局的人报的是 b\n输入格式为 n a b 求出这个圆圈里剩下的最后一个人的编号 \n 样例输入：\n\n6 3 5\n\n 样例输出：\n\n1\n\n 思路：\n大名鼎鼎的约瑟夫环，只是原来的固定淘汰值变成了两个轮换的值，在原来的解法中每次淘汰数字之后更换一下淘汰值即可 \n 代码：\n/** * Created by Aidan on 2021/9/26 16:29 * GitHub: github.com/huaxin0304 * Blog: aidanblog.top */public class JosephRing &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int n = scanner.nextInt();        int a = scanner.nextInt();        int b = scanner.nextInt();        scanner.close();        // 使用集合维护元素，方便淘汰的处理         List&lt;Integer&gt; person = new ArrayList&lt;&gt;();        for (int i = 1; i &lt;= n; i++) &#123;            person.add(i);        &#125;        int k = 0, now = a;        while (person.size() != 1) &#123;            k += now;            // 根据淘汰值找出被淘汰的具体人             k = k % person.size() - 1;            if (k &lt; 0) &#123;                person.remove(person.size() - 1);                k = 0;            &#125; else &#123;                person.remove(k);            &#125;            // 每次更换淘汰值             now = now == a ? b : a;        &#125;        System.out.println(person.get(0));    &#125;&#125;\n 奥运会 \n 题目：\n两个电视频道同时转播奥运会的竞赛项目，两个频道播出的项目中没有重复的，如果看一个项目就全部看完的话，根据节目单判断最多能完整看多少个项目（忽略换台的时间）\n第一行输入 m, n 作为两个频道转播的项目数量，然后以 HH:mm 的格式输入 m+n 行时间，返回能观看项目的最大值 \n 样例输入：\n\n3 4\n07:00-08:00\n08:00-09:00\n08:00-11:00\n09:30-11:00\n13:00-15:00\n12:00-13:30\n13:00-15:30\n\n 样例输出：\n\n4\n\n 思路：\n这道题算法不多，考察的更像是字符串、时间类和集合的应用（我没想到更好的解决方式），首先将 String 转换成 LocalTime 然后使用 TreeMap 存储时间的结束和开始，因为判断的是最多，所以用结束时间为 key 来排序，判断下一场的开始时间是不是晚于当前的结束时间，符合条件的累加 \n 代码：\n/** * Created by Aidan on 2021/9/26 16:31 * GitHub: github.com/huaxin0304 * Blog: aidanblog.top */public class TimeLag &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int m = scanner.nextInt();        int n = scanner.nextInt();        int total = m + n;        scanner.nextLine();        Map&lt;LocalTime, LocalTime&gt; map = new TreeMap&lt;&gt;();        // 定义字符串转时间的格式（直接用字符串也行）        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;HH:mm&quot;);        // 依次转换格式放入 map 中         while (total &gt; 0) &#123;            String time = scanner.nextLine();            LocalTime start = LocalTime.parse(time.substring(0, 5), dtf);            LocalTime end = LocalTime.parse(time.substring(6), dtf);            if (map.get(end) == null) &#123;                map.put(end, start);            &#125; else if (start.isAfter(map.get(end))) &#123;// 结束时间相同只保留开始时间晚的                 map.put(end, start);            &#125;            total--;        &#125;        scanner.close();        int count = 0;        LocalTime perEnd = LocalTime.parse(&quot;00:00&quot;, dtf);        for (Map.Entry&lt;LocalTime, LocalTime&gt; entry : map.entrySet()) &#123;            if (count == 0) &#123;// 第一场永远是最优解                 perEnd = entry.getKey();                count++;                continue;            &#125;            // 开始时间不早于上一场的结束时间即有效             if (!entry.getValue().isBefore(perEnd)) &#123;                count++;            &#125;            perEnd = entry.getKey();        &#125;        System.out.println(count);    &#125;&#125;\n 涂鸦移动 \n 路径深度 \n 题目：\n首先看这么一段文件路径 \nPreface 1  Java SE5 and SE6      Java SE6  The 4th edition      Changes  Note on the cover design  Acknowledgements\n 如果用代码表示，上面的文件系统可以写为： Preface 1\\n\\tJava SE5 and SE6\\n\\t\\tJava SE6\\n\\tThe 4th edition\\n\\t\\tChanges\\n\\tNote on the cover design\\n\\tAcknowledgements&quot; ，其中 ‘\\n’ 和 ‘\\t’ 分别是换行符和制表符。那么指向目录中任何一个条目，都会有一条路径，路径都有深度 \n 上面的例子中：\nNote on the cover design 的路径是 Preface 1/Note on the cover design ，深度是 2，路径都由字母、数字或空格组成，给定一个以上述代码格式表示目录的字符串 input，返回深度最深的条目中，最长路径的长度 \n 类似题 LeetCode 地址 \n 样例输入：\n\nTitle\\n\\tSubtitle1\\n\\tSubtitle2\\n\\t\\taaaa\n\n 样例输出：\n\n20\n解释：aaaa 路径为 “Title/Subtitle2/aaaa”，深度是 3，路径长度 20\n\n 思路：\n首先将输入的路径根据 \\n 进行切割，遍历每一段根据 \\t 的个数判断处于第几层，将每层的目录长度放到数组中，根据最后求出的最大深度计算最大长度 \n 代码：\n/** * Created by Aidan on 2021/9/3 16:22 * GitHub: github.com/huaxin0304 * Blog: aidanblog.top */public class FilePathLength &#123;    public static void main(String[] args) &#123;        String input = &quot;Title\\n\\tSubtitle1\\n\\t\\taaa\\n\\t\\tSubsubtitle1\\n\\t\\t\\tbbbb\\n\\tSubtitle2\\n\\t\\tSubsubtitle2\\n\\t\\t\\tcccccc&quot;;        System.out.println(LongestPath(input));    &#125;    public static int LongestPath(String input) &#123;        if (input.length() == 0) &#123;            return 0;        &#125;        int[] sum = new int[input.length() + 1];    // 从 1 开始，第 0 层就是 0        int Deepest = 0;        int deepestLen = 0;        for (String s : input.split(&quot;\\n&quot;)) &#123;            int level = s.lastIndexOf(&#x27;\\t&#x27;) + 2;    // 计算当前在第几层（从第一层开始，没有、t 为第一层）            Deepest = Math.max(Deepest, level);            deepestLen = s.length() - (Deepest - 1);    // 即便层数深度相同，最深长度也会更新             int len = s.length() - (level - 1);     // 计算当前这一行的长度             sum[level] = sum[level - 1] + len + 1;  // 是目录，要 +1，目录有个 / 的         &#125;        return sum[Deepest - 1] + deepestLen;    &#125;&#125;\n Temmie 的 X 运算 \n 题目：\n有一种特殊的运算 X，它的运算方式如下：对于一个整数 n，对它的每一位 d，用 d+1 替换 d\n例如，对于 193，它的每一位 +1 后的结果为 2，10，4。所以，193 的 X 运算结果为 2104\n计算 n 进行 m 次运算后结果的位数，因为结果可能超过整形范围，所以你只需要告诉他结果模 10^9+7 的余数即可 \n 样例输入：\n输入多行，每行用 m n 的格式表示数字和遍历次数 \n\n5\n1912 1\n5 6\n999 1\n88 2\n12 100\n\n 样例输出：\n\n5\n2\n6\n4\n2115\n\n 思路：\n直接模拟即可，注意当一位数字等于 10 之后会占两位 \n 代码：\n/** * Created by Aidan on 2021/9/3 17:43 * GitHub: github.com/huaxin0304 * Blog: aidanblog.top */public class ArithmeticNum &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int fre = scanner.nextInt();        for (int i = 0; i &lt; fre; i++) &#123;            long n = scanner.nextInt();            long m = scanner.nextInt();            long product = 0;            while (n &lt; 10) &#123;                n++;                m--;            &#125;            while (m-- != 0) &#123;                long temp = 0;                long power = 1;                while (n &gt; 0) &#123;                    temp = n % 10;                    temp++;                    // 处理 10 占两位的情况                     if (temp == 10) &#123;                        temp *= power;                        power *= 10;                    &#125; else &#123;                        temp *= power;                    &#125;                    product += temp;                    power *= 10;                    n /= 10;                &#125;                temp = 0;                power = 1;                n = product;            &#125;            long count = 0;            while (product &gt; 0) &#123;                product = product / 10;                count++;                count %= Math.pow(10, 9) + 7;            &#125;            System.out.println(count);        &#125;    &#125;&#125;\n 58 同城 \n58 同城的笔试题（9-11 20:00），牛客上进行的，当初度小满的第一次笔试题可给我自闭坏了（一道样例怎么改都是 81.7%，还有一道忘了加 scanner.nextLine() 一直报空指针，因为读到的换行符是作为空字符串存储的），这次倒好，三道编程题没半小时全部 AC，调试都不用调，安逸的很 \n 数组唯一数 \n 题目：\n给出一个整型数组，找出其中只出现过一次的数字，这里确定至少会有一个出现一次的数，返回一个数组，其中按原数组顺序返回 \n 样例输入：\n\n[1, 1, 4, 6, 7, 7, 3]\n\n 样例输出：\n\n[4, 6, 3]\n\n 思路：\n这里规定按原数组属性返回，如果使用 HashMap 需要增加遍历一次原数组的代码，所以直接使用 LinkedHashSet 就完了 \n不存在添加进 Set 集合，如若已经存在则移除，最后根据 Set.size() 取出数据即可 \n存在的问题是如果数字出现奇数次也会存在 Set 中，但 AC 了，看来测试数据没有出现过超过两次的情况，后续添加了一个 deletedSet 保存删除的数字解决问题 \n 代码：\n/** * Created by Aidan on 2021/9/11 20:50 * GitHub: github.com/huaxin0304 * Blog: aidanblog.top */public class UniqueNumber &#123;    public static void main(String[] args) &#123;        int[] test = &#123;1, 1, 4, 6, 7, 7, 3&#125;;        int[] result = find(test);        for (int i = 0; i &lt; result.length; i++) &#123;            System.out.println(result[i]);        &#125;    &#125;    public static int[] find(int[] arg) &#123;        Set&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;();        for (int i = 0; i &lt; arg.length; i++) &#123;            if (!set.contains(arg[i])) &#123;                set.add(arg[i]);            &#125; else &#123;                set.remove(arg[i]);            &#125;        &#125;        int[] arr = new int[set.size()];        int index = 0;        for (Integer i : set) &#123;            arr[index] = i;            index++;        &#125;        return arr;    &#125;    /**    public static int[] find(int[] arg) &#123;        Set&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;();        Set&lt;Integer&gt; delSet = new HashSet&lt;&gt;();        for (int i = 0; i &lt; arg.length; i++) &#123;            if (!set.contains(arg[i]) &amp;&amp; !delSet.contains(arg[i])) &#123;                set.add(arg[i]);            &#125; else &#123;                set.remove(arg[i]);                delSet.add(arg[i]);            &#125;        &#125;        int[] arr = new int[set.size()];        int index = 0;        for (Integer i : set) &#123;            arr[index] = i;            index++;        &#125;        return arr;    &#125;    **/&#125;\n 最大子数组和 \n 题目：\n给定一个数组和子数组的长度，找出子数组和的最大值，返回值一个数组包含其子数组的起始下标与子数组和，格式为：[index, sum]\n 样例输入：\n\n[1, 2, 30, 4, 5, 6, 7, 8, 9, 10], 10, 3\n\n 样例输出：\n\n[2, 39]\n\n 思路：\n模拟一下就好，注意不要超过数组边界 \n 代码：\n/** * Created by Aidan on 2021/9/11 20:50 * GitHub: github.com/huaxin0304 * Blog: aidanblog.top */public class SumBySub &#123;    public static void main(String[] args) &#123;        int[] result = subArraySum(new int[]&#123;1, 2, 30, 4, 5, 6, 7, 8, 9, 10&#125;, 10, 3);        for (int i = 0; i &lt; result.length; i++) &#123;            System.out.println(result[i]);        &#125;    &#125;    public static int[] subArraySum(int[] Array, int arrayLen, int subArrayLen) &#123;        // write code here        int max = 0;        int index = 0;        int i = 0;        while (i + subArrayLen &lt; arrayLen) &#123;            int tempMax = 0;            for (int j = i; j &lt; i + subArrayLen; j++) &#123;                tempMax += Array[j];            &#125;            if (max &lt; tempMax) &#123;                max = tempMax;                index = i;            &#125;            i++;        &#125;        return new int[]&#123;index, max&#125;;    &#125;&#125;\n 不能坑队友 \n 题目：\n王者荣耀中英雄大致可以分为五类：上中下、打野、辅助，给定整型数组代表英雄，返回有几种组合，如果阵容不合理则不能开团（返回 0）\n 样例输入：\n\n{0, 1, 2, 3, 4}\n\n 样例输出：\n\n1\n\n 代码：\n/** * Created by Aidan on 2021/9/11 20:58 * GitHub: github.com/huaxin0304 * Blog: aidanblog.top */public class HeroPool &#123;    public static void main(String[] args) &#123;        int result = getTeams(new int[]&#123;0, 1, 2, 3, 4&#125;);        System.out.println(result);    &#125;    public static int getTeams(int[] heros) &#123;        // write code here        int countZero = 0, countOne = 0, countTwo = 0, countThree = 0, countFour = 0;        for (int i = 0; i &lt; heros.length; i++) &#123;            switch (heros[i]) &#123;                case 0: &#123;                    countZero++;                    break;                &#125;                case 1: &#123;                    countOne++;                    break;                &#125;                case 2: &#123;                    countTwo++;                    break;                &#125;                case 3: &#123;                    countThree++;                    break;                &#125;                case 4: &#123;                    countFour++;                    break;                &#125;            &#125;        &#125;        return countZero * countOne * countTwo * countThree * countFour;    &#125;&#125;\n 字节跳动 \n 为面试准备的算法题，面试的部门是非中商业化技术，刷了一些面经中出现频率比较高的，结果很遗憾面试的时候没能撑到算法那一关 \n 二叉树的右视图 \nLeetCode 地址 \n 思路：\n同时维护两个栈：节点栈和深度栈，节点站按照先左后右的顺序存放结点，深度栈存放每个结点对应的深度，这样在同一层深度第一个弹出的必定是最右边的结点，然后将当前深度和结点放入 Map 中，如果后续已经存在当前的深度的 Key，那就直接进入下一层 \n 代码：\n/** TreeNode 结构  * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val = val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val = val; *         this.left = left; *         this.right = right; *     &#125; * &#125; */class Solution &#123;    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;        // 以 &lt;Depth, Node&gt; 的形式存储每层深度的结点         Map&lt;Integer, Integer&gt; rightSideNode = new HashMap&lt;&gt;();        int maxDepth = -1;  // 最大深度，负责从 Map 中取出对应深度的 Node        Stack&lt;TreeNode&gt; nodeStack = new Stack&lt;&gt;();        Stack&lt;Integer&gt; depthStack = new Stack&lt;&gt;();        nodeStack.push(root);        depthStack.push(0);        while (!nodeStack.isEmpty()) &#123;            TreeNode node = nodeStack.pop();            int depth = depthStack.pop();            if (node != null) &#123;                maxDepth = Math.max(maxDepth, depth);                // 如果当前深度在 Map 中没有对应的 Key                if (!rightSideNode.containsKey(depth)) &#123;                    rightSideNode.put(depth, node.val);                &#125;                // 从左向右依次放入结点                 nodeStack.push(node.left);                nodeStack.push(node.right);                depthStack.push(depth + 1);            &#125;        &#125;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        for (int i = 0; i &lt;= maxDepth; i++) &#123;            list.add(rightSideNode.get(i));        &#125;        return list;    &#125;&#125;\n 删除排序链表中的重复元素 \nLeetCode 地址 \n 思路：\n因为是排序链表，所以重复元素一定是连续出现的，可以维护一对快慢指针，当 slow.next==fast.next 时，取出当前重复值，快指针不断前移判断，直到不再重复时停下继续判断，中间重复值取消连接即可 \n 代码：\n这里优化后的代码仅使用一个指针，用 cursor.next 和 cursor.next.next 表示快慢 \n/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode deleteDuplicates(ListNode head) &#123;        if (head == null) &#123;            return head;        &#125;        // 用哑结点表示头结点的前置结点，因为头节点也可能重复被删除         ListNode dummy = new ListNode(0, head);        ListNode cursor = dummy;        // 只要快慢指针还能前移就持续判断         while (cursor.next != null &amp;&amp; cursor.next.next != null) &#123;            // 当快慢指针的 next 结点值重复             if (cursor.next.val == cursor.next.next.val) &#123;                int x = cursor.next.val;                do &#123;                    // 越过第一个重复值之后判断后续是否继续重复                     cursor.next = cursor.next.next;                &#125; while (cursor.next != null &amp;&amp; cursor.next.val == x);            &#125; else &#123;                cursor = cursor.next;            &#125;        &#125;        return dummy.next;    &#125;&#125;\n 子集 \nLeetCode 地址 \n 思路：\n回溯寻找，首先找长度 k=1k=1k=1 的子集，到达数组末尾就表示寻找完毕，保存结果集 \n然后寻找长度为 k=2k=2k=2 的子集，到达数组末尾可能存在存在 K 不为 0 的情况，那就移除最后放入的数，继续存储 \n以此类推 \n 不太好说，可以看官方的视频题解 \n 代码：\nclass Solution &#123;    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();    int len = 0;    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;        len = nums.length;        for (int k = 0; k &lt;= len; k++) &#123;    // 寻找所有长度的子集             backTrack(0, k, new ArrayList&lt;&gt;(), nums);        &#125;        return ans;    &#125;    public void backTrack(int start, int k, List&lt;Integer&gt; tempSet, int[] nums) &#123;        if (k == 0) &#123;   // 当前长度已经找完保存结果             ans.add(new ArrayList&lt;&gt;(tempSet));            return;        &#125;        for (int i = start; i &lt; len; i++) &#123;            tempSet.add(nums[i]);            // 防止重复，每次从下一个开始寻找，同时缩小子集要求个数             backTrack(i + 1, k - 1, tempSet, nums);            tempSet.remove(tempSet.size() - 1);        &#125;    &#125;    /* dfs 版本     List&lt;Integer&gt; t = new ArrayList&lt;Integer&gt;();    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;        dfs(0, nums);        return ans;    &#125;    public void dfs(int cur, int[] nums) &#123;        if (cur == nums.length) &#123;            ans.add(new ArrayList&lt;Integer&gt;(t));            return;        &#125;        t.add(nums[cur]);        dfs(cur + 1, nums);        t.remove(t.size() - 1);        dfs(cur + 1, nums);    &#125;    */&#125;\n 删除链表的倒数第 N 个结点 \nLeetCode 地址 \n 思路：\n\n 可以先遍历长度，第二次遍历到 length-n+1 时进行删除 \n 将链表全部压入栈中，弹出的第 n 个数据就是要删除的链表 \n 使用间隔为 n 的快慢指针，当 fast 为空时，删除 slow 结点 \n\n 代码：\n这里使用第三种方法实现，复杂度最低 \n/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode dummy = new ListNode(0, head); // 创建哑结点，因为头结点也有可能被删除         ListNode first = head;        ListNode second = dummy;        for (int i = 0; i &lt; n; ++i) &#123;            first = first.next; // 快结点先走 n 步         &#125;        while (first != null) &#123; // 快结点到达末尾删除满结点所在位置             first = first.next;            second = second.next;        &#125;        second.next = second.next.next;        ListNode ans = dummy.next;        return ans;    &#125;&#125;\n 合并 K 个升序链表 \nLeetCode 地址 \n 思路：\n这里先把问题规模缩小，不考虑 K 个链表怎么合并，看作是两个链表，每次合并后作为一个链表继续和后续链表合并即可 \n 至于两个链表的合并就是每次判断值赋予新链表上，当一个链表为空后，将另一链表直接置于新链表末尾即可 \n 代码：\n/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode mergeKLists(ListNode[] lists) &#123;        ListNode ans = null;        for (int i = 0; i &lt; lists.length; ++i) &#123;// 遍历每一条链表让其与上一条链表合并             ans = mergeTwoLists(ans, lists[i]);        &#125;        return ans;    &#125;    public ListNode mergeTwoLists(ListNode a, ListNode b) &#123;        if (a == null || b == null) &#123;            return a != null ? a : b;        &#125;        ListNode head = new ListNode(0);    // 哑结点的 next 表示，防止错乱         ListNode tail = head, aPtr = a, bPtr = b;        while (aPtr != null &amp;&amp; bPtr != null) &#123;            if (aPtr.val &lt; bPtr.val) &#123;  // 比较值之后保留小的                 tail.next = aPtr;                aPtr = aPtr.next;            &#125; else &#123;                tail.next = bPtr;                bPtr = bPtr.next;            &#125;            tail = tail.next;   // 指针后移         &#125;        tail.next = (aPtr != null ? aPtr : bPtr);   // 当有链表为空时，另一链表放到结果链表的后边         return head.next;    &#125;&#125;\n 花旗 \n 纯英文的题目，但好在描述的简洁直接，读题还是没障碍的，一道 SQL 实现题，放到了这篇  实现贴上面 ，还有一道合并有序数组的没必要放上来了，说说这道动规吧 \n 规定时间内到达终点的最小花费 \nLeetCode 地址 \n 思路：\n这道题第一时间想的是最短路径实现，但后来还是换成了动态规划，结束之后推算了一下确实也是动态规划的复杂度比较小，要花费 n∗maxTimesn*maxTimesn∗maxTimes 的规模初始化 dp 数组，然后遍历 maxTimesmaxTimesmaxTimes 来对每一个 edges 数组来操作，最后的复杂度为 O((n+m)⋅maxTimes)O((n+m)⋅maxTimes)O((n+m)⋅maxTimes)\n 创建一个 maxTimesmaxTimesmaxTimes 的 dp 数组，然后我们在时间限定内进行动规，dp[t][i] 表示第 t 分钟到达城市 i 时的最少费用，然后假设跟其有边的点 j 就是到达 i 的最后一步，进行状态转移，最后找出时间范围中到达 n-1 花费最小的即可 \n\n 当前时间为 1，只能从 0 走到 3 号点，这样的花费就是 25    dp[1][3]=dp[0][0]+cost[3]\n 时间在 2-9 之间时只能在 0-3 点横跳 \n…\n 此时时间为 10，横跳结束，可以走到 1 号点，花费 15   dp[10][1]=dp[0][0]+cost[1]\n 时间来到 11，可以到达 4 号点，花费 45     dp[11][34]=dp[1][3]+cost[4]\n… 依次类推 \n\n 代码：\npublic class MinCostWithTimeLimited &#123;    public static void main(String[] args) &#123;        System.out.println(minCostWithTimeLimited(30,                new int[][]&#123;                        &#123;0, 1, 10&#125;,                        &#123;1, 2, 10&#125;,                        &#123;2, 5, 10&#125;,                        &#123;0, 3, 1&#125;,                        &#123;3, 4, 10&#125;,                        &#123;4, 5, 15&#125;                &#125;,                new int[]&#123;5, 1, 2, 20, 20, 3&#125;));    &#125;    public static int minCostWithTimeLimited(int maxTime, int[][] edges, int[] passingFees) &#123;        int n = passingFees.length; // 根据城市成本数组保留城市个数         /*        最大费用，这里根据数据规模计算         可以使用 `Integer.MAX_VALUE - Arrays.stream(passingFees).max().getAsInt();`        */        int maxFee = (int) 1E6 + 1;        // 创建时间限制同样规模的数组，保留从 0 到 i 需要的时间         int[][] dp = new int[maxTime + 1][n];        // 使用最大成本填充         for (int i = 0; i &lt;= maxTime; i++) &#123;            Arrays.fill(dp[i], maxFee);        &#125;        // 起点花费         dp[0][0] = passingFees[0];        // 在时间限定中尝试         for (int i = 1; i &lt;= maxTime; i++) &#123;            for (int[] edge : edges) &#123;                // 耗时超过当前时间限定直接下一次循环                 if (edge[2] &gt; i) &#123;                    continue;                &#125;                int x = edge[0], y = edge[1], time = edge[2];                // 根据边关系求出走这条路时的花费                 dp[i][x] = Math.min(dp[i][x], dp[i - time][y] + passingFees[x]);                dp[i][y] = Math.min(dp[i][y], dp[i - time][x] + passingFees[y]);            &#125;        &#125;        int ans = maxFee;        for (int i = 0; i &lt;= maxTime; i++) &#123;            ans = Math.min(ans, dp[i][n - 1]);        &#125;        return (ans == maxFee) ? -1 : ans;    &#125;&#125;\n 阿里巴巴 \n 两道题，第二道没做明白，只 AC 了第一道 \n 补码的加法运算 \n 题目：\n第一行给出组数 N，紧接输入 N 行数据，每行一对以补码形式的的 32 位字符，输出相加后的十进制结果 \n 样例输入：\n\n2\n00000000000000000000000000000101 11111111111111111111111111111111\n00000000000000000000000000011111 00000000000000000000000000000111\n\n 样例输出：\n\n4\n38\n\n 思路：\n可以根据补码直接定义运算规则，也可以转换为原码后进行计算，我这里选择的是第二种，根据原码对补码的转换思路反向操作即可，转换补码的思路：\n\n 正数：保持不变 \n 负数：符号位保持不变，数值位按位取反末位加一 \n\n 代码：\nimport java.util.Scanner;/** * @author Aidan * @createTime 2021/10/8 20:06 * @GitHub github.com/huaxin0304 * @Blog aidanblog.top */public class ComplementArithmetic &#123;    /**     * 尽量不要在代码中出现 magic number     * 可以使用 int 型定义为 48,49     */    static final char ZERO = &#x27;0&#x27;;    static final char ONE = &#x27;1&#x27;;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int n = scanner.nextInt();        for (int i = 0; i &lt; n; i++) &#123;            scanner.nextLine();            String a = scanner.next();            String b = scanner.next();            // 数据读取后进行处理，转换为 10 进制             int x = hand(a), y = hand(b);            System.out.println(x + y);        &#125;    &#125;    public static int hand(String str) &#123;        char[] chars = str.toCharArray();        int m;        // 符号位为 0 是一个正数，直接进行进制转换         if (chars[0] == ZERO) &#123;            m = Integer.parseInt(str, 2);        &#125; else &#123;            // 将数值位按位取反             for (int i = 1; i &lt; chars.length; i++) &#123;                if (chars[i] == ONE) &#123;                    chars[i] = ZERO;                &#125; else &#123;                    chars[i] = ONE;                &#125;            &#125;            String newA = String.copyValueOf(chars, 1, 31);            // 处理末尾与符号             m = Integer.parseInt(newA, 2) + 1;            if (m &gt; 0) &#123;                m *= -1;            &#125;        &#125;        return m;    &#125;&#125;\n 倍业科技 \n 字符串压缩与解压 \nLeetCode 地址 \n 代码：\nimport java.util.Scanner;/** * @author Aidan * @createTime 2021/10/26 14:13 * @GitHub github.com/huaxin0304 * @Blog aidanblog.top */public class TarString &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String str = scanner.nextLine();        System.out.println(compress(str));        System.out.println(decompress(str));    &#125;    static String compress(String str) &#123;        StringBuilder builder = new StringBuilder();        char start = str.charAt(0);        int count = 1;        for (int i = 1; i &lt; str.length(); i++) &#123;            char next = str.charAt(i);            // 重复字符累加             if (start == next) &#123;                count++;                continue;            &#125;            // 根据重复次数压缩             if (count == 1) &#123;                builder.append(start);            &#125; else &#123;                builder.append(count).append(start);            &#125;            // 开始下一轮重复             start = next;            count = 1;        &#125;        // 处理末尾数据         if (count == 1) &#123;            builder.append(start);        &#125; else &#123;            builder.append(count).append(start);        &#125;        return builder.toString();    &#125;    static String decompress(String str) &#123;        StringBuilder builder = new StringBuilder();        for (int i = 0; i &lt; str.length();) &#123;            char c = str.charAt(i);            // 如果当前遍历到的字符是数字，考虑位数超过一的情况             if (Character.isDigit(c)) &#123;                int j = i + 1;                for (; j &lt; str.length(); j++) &#123;                    if (!Character.isDigit(str.charAt(j))) &#123;                        break;                    &#125;                &#125;                // 根据数字进行重复                 int num = Integer.parseInt(str.substring(i, j));                builder.append(String.valueOf(str.charAt(j)).repeat(Math.max(0, num)));                i = j + 1;                // 遇到单个字符的情况             &#125; else &#123;                builder.append(str.charAt(i));                i++;            &#125;        &#125;        return builder.toString();    &#125;&#125;\n 便利蜂 \n 测量次数 \n 题目：\n小明和他的伙伴发现了一堆木头排成了一排，一共 n 个，假设排列在 x 轴上，最左端的木头的坐标是 -1，最右端木头的坐标是 n。他们想拿走里面最重和最轻的木头各一个，但是他们并不知道是这一堆里的哪一个，因此他们需要挨个测量。现在他们在这排木头的两端，一个人在坐标 0，一个人在坐标 n，他们只能按顺序测量，即在 0 位置的人只能依次测量 0, 1, 2, 3 然后到 n，在 n 位置的人则相反。现在你已经知道每个木头的重量，你可以指挥他们是否继续测量，问两个人一共最少需要多少次测量就可以找到最重和最轻的木头 \n 输入描述：\n第一行一个整数 n，0&lt;=n&lt;=1000\n 第二行 n 个空格隔开的整数，表示木头的重量，其中任意一个数大小范围是 [-1, 10000]。\n 输出描述：\n一个整数，表示最少需要测量的次数。\n 样例输入：\n\n4\n0 5 4 3 2\n\n 样例输出：\n\n1\n\n 思路：\n直接根据描述模拟的测量方法，可能剪枝后还是跑不完样例，贴一下代码吧 \n 代码：\nimport java.util.ArrayList;import java.util.List;import java.util.Scanner;/** * @author Aidan * @createTime 2021/10/30 19:24 * @GitHub github.com/huaxin0304 * @Blog aidanblog.top */public class MeasureNum &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int n = scanner.nextInt();        int[] arr = new int[n];        int maxInd = 0, max = Integer.MIN_VALUE, minInd = 0, min = Integer.MAX_VALUE;        for (int i = 0; i &lt; n; i++) &#123;            arr[i] = scanner.nextInt();            if (arr[i] &gt; max) &#123;                max = arr[i];                maxInd = i;            &#125;            if (arr[i] &lt; min) &#123;                min = arr[i];                minInd = i;            &#125;        &#125;        List&lt;Integer&gt; maxIndList = new ArrayList&lt;&gt;();        List&lt;Integer&gt; minIndList = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; arr.length; i++) &#123;            if (arr[i] == arr[minInd]) &#123;                minIndList.add(i);            &#125;            if (arr[i] == arr[maxInd]) &#123;                maxIndList.add(i);            &#125;        &#125;        int result = 0;        for (Integer maxTemp : maxIndList) &#123;            maxInd = maxTemp;            for (Integer minTemp : minIndList) &#123;                minInd = minTemp;                if (maxInd &lt; minInd) &#123;                    int temp = maxInd;                    maxInd = minInd;                    minInd = temp;                &#125;                result = Math.min(Math.min(n - minInd, maxInd + 1), (minInd + 1) + (n - maxInd));            &#125;        &#125;        System.out.println(result);    &#125;&#125;\n 滴滴 \n 删除游戏的最大得分 \n 题目：\n首先随机写下 N 个正整数，然后任选一个数字作为起始点，从起始点开始从左往右每次可以删除一个数字，但是必须满足下一个删除的数字要小于上一个删除的数字。每成功删除一个数字计 1 分。请问对于给定的 N 个正整数，一局游戏过后可以得到的最大计分是多少？\n 思路：\n第一时间考虑的 dfs 方式，也能跑完但这种问题还是动态规划比较好，所以结束后又写了一遍动规的写法 \n 代码：\nimport java.util.Scanner;/** * @author Aidan * @createTime 2021/10/23 16:33 * @GitHub github.com/huaxin0304 * @Blog aidanblog.top */public class MaxScore &#123;    private static int result = 0;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int n = scanner.nextInt();        int[] arr = new int[n];        for (int i = 0; i &lt; n; i++) &#123;            arr[i] = scanner.nextInt();        &#125;        /* dfs 调用         for (int i = 0; i &lt; arr.length; i++) &#123;            dfs(arr[i], i, arr, 1);        &#125;        */        dp(arr);        System.out.println(result);    &#125;    private static void dp(int[] arr) &#123;        int[] dp = new int[arr.length];        dp[0] = 1;        int maxIndex = 0;        for (int i = 1; i &lt; arr.length; i++) &#123;            dp[i] = 1;            for (int j = 1; j &lt; i; j++) &#123;                if (arr[j] &gt; arr[i] &amp;&amp; dp[j] + 1 &gt; dp[i]) &#123;                    dp[i] = dp[j] + 1;                &#125;            &#125;            if (dp[maxIndex] &lt; dp[i]) &#123;                maxIndex = i;            &#125;        &#125;        result = dp[maxIndex];    &#125;    /* dfs 解法     private static void dfs(int flag, int i, int[] arr, int count) &#123;        if (i + 1 == arr.length) &#123;            result = Math.max(result, count);        &#125;        int j = i + 1;        for (; j &lt; arr.length; j++) &#123;            if (arr[j] &lt; flag) &#123;                count++;                dfs(arr[j], j, arr, count);                count--;            &#125;        &#125;        if (j == arr.length) &#123;            result = Math.max(result, count);        &#125;    &#125;    */&#125;\n 最小生成树 \n 题目：\nX 星大学新校区终于建成啦！  新校区一共有 N 栋教学楼和办公楼。现在需要用光纤把这 N 栋连接起来，保证任意两栋楼之间都有一条有线网络通讯链路。\n已知任意两栋楼之间的直线距离（单位：千米）。为了降低成本，要求两栋楼之间都用直线光纤连接。\n光纤的单位成本 C 已知（单位：X 星币 / 千米），请问最少需要多少 X 星币才能保证任意两栋楼之间都有光纤直接或者间接相连？\n注意：如果 1 号楼和 2 号楼相连，2 号楼和 3 号楼相连，则 1 号楼和 3 号楼间接相连 \n 思路：\n直接最小生成树进行判断即可 \n 代码：\nimport java.util.Scanner;/** * @author Aidan * @createTime 2021/10/23 16:59 * @GitHub github.com/huaxin0304 * @Blog aidanblog.top */public class MinLen &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int n = scanner.nextInt(), c = scanner.nextInt();        int[][] map = new int[n + 1][n + 1];        int[] visited = new int[n + 1];        for (int i = 1; i &lt;= n * (n - 1) / 2; i++) &#123;            int x = scanner.nextInt();            int y = scanner.nextInt();            int len = scanner.nextInt();            map[x][y] = len;            map[y][x] = len;        &#125;        // 所有楼都会间接可达，不用考虑入口，直接选择 1 号楼         visited[1] = 1;        int result = 0, step = 1, now = 0, min;        while (step &lt; n) &#123;            min = Integer.MAX_VALUE;            for (int i = 1; i &lt;= n; i++) &#123;                if (visited[i] == 1) &#123;                    // 选择没被连接的可达最小值                     for (int j = 1; j &lt;= n; j++) &#123;                        if (visited[j] == 0 &amp;&amp; min &gt; map[i][j]) &#123;                            min = map[i][j];                            now = j;                        &#125;                    &#125;                &#125;            &#125;            if (min != Integer.MAX_VALUE) &#123;                // 被连接后标识                 visited[now] = 1;                result += min;                step++;            &#125;        &#125;        System.out.println(result * c);    &#125;&#125;\n 去哪儿 \n 题目：\n对字符串按照字符出现频率重新排序，频率相同按大小写排序，同为大写或小写按字母序排列 \n 代码：\npublic class StringReordering &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String str = scanner.nextLine();        char[] chars = str.toCharArray();        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();        for (char c : chars) &#123;            int count;            if (map.containsKey(c)) &#123;                count = map.get(c);                map.put(c, ++count);            &#125; else &#123;                map.put(c, 1);            &#125;        &#125;        List&lt;Map.Entry&lt;Character, Integer&gt;&gt; entryList = new ArrayList&lt;&gt;(map.entrySet());        entryList.sort((o1, o2) -&gt; &#123;            if (!Objects.equals(o2.getValue(), o1.getValue())) &#123;                return o2.getValue() - o1.getValue();            &#125; else if ((o1.getKey() &gt; 94 &amp;&amp; o2.getKey() &gt; 94) || (o1.getKey() &lt; 95 &amp;&amp; o2.getKey() &lt; 95)) &#123;                return o1.getKey() - o2.getKey();            &#125;            return o1.getKey() &gt; 94 ? 1 : -1;        &#125;);        StringBuilder stringBuilder = new StringBuilder();        for (Map.Entry&lt;Character, Integer&gt; entry : entryList) &#123;            stringBuilder.append(String.valueOf(entry.getKey()).repeat(Math.max(0, entry.getValue())));        &#125;        System.out.println(stringBuilder);    &#125;&#125;\n 360\n 题目：\n小 A 的英语考了个不及格，老师很生气，并且发现他英语的语法几乎全错！于是老师决定好好教教他英语语法 \n\n 老师想先从句子结构开始教他。一个句子至少需要包含主谓结构，即主语和谓语，并且主语在前，谓语在后。有些句子会在谓语后面加上宾语。避免复杂，本题中句子的顺序严格按照主语 - 谓语 - 宾语的顺序（即无宾语前置和倒装等情况）。\n 老师给了小 A 三张单词表，分别是主语单词表、谓语单词表和宾语单词表。老师要让小 A 用这些单词表中的单词来造句，并且规定：谓语有且仅有一个单词，主语和宾语可以包含任意个单词（主语不可为空）。老师暂时不想让小 A 造出能保证意思通顺的句子，他只想让小 A 能够学会基本的句子结构就行。\n 现在，小 A 根据这些单词造了 m 条句子，现在假设你是老师，你需要判断每条句子是否符合上述句子结构。\n\n 输入描述 \n\n 第一行三个正整数 n1, n2, n3，分别表示主语、谓语、宾语单词表的单词数；\n 第二行包含 n1 个单词，单词仅由小写英文字母组成，每两个单词之间有一个空格，单词长度不超过 10；\n 第三行包含 n2 个单词，其他格式同上；\n 第四行包含 n3 个单词，其他格式同上；\n 第五行一个正整数 m；\n 接下来 m 行，每行一个句子。句子由若干单词（至少一个）组成，并且保证出现的单词都在上面的单词表内。每两个单词之间一个空格隔开 \n\n\n 数据保证一个单词最多只可做一种句子成分。即每个单词仅会出现在一个单词表上。\n1≤n1, n2, n3≤1000, 1≤m≤20, 1≤句子单词数≤10\n\n 输出描述 \n对于每条句子，如果其符合句子结构，输出一行“YES”（不含引号），否则输出一行“NO”（不含引号）\n 样例输入 \n\n3 3 3\ni you he\nam is are\nyours his hers\n5\ni am yours\nyou is his\nhe are hers yours\ni am am yours\nis his\n\n 样例输出 \n\nYES\nNO\n\n 代码：\nimport java.util.*;/** * Created by Aidan on 2021/10/24 15:42 * GitHub: github.com/huaxin0304 * Blog: aidanblog.top */public class AmIsAre &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int zCount = scanner.nextInt(), wCount = scanner.nextInt(), bCount = scanner.nextInt();        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();        for (int j = 0; j &lt; zCount; j++) &#123;            String temp = scanner.next();            map.put(temp, 0);        &#125;        scanner.nextLine();        for (int j = 0; j &lt; wCount; j++) &#123;            String temp = scanner.next();            map.put(temp, 1);        &#125;        scanner.nextLine();        for (int j = 0; j &lt; bCount; j++) &#123;            String temp = scanner.next();            map.put(temp, 2);        &#125;        scanner.nextLine();        int count = scanner.nextInt();        scanner.nextLine();        for (int i = 0; i &lt; count; i++) &#123;            String str = scanner.nextLine();            String[] strings = str.split(&quot; &quot;);            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();            for (String string : strings) &#123;                list.add(map.get(string));            &#125;            String flag = &quot;YES&quot;;            if (!list.contains(0)) &#123;                flag = &quot;NO&quot;;            &#125; else &#123;                int W_Count = 0;                for (int i1 = 1; i1 &lt; list.size(); i1++) &#123;                    if (list.get(i1 - 1) &gt; list.get(i1) || W_Count &gt; 1                            || (list.get(i1) == 2) &amp;&amp; W_Count == 0) &#123;                        flag = &quot;NO&quot;;                        break;                    &#125; else if (list.get(i1) == 1) &#123;                        W_Count++;                    &#125;                &#125;            &#125;            System.out.println(flag);        &#125;    &#125;&#125;\n 途家民宿 \n 生成城市树 \n 题目：\n 按照固定的格式进行输入，每行的格式为：IdpIdlevelnameId pId level nameIdpIdlevelname，最后按照级别生成目录形式的文本输出，若级别相同，则按姓名进行升序排列 \n 思路：\n 将每个城市封装成一个 class，对级别为 0 的城市进行遍历，然后递归输出后续的城市并进行格式的调整 \n 代码：\nimport java.util.*; /** * @author Aidan * @createTime 2021/11/13 15:28 * @GitHub github.com/huaxin0304 * @Blog aidanblog.top */public class GenerateCityTree &#123;    static class City &#123;        int ID, PID, level;        String name;        public City(int ID, int PID, int level, String name) &#123;            this. ID = ID;             this. PID = PID;             this.level = level;             this.name = name;         &#125;    &#125;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        List&lt;City&gt; cityList = new ArrayList&lt;&gt;();        while (scanner.hasNextLine()) &#123;            String str = scanner.nextLine();            Scanner scannerStr = new Scanner(str);            String[] strings = new String[4];            for (int i = 0; i &lt; 4; i++) &#123;                strings[i] = scannerStr.next();            &#125;            City tempCity = new City(Integer.parseInt(strings[0]),                    Integer.parseInt(strings[1]), Integer.parseInt(strings[2]), strings[3]);            cityList.add(tempCity);        &#125;        cityList.sort((o1, o2) -&gt; &#123;            if (o1.level != o2.level) &#123;                return o1.level - o2.level;            &#125;            return o1.ID - o2.ID;        &#125;);        /*for (City city : cityList) &#123;            System.out.println(city.getName());        &#125;*/        for (City city : cityList) &#123;            if (city.level == 1) &#123;                System.out.println(city.name);                dfs(cityList, city.level + 1, city.ID);            &#125;        &#125;    &#125;    static void dfs(List&lt;City&gt; list, int level, int ID) &#123;        for (City city : list) &#123;            if (city. PID == ID &amp;&amp; city.level == level) &#123;                outSpace(level);                 System.out.print(city.name);                 System.out.println();                 dfs(list, level + 1, city. ID);             &#125;        &#125;        return;     &#125;    static void outSpace(int level) &#123;        for (int i = 0; i &lt; (level - 1) * 4; i++) &#123;            System.out.print(&quot; &quot;);        &#125;    &#125;&#125;\n 逆序输出文章 \n 题目：\n 输入一篇英文文章，将每个词颠倒顺序进行输出，每个词仍保证有序 \n 思路：\n 将每个词放入 List 集合中，对特定格式的词进行处理（包含 ‘, ‘，’.’），然后逆序遍历输出即可 \n 代码：\nimport java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Scanner;/** * @author Aidan * @createTime 2021/11/13 14:55 * @GitHub github.com/huaxin0304 * @Blog aidanblog.top */public class ReviseArticle &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String s = scanner.nextLine();        String[] s1 = s.split(&quot; &quot;);        ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;(Arrays.asList(s1));        Collections.reverse(strings);        int i = 0;        for (String string : strings) &#123;            i++;            if (string.contains(&quot;,&quot;)) &#123;                String[] split = string.split(&quot;,&quot;);                System.out.print(split[1]);                System.out.print(&quot;,&quot;);                System.out.print(split[0]);            &#125; else if (string.contains(&quot;.&quot;)) &#123;                String[] split = string.split(&quot;\\\\.&quot;);                if (split.length == 1) &#123;                    System.out.print(&quot;.&quot;);                    System.out.print(string.replace(&#x27;.&#x27;, &#x27; &#x27;));                    continue;                &#125; else &#123;                    System.out.print(split[1]);                    System.out.print(&quot;.&quot;);                    System.out.print(split[0]);                &#125;            &#125; else &#123;                System.out.print(string);            &#125;            if (i &lt; strings.size()) &#123;                System.out.print(&quot; &quot;);            &#125;        &#125;    &#125;&#125;\n 数美科技 \n 题目：\n 如果有相邻字符是连续状态则可以看作是连续子串，输入一串字符，求其中连续子串的个数 \n 代码：\nimport java.util.HashSet;import java.util.Scanner;import java.util.Set;/** * @author Aidan * @createTime 2021/11/18 20:10 * @GitHub github.com/huaxin0304 * @Blog aidanblog.top */public class SubStr &#123;    // 将连续子串放入 set 中防止重复     private static Set&lt;String&gt; set = new HashSet&lt;String&gt;();    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String str = scanner.nextLine();        // 截取字符串的不中断连续子串         for (int i = 0; i &lt; str.length(); i++) &#123;            int j = i;            while (j + 1 &lt; str.length() &amp;&amp; str.charAt(j + 1) == str.charAt(j) + 1) &#123;                j++;            &#125;            numSub(str.substring(i, j + 1));            // i 会自增，使用 j 即可             i = j;        &#125;        // 结果去掉空串         System.out.println(set.size() - 1);    &#125;    /**     * 每个连续子串又可以分成 n(n+1)/2 个（不包括空串）     *     * @param string 截取的不中断连续子串      */    private static void numSub(String string) &#123;        // 子串可以分隔成 i~n 中长度         for (int i = 1; i &lt;= string.length(); i++) &#123;            int j = 0;            for (; j + i &lt;= string.length(); j++) &#123;                set.add(string.substring(j, j + i));            &#125;            set.add(string.substring(j));        &#125;    &#125;&#125;\n","categories":["算法"],"tags":["Java"]},{"title":"大文件外排序","url":"/sort-outside_large_files/","content":"\n\n 一道固定内存下进行文件外排序的算法题解，虽然说是外排，但是根据题目要求，还是使用内排序的方式实现 \n\n 题目 \n\n 假设您拥有⼀台电脑 \n\n 内存为 4GB\n 磁盘⽆限空间 \n 磁盘上 data ⽬录下有⼀万份大小为 8GB 的⽂件 \n⽂件内容每⾏开头前三个字⺟都为最基础的 ASCII 码值 \n⽂件内容是⽆序的 \n 该电脑能打开的⽂件描述符⽆限多 \n\n 现要求将 data ⽬录下的所有⽂件合并为⼀个超⼤⽂件且合并后的⽂件中的内容使⽤每⾏前三个字⺟做升序排列，如果前三个字⺟相同则随机即可，要求考虑最快速度下最⼩资源占⽤。\n\n 输入样例 \n⽂件 A 内容：aaaAAAaabAAA⽂件 B 内容：aaaBBBaaaCCCaacBBB\n 输出结果 \naaaAAAaaaBBBaaaCCCaabAAAaacBBB 或 aaaCCCaaaBBBaaaAAAaabAAAaacBBB\n 思路 \n 粗略一看像是外排序的问题，但根据要求有几个特点 \n\n 排序依据：每行开头的 ASCII 码 \n 文件描述符无上限 \n\n 如果使用外排序，将会产生一些保留中间阶段排序的临时文件，反而增加了磁盘和 I/O 开销 \n\n 首先考虑排序依据，ASCII 码一共 128 个，排除控制字符后可显示的有 95 个，根据题目描述每行开头固定三位，也就是共有 95395^3953 个，每个 ASCII 占用一个字节，最大占用量为 953×3=2572125≈2.45MB95^3\\times3=2572125\\approx2.45MB953×3=2572125≈2.45MB，这样去重后排序的内存消耗可以忽略了 \n 其次是文件描述符，对应的数据结构为 fd -&gt; 文件指针 -&gt; 文件，内存中不读取内容时占用很小，也可以使用内存进行处理，同时为减少数据量的拷贝，使用 syscall 直接进行文件操作，记录每一行位置的起始和长度，在排序后进行写入即可 \n 因为以上没有提到 CPU 核数的问题，所以不考虑并发，仅使用单线程处理 \n\n 代码 \npackage mainimport (\t&quot;os&quot;\t&quot;sort&quot;\t&quot;syscall&quot;)const bufferSize = 1024 * 1024 * 1024 // 缓冲区暂定为 1GBtype File struct &#123;\tfd     int   // 文件描述符 \toffset int64 // 行偏移量 \tsize   int   // 行长度 &#125;func main() &#123;\tstorage := make(map[string][]*File)\t// 读取文件内容并构建 ASCII 码映射 \tif err := readFiles(storage); err != nil &#123;\t\tpanic(err)\t&#125;\t// 获取所有 key 并排序 \tkeys := make([]string, 0, len(storage))\tfor key := range storage &#123;\t\tkeys = append(keys, key)\t&#125;\tsort.Strings(keys)\tresultFd, err := syscall.Open(&quot;result&quot;, syscall.O_WRONLY|syscall.O_CREAT, 0644)\tif err != nil &#123;\t\tpanic(err)\t&#125;\tdefer syscall.Close(resultFd)\t// 将文件内容写入结果文件 \tfor _, key := range keys &#123;\t\tfiles := storage[key]\t\tfor _, file := range files &#123;\t\t\tif _, err := syscall.Seek(file.fd, file.offset, 0); err != nil &#123;\t\t\t\tpanic(err)\t\t\t&#125;\t\t\tbuffer := make([]byte, file.size)\t\t\tif _, err := syscall.Read(file.fd, buffer); err != nil &#123;\t\t\t\tpanic(err)\t\t\t&#125;\t\t\tif _, err := syscall.Write(resultFd, buffer[:file.size]); err != nil &#123;\t\t\t\tpanic(err)\t\t\t&#125;\t\t&#125;\t&#125;\t// 关闭所有打开的文件 \tfor _, files := range storage &#123;\t\tfor _, file := range files &#123;\t\t\tsyscall.Close(file.fd)\t\t&#125;\t&#125;&#125;func readFiles(storage map[string][]*File) error &#123;\tfiles, err := os.ReadDir(&quot;data&quot;)\tif err != nil &#123;\t\treturn err\t&#125;\tfor _, entry := range files &#123;\t\tfd, err := syscall.Open(&quot;data/&quot; + entry.Name(), syscall.O_RDONLY, 0)\t\tif err != nil &#123;\t\t\treturn err\t\t&#125;\t\tbuffer := make([]byte, bufferSize)\t\tvar lineBuffer []byte\t\tvar offset int64\t\tfor &#123;\t\t\tn, err := syscall.Read(fd, buffer)\t\t\tif err != nil &#123;\t\t\t\treturn err\t\t\t&#125;\t\t\tif n == 0 &#123;\t\t\t\tbreak // EOF\t\t\t&#125;\t\t\tfor i := 0; i &lt; n; i++ &#123;\t\t\t\tif buffer[i] == &#x27;\\n&#x27; &#123;\t\t\t\t\tkey := string(lineBuffer)[:3]\t\t\t\t\tstorage[key] = append(storage[key], &amp;File&#123;fd: fd, offset: offset - int64(len(lineBuffer)), size: len(lineBuffer) + 1&#125;)\t\t\t\t\tlineBuffer = nil\t\t\t\t&#125; else &#123;\t\t\t\t\tlineBuffer = append(lineBuffer, buffer[i])\t\t\t\t&#125;\t\t\t\toffset += 1\t\t\t&#125;\t\t&#125;\t&#125;\treturn nil&#125;","categories":["算法"],"tags":["Go"]},{"title":"C 转 C++ 刷题教程","url":"/summarize-c_plus_stl/","content":"本文章与其说是 C++ 的 STL 容器使用，其实是在准备算法刷题时总结的一些 API 调用，后来更多的是用 Java，虽说算法不应该和语言挂钩，但不得不承认在刷力扣或是 PAT 算法考试时 C++ 才是我真正的心头好\n\n实际竞赛或是 PAT 考试时经常会同时用到 C 的简单高效和 C++ 的丰富类库，在总结是也着重记录了 C =&gt; C++ 的语法变化和不同应用场景下的选择\n 语法变化\n 输出方法\nC++ 中提供 cin(&gt;&gt;) 和 cout(&lt;&lt;) 进行弱类型的输入和输出，cin 和 cout 虽然使用起来方便，但是输入输出的效率不如 scanf 和 printf\n 头文件\nC++ 的头文件一般是没有像 C 语言的 .h 后缀，但 C++ 向下包含 C，一般 C 语言中的头文件去掉 .h 在前面加上 c 就可以继续使用\n#include &lt;cmath&gt;// 相当于 #include &lt;math.h&gt;#include &lt;cstdio&gt;// 相当于 #include &lt;stdio.h&gt;#include &lt;cstring&gt;// 相当于 #include &lt;string.h&gt;\n bool 类型\nC++ 无需添加头文件就自带布尔类型的变量，在 bool 中 0 为 false，非零为 true\nbool flag=true;bool flag=-357;// 为 truebool flag=0;// 为 false \nC++ 无需用 #define 定义常量，统一用 const 数据类型 常量名称 的方式进行定义\n string 类\nC++ 中自带 string 字符串类，部分情况仍需使用 char[] 数组方法，包含定义、输出、拼接和一定的处理\n尽量使用  头文件，≠\nstring str1 = &quot;Hello World&quot;;// 定义字符串string str2;cin &gt;&gt; str2;// 输入字符串string str3 = str2 + str1;// 字符串拼接cout &lt;&lt; str3 &lt;&lt; endl;// 输出for (int i = 0; i &lt; str1.length(); i++)&#123; // 使用字符数组的方式进行输出    cout &lt;&lt; str1[i];&#125;cout &lt;&lt; endl;\n string 输入输出\n由于 string 是 C++ 中产生的，所以 C 语言中的 scanf 和 printf 函数无法对其进行输入输出的处理\n可以使用 printf(&quot;%s&quot;,str.c_str());的方式进行输出，c_str()函数返回的是一个 C 语言中的 char 指针，表示将字符串转换为一个只读的字符数组\ncin 的输入处理是以空格结束一个字符串的，如果要进行整行字符串的输入（回车结束）需要使用 getline 方法\n对于字符串长度的获取，也可以直接采用 str.length();或者 str.size()的方式\n由于有些函数只支持迭代器为参数，所以 string 也可以以迭代器的方式进行访问（可加减）\nstring str4;getline(cin, str4);//getline 的参数中需要加上 cin 表示输入cout &lt;&lt; str4 &lt;&lt; endl;cout &lt;&lt; str4.length() &lt;&lt; endl; cout &lt;&lt; str4.size() &lt;&lt; endl;  \n string 函数\n\n\nstring 可以直接进行赋值或加减拼接\n\n\n可以直接用比较运算符判断相等或大于小于（以字典序为规则）\n string str1 = &quot;Hello World&quot;; // 定义字符串string str2 = &quot;12345&quot;; str1 += str2; // 相加进行拼接cout &lt;&lt; str1 &lt;&lt; endl; cout &lt;&lt; (str1 &gt; str2) &lt;&lt; endl; // 输出 str1 是否小于 str2\n\n\n输出长度常用 length()而不是 size()\n\n\ninsert()插入函数常用两种方式\n\n直接位置插入： insert(位置下标，要插入的字符串)\n迭代器参数插入，常用于将一个字符串的一部分插入到另一字符串： insert(插入位置，被插入字符串的起点，终点)\n\n\n\nsubstr() 字符串截取函数\nstring str1 = &quot;Hello World&quot;;       // 定义字符串cout &lt;&lt; str1.substr(4) &lt;&lt; endl;    // 从下标 4 开始到结束cout &lt;&lt; str1.substr(4, 6) &lt;&lt; endl; // 从下标 4 开始，截取 6 个字符\n\n\n删除字符的函数 erase()\nerase()接收的也是迭代器作为参数，单个元素或者一个区间\nstring str;cin &gt;&gt; str;while (str.find(&#x27;a&#x27;) != string::npos) //find()返回的是字符的下标&#123;    str.erase(str.find(&#x27;a&#x27;), 1); // 第二个参数的 1 代表删除元素的个数&#125;cout &lt;&lt; str &lt;&lt; endl;str.erase(str.begin()); // 删除第一个字符cout &lt;&lt; str &lt;&lt; endl;str.erase(str.begin(), str.begin() + 2); // 删除一个范围，左闭右开cout &lt;&lt; str &lt;&lt; endl;str.clear(); // 清空字符串   \n\n\nfind()查找字符或字串，查找失败返回 string::npos\nstring str = &quot;qwertasd&quot;;string str2 = &quot;asd&quot;;cout &lt;&lt; str.find(&#x27;a&#x27;) &lt;&lt; endl;// 查找单个字符返回的这个字符的下标，可用其返回值!=string::npos 的方式表示查找成功cout &lt;&lt; str.find(str2) &lt;&lt; endl;    // 返回匹配成功的起始下标cout &lt;&lt; str.find(str2, 4) &lt;&lt; endl; // 表示从下标 4 开始向后查找，返回值与上一样\n\n\nreplace()函数替换字串： replace(替换起始位置，替换长度，替换的字串)\n也支持迭代器参数替换： replace(迭代器位置起，始，字串)\nstring str = &quot;qwertasd&quot;;string str2 = &quot;asd&quot;;cout &lt;&lt; str.replace(3, 3, str2) &lt;&lt; endl; // 从下标 3 开始往后的三个字符被 str2 替代cout &lt;&lt; str.replace(str.begin(), str.begin() + 4, str2) &lt;&lt; endl;  \n\n\n struct 的使用\n在 C++ 中，结构体生成对象时无需进行结构体的声明，也就是不用在前面加是 struct\n结构体的定义尽量在 main() 方法之外\nstruct stu&#123;    int grade;    float score;&#125;;struct stu arr1[10]; // C 语言里面需要写 structstu arr2[10];        // C++ 里面不用写\n &amp; 在 C++ 中的引用\nC++ 中的 &amp; 符号在函数的参数列表中作引用，要与 C 语言的取地址输入分开，这两者并不相同\n做引用时的意思是将传送进来的变量参数直接进行操作（可以理解成拷贝副本），只是将名字换成了定义方法中的局部变量名\nvoid function(int &amp;a); int main()&#123;    int n = 0;    function(n); // n 由 0 变成了 99    cout &lt;&lt; n &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;&#125;void function(int &amp;a)// 传⼊的是 n 的引⽤，相当于直接对 n 进⾏了操作，只不过在 function 函数中换了个名字叫 a&#123;     a = 99;&#125;\nvoid function(int a);int main()&#123;    int n = 0;    function(n); // 并没有对 n 这个值进行改变，还是 0    cout &lt;&lt; n &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;&#125;void function(int a) // 传⼊的是 0 这个值，并不会改变 main 函数中 n 的值&#123;    a = 99;&#125; \n STL 的应用\nSTL 称为标准模板库（Standard Template Library） ，STL 已完全被内置到支持 C++ 的编译器中，无需额外安装\n vector 动态数组\n动态数组 vector，能够在运行阶段设置数组的长度、在末尾增加新的数据、在中间插入新的值、长度任意被改变\n\n\n定义 vector，vector 是包含在头文件 [vector] 中的，预定义头文件之后的生成格式为： vector&lt; 数据类型 &gt; 数组名;\n\n\nvector 的大小如果在初始不进行定义的话默认为 0，可以采用vector&lt; 数据类型 &gt; 数组名(``size``); 的方式来进行初始大小的定义，也可以采用 resize 方法进行大小的重定义\n\n\n对定义了长度的数组，那么它的初始值将全部定义为 0\n也可以采用 vector&lt; 数据类型 &gt; 数组名(size, 初始值);  在初始化的是否就赋予初始值\n\n\n对 vector 动态数组的访问和普通数组的访问方式一样，也是通过下标的方式，但可以通过迭代器进行遍历\n\n\nvector&lt;int&gt; num;cout &lt;&lt; num.size() &lt;&lt; endl; // 刚创建的数组为空，size==0vector&lt;int&gt; number(10);     // 将 number 数组的大小定义为 10cout &lt;&lt; number.size() &lt;&lt; endl;num.resize(5); // 将 num 的长度重定义为 5cout &lt;&lt; num.size() &lt;&lt; endl;for (int i = 0; i &lt; num.size(); i++)&#123;    cout &lt;&lt; num[i] &lt;&lt; &quot; &quot;; // 此时初始值为 0&#125;cout &lt;&lt; endl;vector&lt;int&gt; numbers(10, 5);// 初始化数组长度为 10，所有元素的初始值为 5for (int i = 0; i &lt; numbers.size(); i++)&#123;    cout &lt;&lt; numbers[i] &lt;&lt; &quot; &quot;; // 此时初始值为 5&#125;num.clear();// 清空数组元素，复杂度为 O(N)（N 为元素的个数） for (int i : numbers)// 读取型遍历&#123;  cout &lt;&lt; i &lt;&lt; endl;&#125;  \n\npush_back() 和 pop_back() 函数实现在数组尾插入或删除元素\n\n  vector&lt;int&gt; num = &#123;10, 20, 30&#125;;num.push_back(40); // 在数组末尾插入 40num.pop_back();    // 移除最后一个元素 \n\n迭代器访问，完整的指针类型定义应该是 vector&lt;int&gt;::iterator ，但在 C++１１中出现了 auto 型，会自动进行检测变量的类型\n美国人的思想为  左闭右开 ，也就是 end() 函数不进行存储任何东西，表示一个数组到这就为空了（尾元素的下一个元素的地址）\n\n  vector&lt;int&gt; num = &#123;10, 20, 30, 40, 50&#125;;for (auto it = num.begin(); it != num.end(); it++)//num.begin()是一个指针，代表指向第一个元素&#123;                       //auto 相当于生成一个 vector 类型的迭代器，it 是 iterator 的缩写    cout &lt;&lt; *it &lt;&lt; &quot; &quot;; //it 是一个指针，加 * 进行取值&#125;\n只有 vector 和 string 中才允许有 ve.begin()+3这种迭代器加整数的操作\n\n在指定位置插入新的元素，可以使用自带的 insert()和 emplace()函数\n\ninsert() 函数的功能是在 vector 容器的指定位置插入一个或多个元素。该函数的语法格式有多种\n\n\n\n语法格式\n用法说明\n\n\n\n\ninsert(pos,elem)\n在迭代器 pos 指定的位置之前插入一个新元素 elem，并返回表示新插入元素位置的迭代器\n\n\ninsert(pos,n,elem)\n在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器\n\n\ninsert(pos,first,last)\n在迭代器 pos 指定的位置之前，插入其他容器（不仅限于 vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器\n\n\ninsert(pos,initlist)\n在迭代器 pos 指定的位置之前，插入初始化列表（用大括号 {} 括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器\n\n\n\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;array&gt;using namespace std;int main()&#123;    vector&lt;int&gt; demo&#123;1, 2&#125;;    // 第一种格式用法    demo.insert(demo.begin() + 1, 3); //&#123;1,3,2&#125;    // 第二种格式用法    demo.insert(demo.end(), 2, 5); //&#123;1,3,2,5,5&#125;    // 第三种格式用法    array&lt;int, 3&gt; test&#123;7, 8, 9&#125;;    demo.insert(demo.end(), test.begin(), test.end()); //&#123;1,3,2,5,5,7,8,9&#125;    // 第四种格式用法    demo.insert(demo.end(), &#123;10, 11&#125;); //&#123;1,3,2,5,5,7,8,9,10,11&#125;    for (int i = 0; i &lt; demo.size(); i++)    &#123;        cout &lt;&lt; demo[i] &lt;&lt; &quot; &quot;;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\n\nemplace()用于在 vector 容器指定位置之前插入一个新的元素，其格式为 iterator emplace (const_iterator pos, args...); emplace()函数的效率更高一些\n\n#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std; int main()&#123;    vector&lt;int&gt; demo1&#123;1, 2&#125;;    //emplace() 每次只能插入一个 int 类型元素    demo1.emplace(demo1.begin(), 3);    for (int i = 0; i &lt; demo1.size(); i++)    &#123;        cout &lt;&lt; demo1[i] &lt;&lt; &quot; &quot;;    &#125;    system(&quot;pause&quot;);    return 0;&#125;\nerase()删除函数用来删除数组中的特定元素，但其接收的参数为一个迭代器，可以先用  下的 find()函数查找出位置\nvector&lt;int&gt; num = &#123;3, 4, 5, 6, 7&#125;;auto it = find(num.begin(), num.end(), 6); // 查找相应元素的迭代器num.erase(it);                             // 删除这个元素num.erase(num.begin());for (auto it = num.begin(); it != num.end(); it++)&#123;    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;\n set 集合\n集合中的元素各不相同，而且元素之间会进行从小到大的排序\n\n\nset 是包含在头文件  中的，预定义头文件之后的生成格式为： set&lt; 数据类型 &gt; 集合名;\n\n\nset 集合中的元素是有序的，所以不用管插入的位置，插入方式为： set.insert(元素);\n\n\n集合的输出：使用迭代器的方式进行集合的遍历输出，但集合是默认从小到大排序的，所以可以使用 set.rbegin()/set.rend()反向迭代器实现反向遍历\n可以通过 *(num.begin()) 这种指针取值的方式来对第一个元素（最小元素）进行输出；同理 *(num.rbegin()) 对最后一个元素（最大元素）进行输出\n\n\n对集合中元素的查找可以使用 set.find(目标元素)，但此方法是一个迭代器，我们可以用 set.find(目标元素) != set.end()的方式，通过返回值 1 或 0 判断集合中有无这个元素\n\n\nset&lt;int&gt; num;               // 定义 set 集合num.insert(1);              // 向集合中插入元素 1cout &lt;&lt; num.size() &lt;&lt; endl; // 输出集合的大小for (int i = 3; i &lt; 10; i++)&#123;    num.insert(i);&#125;num.erase(5);// 擦除元素 5cout &lt;&lt; &quot;min:&quot; &lt;&lt; *(num.begin()) &lt;&lt; endl; // 输出集合中第一个元素的元素cout &lt;&lt; &quot;max:&quot; &lt;&lt; *(num.rbegin()) &lt;&lt; endl; // 输出集合中最后一个元素的元素for (auto it = num.begin(); it != num.end(); it++)&#123; // 遍历集合    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;for (auto it = num.rbegin(); it != num.rend(); it++)&#123; // 反向遍历集合    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl     &lt;&lt; (num.find(7) != num.end()) &lt;&lt; endl; // 查找元素 7cout &lt;&lt; *(num.find(7)) &lt;&lt; endl; num.clear(); // 清空集合 \nset 集合的 erase()函数不同于 vector 只能以迭代器作为参数，可以用迭代器，元素值和迭代器范围进行删除\n但是 set 集合又不允许迭代器相加的操作\nset&lt;int&gt; num; // 定义 set 集合for (int i = 0; i &lt; 10; i++)&#123;    num.insert(i);&#125;num.erase(5);                              // 擦除元素 5num.erase(num.begin());                    // 擦除起始元素num.erase(num.begin(), num.find(4));       // 擦除开始到元素 4 的位置（不包含 num.find(4)）\n map 键值对\nmap 集合又称为映射，采用一键对一值的方式进行存储，存放的元素会通过键进行从小到大的排列\nmap 是包含在头文件  中的，预定义头文件之后的生成格式为： map&lt; 键数据类型, 值数据类型 &gt; 集合名; \n通过键作为下标存储值达到同时存储一对数据的目的，擦除也是一样\n也有迭代器遍历和反迭代器的内部函数，但是无需对指针进行取值，只要用指针指向 frist 或 second 便可直接显示键或值的内容，如 data.begin()-&gt;frist 表示第一对元素的键的内容\nmap&lt;string, int&gt; data;data[&quot;hello&quot;] = 2;data[&quot;world&quot;] = 7;data[&quot;;&quot;] = 2;                 // 在 map 中插入元素cout &lt;&lt; data[&quot;hello&quot;] &lt;&lt; endl; // 通过键输出值, 不存在返回 0cout &lt;&lt; data.size() &lt;&lt; endl;   //map 的大小，一对键值看作一个元素data.erase(&quot;hello&quot;);           // 通过键擦除一对元素for (auto it = data.begin(); it != data.end(); it++)&#123; // 迭代器遍历，直接用指针取值，指向 frist 表示键，指向 seco 表示值    cout &lt;&lt; it-&gt;first &lt;&lt; &quot;  &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;&#125; \n\n\nfind()函数，参数为 key，查找成功返回一个迭代器\n\n\ncount()函数，返回被查找元素的个数（map 中的元素不重复，值只可能是 1 或 0），参数也是 key\n\n\nerase()函数，删除单个元素时的参数可以是迭代器也可以是 key，删除区间元素只能是迭代器的起始位置\n\n\nmap&lt;char, int&gt; data;data[&#x27;a&#x27;] = 2;data[&#x27;b&#x27;] = 3;data[&#x27;c&#x27;] = 4;data[&#x27;d&#x27;] = 5;auto it = data.find(&#x27;a&#x27;); // 查找成功返回位置 5cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;data.erase(&#x27;a&#x27;);                      // 通过 key 删除元素data.erase(data.find(&#x27;b&#x27;));           // 通过迭代器删除元素data.erase(data.begin(), data.end()); // 通过迭代器起始删除区间元素data.clear();                         // 清空元素\n unordered 集合\n因为在 map 和 set 集合中的元素都是有序的，但 unordered 的意思是未经排序，也就是里面的元素是无序的，时间复杂度更小一下，用法相同\n queue 队列\n有头尾指针 front 和 back，先进先出，队尾入，队首移除\n主要使用是在广度优先搜索时无需手动编写队列\n\n\n头文件，定义格式： queue&lt; 数据类型 &gt; 队名;\n\n\npush()和 pop()进行入队和出队操作（队尾入，队首出），无法遍历，可读取队首队尾，可访问大小\n\n\nqueue&lt;int&gt; que;for (int i = 0; i &lt; 10; i++)&#123;    que.push(i); // 从队尾入队&#125;que.pop();                                        // 移除队首元素cout &lt;&lt; que.front() &lt;&lt; &quot; &quot; &lt;&lt; que.back() &lt;&lt; endl; // 输出首尾元素cout &lt;&lt; que.size() &lt;&lt; endl;                       // 输出大小cout &lt;&lt; que.empty() &lt;&lt; endl;                      // 判断是否为空\n\nempty()函数判断是否为空返回 bool 型，在使用 front 和 back 进行输出时，先判断是否为空，否则容易出错\n\n priority_queue 队列\n称为优先队列，底层是用堆来实现的，具体表现为队首元素永远时优先级最高的那个（优先级可以自己规定）\n优先队列没有 front 和 back 指针，统一用 top 来对队首进行操作（又称为堆顶），其他使用与 queue 无异\npriority_queue&lt;int&gt; num;num.push(2);num.push(4);num.push(3);cout &lt;&lt; num.top() &lt;&lt; endl; // 输出堆顶num.pop();cout &lt;&lt; num.top() &lt;&lt; endl;\n优先级的定义，可以使用自带的大小定义，其格式为： priority_queue&lt; 类型，vector&lt; 类型 &gt;，less&lt; 类型 &gt;&gt; num;  这是指小的放后边，也就是默认的规则，若改为大的放后边只要将 less 改为 greater 即可\n其他方法看算法笔记 P235\n stack 栈\n先进后出，只能对栈顶进行操作，所以只有一个指针 top\n\n\n头文件，定义格式： stack&lt; 数据类型 &gt; 栈名;\n\n\npush()和 pop()进行入栈和出栈操作，无法遍历，只能读取栈顶 top，可访问大小\n\n\nstack&lt;int&gt; s; // 定义⼀个空栈 sfor (int i = 0; i &lt; 6; i++)&#123;    s.push(i); // 将元素 i 压⼊栈 s 中&#125;s.pop();                  // 移除栈顶元素cout &lt;&lt; s.top() &lt;&lt; endl;  // 访问 s 的栈顶元素cout &lt;&lt; s.size() &lt;&lt; endl; // 输出 s 的元素个数 \n pair 元素对\n在头文件  中，主要是将两个元素（无论类型是否相同）合成一个元素，就像定义在结构体中定义两个不同变量，但是用起来更简单，可以直接比较大小（先比较 first，如果相同再比较 second）\n访问就像 map 中的 first 元素和 second 函数（但不是指向，而是类似结构体的形式）\n初始化可以直接在后边加圆括号直接输入，还有三种赋值方式\npair&lt;string, int&gt; psi;//pair&lt;string, int&gt; psi(&quot;hh&quot;, 5);// 初始化 psi = make_pair(&quot;ha&quot;, 6); // 使用 make_pair() 函数定义cout &lt;&lt; psi.first &lt;&lt; &quot; &quot; &lt;&lt; psi.second &lt;&lt; endl;psi = pair&lt;string, int&gt;(&quot;hh&quot;, 5); // 指定类型定义cout &lt;&lt; psi.first &lt;&lt; &quot; &quot; &lt;&lt; psi.second &lt;&lt; endl;psi.first = &quot;xx&quot;; // 指定变量定义psi.second = 7;cout &lt;&lt; psi.first &lt;&lt; &quot; &quot; &lt;&lt; psi.second &lt;&lt; endl;\n具体使用就是代替二元结构体和作为键值对插入 map 中\nmap&lt;string, int&gt; msi;msi[&quot;hh&quot;] = 6;                    // 传统定义msi.insert(make_pair(&quot;xixi&quot;, 8)); //pair 插入auto it = msi.find(&quot;hh&quot;);cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;it = msi.find(&quot;xixi&quot;);cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n","categories":["算法"],"tags":["C/C++"]},{"title":"C++ 刷题实用方法总结","url":"/summarize-c_plus_utility/","content":"\n\n准备 PAT 竞赛时自己总结的实用函数，搞过 OJ 的应该都有一套自己总结的算法秘籍（小抄），这种东西主观性比较强，自己搞的才看的懂，发出来做个记录吧\n\n cmath 头文件\n其针对的参数大多为 double，所有进行整型判断的时候需要进行转换：(double)int；\n\n\n\n方法\n含义\n\n\n\n\nfabs()\n绝对值\n\n\nfloor()、ceil()\n向下、向上取整\n\n\npow(r, p)\n幂值： rpr^prp\n\n\nsqrt()\n开根\n\n\nround()\n四舍五入取整\n\n\nlog()\n以 e 为底的对数\n\n\n\n并没有以任意数为底的求对数函数，但可以采用换底公式： logab=logeb/logealog_ab=log_eb/log_ealoga​b=loge​b/loge​a\n climits 头文件\n最常使用的是对最大最小值的赋予： INT_MAX/MIN\nint max = INT_MIN, min = INT_MAX; // 最大值初始要足够小，最小值要足够大cout &lt;&lt; max &lt;&lt; &quot; &quot; &lt;&lt; min &lt;&lt; endl;\n bitset 头文件\n 二进制操作\nbitset&lt;5&gt; b(&quot;11&quot;); //5 表示 5 个⼆进位 // 初始化⽅式：// bitset&lt;5&gt; b; 都为 0// bitset&lt;5&gt; b(u); u 为 unsigned int，如果 u = 1, 则被初始化为 10000// bitset&lt;5&gt; b(s); s 为字符串，如 &quot;1101&quot; -&gt; &quot;10110&quot;// bitset&lt;5&gt; b(s, pos, n); 从字符串的 s[pos] 开始，n 位⻓度for (int i = 0; i &lt; 5; i++)    cout &lt;&lt; b[i];cout &lt;&lt; endl     &lt;&lt; b.any(); //b 中是否存在 1 的⼆进制位cout &lt;&lt; endl     &lt;&lt; b.none(); //b 中不存在 1 吗？cout &lt;&lt; endl     &lt;&lt; b.count(); //b 中 1 的⼆进制位的个数cout &lt;&lt; endl     &lt;&lt; b.size(); //b 中⼆进制位的个数cout &lt;&lt; endl     &lt;&lt; b.test(2);              // 测试下标为 2 处是否⼆进制位为 1b.set(4);                       // 把 b 的下标为 4 处置 1b.reset();                      // 所有位归零b.reset(3);                     //b 的下标 3 处归零b.flip();                       //b 的所有⼆进制位逐位取反unsigned long a = b.to_ulong(); //b 转换为 unsigned long 类型\n 进制转换函数\n 手动写法\nint len = 0, arr[100];do&#123;    arr[len++] = n % radix;    n = n / radix;&#125; while (n != 0); // 十进制转为其他进制for (int i = len - 1; i &gt;= 0; i--)&#123;    n = n * radix + arr[i];&#125; // 其他进制转为十进制\n 输出格式\n在使用  头文件时可以根据输出关键字进行进制的转换\ncout &lt;&lt; &quot;35 的 8 进制:&quot; &lt;&lt; oct &lt;&lt; 35 &lt;&lt; endl;cout &lt;&lt; &quot;35 的 10 进制 &quot; &lt;&lt; dec &lt;&lt; 35 &lt;&lt; endl;cout &lt;&lt; &quot;35 的 16 进制:&quot; &lt;&lt; hex &lt;&lt; 35 &lt;&lt; endl;cout &lt;&lt; &quot;35 的 2 进制: &quot; &lt;&lt; bitset&lt;8&gt;(35) &lt;&lt; endl; //&lt;8&gt;：表示保留 8 位输出\n strtol()函数\n任意进制转换为十进制(str→long int)，其格式为： long int strtol(const char *nptr, char **endptr, int base) ，base 是要转化的数的进制，非法字符会赋值给 endptr，nptr 是要转化的字符\n因为是 C 语言自带的函数，所以字符串只能用 char 数组的方式读入（也可以字符串读入然后转换成字符数组）\nchar a[20]=&quot;10549stend#12&quot;;  char *stop;  // 建立一个由 stop 指向的字符数组int ans=strtol(a, &amp;stop, 8);   // 将八进制数 1054 转成十进制，后面均为非法字符printf(&quot;%d\\n&quot;,ans);  printf(&quot;%s\\n&quot;, stop);   \n itoa()函数\n十进制转换为任意进制(int→str)，其格式为： charitoa(int value,charstring,int radix);，radix 是要转化的数的进制\n因为是 C 语言自带的函数，所以字符串只能用 char 数组的方式读入（也可以字符串读入然后转换成字符数组）\nint num = 10;  char str[100];  _itoa(num, str, 2);  //c++ 中一般用_itoa，用 itoa 也行,printf(&quot;%s\\n&quot;, str);\n sprintf()函数\n也是将一个 10 进制数转换为指定格式的 n 进制字符串，函数原型： int sprintf(char *buffer, const char *format, [ argument] … )\nchar s[100]=&#123;0&#125;;sprintf(s, &quot;%d&quot;, 123); // 十进制输出产生 &quot;123&quot;sprintf(s, &quot;%4d%4d&quot;, 123, 4567); // 指定宽度不足的左边补空格，产生：&quot; 1234567&quot;sprintf(s, &quot;%8o&quot;, 123);    // 八进制输出，宽度占 8 个位置sprintf(s, &quot;%8x&quot;, 4567); // 小写 16 进制，宽度占 8 个位置，右对齐sprintf(s, &quot;%10.3f&quot;, 3.1415626); // 产生：&quot; 3.142&quot;int i = 100;sprintf(s, &quot;%.2f&quot;, i);    // 注意这是不对的sprintf(s, &quot;%.2f&quot;, (double)i);    // 要按照这种方式才行\n cstring 头文件\n 函数初始化数组\n给数组初始化时，可以使用 memset()函数进行填充，而不用 for 循环遍历，其格式为： memset(数组名, 初始值,sizeof(数组名)); 其在头文件  中，只用 memset()函数为数组赋 0 或 -1 时使用\n也可对二维数组和多维数组进行初始操作\nint arr[10];memset(arr, 0, sizeof(arr));for (auto i = 0; i &lt; 10; i++)&#123;    cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;&#125;\n 字符串转换数组\n字符串转换为字符数组需要使用  中的 strncpy 方法将字符串内容挨个拷贝进数组中\n字符数组转换为字符串可以直接进行赋值转换\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std; int main()&#123;    string s = &quot;aaaa vvva&quot;;    char a[10];    strncpy(a, s.c_str(), s.length()); // 使用 &lt;cstring&gt; 中的方法将字符串拷贝到数组中    for (int i = 0; i &lt; 10; i++)        cout &lt;&lt; a[i];    cout &lt;&lt; endl;    char arr[] = &quot;123 45sdf&quot;;    string str = arr; // 直接将数组名赋值给字符串    cout &lt;&lt; str &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;&#125;\n tostring 函数\n在头文件  中，也可以不用\n作用是将其他类型的数据转换为 string 型\nstring s1 = to_string(123); // 将 123 这个数字转成字符串cout &lt;&lt; s1 &lt;&lt; endl;string s2 = to_string(4.5); // 将 4.5 这个数字转成字符串cout &lt;&lt; s2 &lt;&lt; endl;cout &lt;&lt; s1 + s2 &lt;&lt; endl;           // 将 s1 和 s2 两个字符串拼接起来并输出printf(&quot;%s\\n&quot;, (s1 + s2).c_str()); // 如果想⽤printf 输出 string，得加⼀个.c_str()\nstring 转换成 int，double 可以使用 stoi 和 stod 方法，其含义为 string to int，其他数据类型也适用只要将最后一个字母写成目标类型的首字母\nstring str = &quot;123&quot;;int a = stoi(str); // 非法字符会自动去除cout &lt;&lt; a &lt;&lt; endl;str = &quot;123.44&quot;;double b = stod(str);cout &lt;&lt; b &lt;&lt; endl;\n algorithm 头文件\n 数学函数\nmax(x,y)、min(x,y)函数用来返回两个数（可以是浮点）中较大或较小的那个，如果是判断三个数的最大值可以写成： max(a,max(b,c))\nabs()只能是整数，浮点数可以用  下的 fabs()\nswap()用来交换两个数的值\n sort 函数\nsort 排序函数在头文件  中，主要是对数组进行排序，格式为： sort(数组头，数组尾，规则 cmp);\ncmd 的排序规则的格式是返回一个大小判断的 bool 值，不能有 = 号，sort 是不稳定的排序\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;bool cmp(int a, int b) //cmp 规则的定义几乎都是这种格式&#123;                      // cmp 函数返回的值是 bool 类型    return a &gt; b;      // 从大到小排列，不能有“=”号&#125;int main()&#123;    vector&lt;int&gt; v(10);    for (int i = 0; i &lt; 10; i++)    &#123;        cin &gt;&gt; v[i];    &#125;    sort(v.begin(), v.end()); // 因为这⾥没有传⼊参数 cmp，所以按照默认，v 从小到大排列    int arr[10];    for (int i = 0; i &lt; 10; i++)    &#123;        cin &gt;&gt; arr[i];    &#125;    sort(arr, arr + 10, cmp); // arr 从⼤到小排列，因为 cmp 函数排序规则设置从大到小    system(&quot;pause&quot;);    return 0;&#125;\n struct 的 sort\n结构体中可能会对多个变量进行比对，这就需要进行自定义的 cmp 函数\n有一个学生结构体，要对学生进行排序时按照如下方法：当成绩不同时按从大到小排列，若成绩相同，对相同者进行学号从小到大排列\nstruct stu&#123; // 定义⼀个结构体 stu，number 表示学号，score 表示分数    int number;    int score;&#125;; bool cmp(stu a, stu b)&#123;                           // cmp 函数，返回值是 bool，传⼊的参数类型应该是结构体 stu 类型    if (a.score != b.score) // 如果学生分数不同，就按照分数从大到小排列        return a.score &gt; b.score;    else // 如果学生分数相同，就按照学号从小到大排列        return a.number &lt; b.number;&#125;bool cmp(stu a, stu b)&#123; // 写成三目运算符    return a.score != b.score ? a.score &gt; b.score : a.number &lt; b.number;&#125;\n cmp_char[]\n字符数组的排序不能像字符串那样直接进行比较，需要使用  中的 strcmp()函数\nreturn (strcmp(a.name, b.name) &lt; 0); // 递增return (strcmp(a.name, b.name) &gt; 0); // 递减 \n 项式 cmp\nPAT(advance)中的 T1038 中就要将字符串使用多项式相加的规则进行排序\nbool cmp(string a, string b)&#123;    return a + b &lt; b + a; // 如果 a+b&lt;b+a，a 就在前面，否则反之&#125;\n reverse()函数\n中的反转函数，通过指针或迭代器用来反转相应范围内的数，应用于数组和字符串较多\n用来反转字符串非常方便\nchar arr[8] = &#123;&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;&#125;;reverse(arr, arr + 4);string str;getline(cin, str);reverse(str.begin(), str.end());// 反转首尾cout &lt;&lt; str &lt;&lt; endl;\n next_pernumtation()\n当前序列的下一个全排列，可配合 do…while()循环输出一个序列的全排列\nint arr[3] = &#123;1, 2, 3&#125;;do // 先输出本身&#123;    cout &lt;&lt; arr[0] &lt;&lt; &quot; &quot; &lt;&lt; arr[1] &lt;&lt; &quot; &quot; &lt;&lt; arr[2] &lt;&lt; endl; // 只能使用单循环语句&#125; while (next_permutation(arr, arr + 3));                     // 输出最后一个序列后返回值为 false\n max_element（）及 min_element（）函数\n中的求最大最小值的函数，可对普通数组和 vector 数组进行使用\n返回的是迭代器或指针，所以加上取值符 *，若求下标则用返回的结果减去数组的起始位置即可\n// 求值vector&lt;int&gt; vec;int maxValue = *max_element(v.begin(),v.end()); int minValue = *min_element(v.begin(),v.end());int maxPosition = max_element(v.begin(),v.end()) - v.begin(); a[]=&#123;1,2,3,4,5,6&#125;;int maxValue = *max_element(a,a+6); int minValue = *min_element(a,a+6); int maxPosition = max_element(a,a+6) - a; \n 初始化数组\n memset()函数\n给数组初始化时，可以使用 memset()函数进行填充，而不用 for 循环遍历，其格式为： memset(数组名, 初始值, sizeof(数组名));  其在头文件  中，只用 memset()函数为数组赋 0 或 -1 时使用\n也可对二维数组和多维数组进行初始操作\nint arr[10]; memset(arr, 0, sizeof(arr)); for (auto i = 0; i &lt; 10; i++)&#123;    cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;&#125;\n fill()函数\n与 memset 不同的是可以对数组不同范围内赋予任意值，格式： fill(起，始，初始值)\nint arr[10];fill(arr + 2, arr + 5, 234);\n find 函数\nfind()函数的具体实用是可以返回一个数组（包括动态）中某个特定元素的指针（迭代器），因为数组的存储空间是连续的，用当前指针（迭代器）去减去开始的指针（迭代器）得到的就是数组中该元素的下标\nint a[] = &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;;int a_length = sizeof(a) / a[0]; // 获取数组 a 的长度vector&lt;int&gt; b&#123;10, 20, 30, 40, 50&#125;;int *a_head = a;                                // 获取起始位置int *a_position = find(a, a + a_length, 6);     // 被查找元素的位置cout &lt;&lt; a_position - a_head &lt;&lt; endl;            // 下标auto b_position = find(b.begin(), b.end(), 30); // 动态数组返回的是迭代器类型，auto==vector&lt;int&gt;::iteratorcout &lt;&lt; b_position - b.begin() &lt;&lt; endl;         // 下标\n binary_search()\n用以实现二分查找： binary_search(first,last,val)，直接使用 find 函数也可，但如果查找数组中第一个大于 X 的数就不好实现了，所以二分查找又延伸出边界的查找\nint a[100] = &#123;4, 10, 11, 30, 69, 70, 96, 100&#125;;int b = binary_search(a, a + 9, 4); // 查找成功，返回 1\n 查找边界\nlower_bound()和 upper_bound()函数作用的对象是一个有序数组或容器，其格式为： lower_bound(first, last, val) ，返回数组或容器中第一个小于（或大于）val 的值的位置（指针或迭代器），若获取下标用其返回的位置减去起始位置即可\nvector&lt;int&gt; v = &#123;2, 5, 1, 3, 7, 6, 9, 5&#125;;sort(v.begin(), v.end());int up_position = upper_bound(v.begin(), v.end(), 6) - v.begin();cout &lt;&lt; v[up_position] &lt;&lt; endl;int arr[10] = &#123;3, 5, 6, 2, 7, 9, 1, 2, 6, 8&#125;;sort(arr, arr + 10);int low_position = lower_bound(arr, arr + 10, 7) - arr - 1;cout &lt;&lt; arr[low_position] &lt;&lt; endl;\n cctype 头文件\n就是 C 语言中的 &lt;ctype.h&gt; 头文件，里边包含一些类型判断函数非常方便\n有时不进行头文件引用也可以进行函数的使用\nchar c;cin &gt;&gt; c;if (isalpha(c))&#123;    cout &lt;&lt; &quot;c is alpha&quot;;&#125;if (islower(c))&#123;    cout &lt;&lt; endl         &lt;&lt; &quot;islow&quot;;&#125;\n其他的判断函数还包括：\n\n\n\n\n\n\n\n\n\n函数名\n意义\n\n\nisalpha\n字母（包括大写、小写）\n\n\nislower\n小写字母\n\n\nisupper\n大写字母\n\n\nisalnum\n字母（大写、小写）+ 数字\n\n\nisblank\nspace 和 \\t\n\n\nisspace\nspace、\\t、\\r、\\n\n\n\n\n此外还有 tolower 和 toupper 方法用来将字符转换为大写或小写\nchar c = &#x27;A&#x27;;char t = tolower(c); // 将 c 字符转化为⼩写字符赋值给 tcout &lt;&lt; t &lt;&lt; endl;   // 此处 t 为 &#x27;a&#x27; \n","categories":["算法"],"tags":["C/C++"]},{"title":"Java 刷题实用方法总结","url":"/summarize-java_utility/","content":"\n\nJava 刷算法时的常用 API 以及一些奇技淫巧，当时参加蓝桥杯总结的，隔一段时间再刷题的时候总会拿出来看看\n\n Java 语法操作\n 输入 输出\n对字符串的获取可以采用 next() 和 nextline() ，用 hasNext() 或 hasNextline() 判断是否还有数据输入\nhasNext() 或 hasNextline() 在 while 循环中可能没啥区别，但 next() 和 nextline() 却大有不同\nnext() 不能读取空格，换言之，读取到有效字符之后遇到空格就会停止，但 nextline() 以 Enter 结束，能存储对应格式的任何字符\n 多行输入\n存在输入多行，且每行输入的字符或数字个数不定的情况，这就需要将 hasnext() 和 nextline() 搭配使用\n具体方法是实例化两个 Scanner 对象 former 和 latter，其中 latter 的参数是 former 的 nextline() ，然后使用 hasnext() 判断获取到的行是否存在下一个输入\nScanner scanner = new Scanner(System.in);int N = scanner.nextInt();scanner.nextLine();// 抵消 N 后面的换行符int[] arr = new int[10000];int count = 0;for (int i = 0; i &lt; N; i++) &#123;    Scanner input = new Scanner(scanner.nextLine());// 获取每行    while (input.hasNext()) &#123;// 遍历每行数据        arr[count++] = input.nextInt();    &#125;&#125;\n 输入字符\nJava 中不提供 nextChar() 的方法，但可以使用next().charAt(0)\nScanner sc = new Scanner(System.in);char c= sc.next().charAt(0);// 将不空格的一串字符按数组存储：`sc.next().toCharArray();`int n = sc.nextInt();int m = sc.nextInt();char[][] arr = new char[n][m];for (int i = 0; i &lt; n; i++) &#123;    arr[i] = sc.next().toCharArray();// 读入字符串拆分成字符数组&#125;\n 格式化输出\nString.format() 和 System.out.printf() 可以进行格式化的输出效果\n%4d 和 %-4d 的区别： %4d 是靠右输出四位，不足用空格补齐； %-4d 是靠左输出\n输出 N 位小数，可以使用 DecimalFormat 对格式进行定义；或者使用 String.format(格式, 浮点变量) 直接打印\npublic static void main(String[] args) &#123;    float f= (float) 3.234567;    // 正常输出    System.out.println(f);    // 采用类    DecimalFormat df=new DecimalFormat(&quot;#0.00&quot;);    System.out.println(df.format(f));    // 模仿 C 语言    System.out.printf(&quot;%.2f\\n&quot;,f);//printf 支持和 C 语言相似的格式化输出    // 转换格式    System.out.println(String.format(&quot;%.2f&quot;,f));&#125;\n\n结果：2.35  2.35\n\n 循环的注意\n 判断引用型\n引用型在循环中的判断不能直接使用 == , 因为即便内容相等的两个数也有可能被引用的地址不相同，而 == 比较的就是引用的地址如下面这种情况：\nString str1 = &quot;hello&quot;;String str2 = &quot;HELLO&quot;.toLowerCase();// 此时的 str1 和 str2 在内容是是相等的但进行等值判断是却会进行不等的运算\n对引用型的数据统一使用 equals() 的方式进行判断： if(s1.equals(s2))&#123;···&#125; 但注意如果 s1 的值是空的时候也会报错\n所以可以使用 if(s1!=null &amp;&amp; s1.equals(s2))&#123;···&#125; 进行判断\n switch 的用法\nJava 中的 switch 循环支持字符串的匹配，但不要忘记每个语句后面加 break; \nJava12 之后的 switch 语句中支持使用 -&gt; 符号取代 : 进行自动跳出的 case 语句，如果一个 case 中要运行多个语句可以用 &#123;&#125; 括起来\n 数组的操作\n初始化数组可以使用 Arrays.fill() 方法\nboolean[] arrPrimer = new boolean[10000];Arrays.fill(arrPrimer, Boolean.TRUE);\n 遍历数组\n数组的遍历有三种方式： for() 循环搭配索引、 for each 迭代每个元素(但无法获取索引)、转换成字符串输出\nJava 标准库提供的 Arrays.toString() 方法进行将整个数组转换为字符串直接打印输出，二维数组使用： Arrays.deepToString()\nint[] arr=&#123;1,2,3,4,5,6,7,8&#125;;System.out.println(Arrays.toString(arr));\n\n结果：[1, 2, 3, 4, 5, 6, 7]\n\n 数组排序\n使用 Arrays 中的 sort 方法可以对数组进行快速排序；若要实现降序排序可以使用 Collections.reverseOrder() 方法(仅对类起作用)\nint[] arr = &#123;1, 3, 6, 2, 4, 8, 7, 9&#125;;Arrays.sort(arr);Integer[] arr = &#123;1, 3, 6, 2, 4, 8, 7, 9&#125;;Arrays.sort(arr, Collections.reverseOrder());for (int m : arr)    System.out.print(m + &quot; &quot;);\n 拷贝数组\n可以直接使用数组自身的 .clone() 方法，因为数组是引用型，将数组放入方法或者类中很容易导致内外部操作互相影响，所以 .clone() 方法在这种场景下常用\nint[] arr = &#123;1, 4, 5, 2, 8, 12, 99, 345, 234, 6&#125;;int[] copy = arr.clone();System.out.println(Arrays.toString(arr));System.out.println(Arrays.toString(copy));\n系统提供的数组拷贝方法： System.arraycopy(Object a, int begin_a, Object b, int begin_b, int length); \npublic static void main(String[] args) &#123;    int a[]=&#123;1,2,3,4&#125;;    int b[]=new int[10];    System.arraycopy(a,0,b,0,3);    for (int n:b)        System.out.print(n+&quot; &quot;);&#125;// 这种方法可以进行自定义长度的拷贝\n\n结果：1 2 3 0 0 0 0 0 0 0\n\n将一个数组的一部分拷贝到另一数组中可以使用 Arrays.copyOf(object, length);  方法\npublic static void main(String[] args) &#123;    int a[]=&#123;1,2,3,4&#125;;    int b[]= Arrays.copyOf(a,3);    for (int n:b)        System.out.print(n+&quot; &quot;);&#125;\n\n结果：1 2 3\n\n Arrays 类\nArrays 类提供很多使用的方法，常见的如下：\nArrays.asList(Object[] a) // 数组转换成 List public static int binarySearch(Object[] a, Object key) // 二分查找 (仅支持有序)public static boolean equals(Object[] a, Object[] a2)  // 判断两数组内容是否一致public static void fill(Object[] a, Object val)   // 在 a 中所有位置填充 valpublic static void fill(Object[] a, int fromIndex, int toIndex, Object val)// 在[fromIndex,toIndex) 中填充 val// 其提供了三种排序比较方法：public static void sort(Object[] a) // 改进的快速排序（升序）public static void sort(Object[] a, int fromIndex, int toIndex) // 对 [fromIndex,toIndex) 升序排序public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) // 自定义比较器排序\n 字符串\n Character 类\n主要应用其中的字符类型判断函数，可以节约时间\n\n\n\n函数名\n用途\n\n\n\n\nCharacter.isDigit(char c)\n判断字符 c 是否是数字字符\n\n\nCharacter.isLowerCase(char c)\n判断 c 是否是小写字母字符\n\n\nCharacter.isUpperCase(char c)\n判断 c 是否是大写字母字符\n\n\nCharacter.isLetterOrDigit(char c)\n判断 c 是否是字母或数字字符\n\n\n\n String 类\n存入两个字符相同的 string 型时，两者的地址也相同(将后创建的地址指向前者，节约内存)；但是 new String 的两个不同对象的内容即便相同地址也不同\npublic static void main(String[] args) &#123;    String a=&quot;asd&quot;;    String b=&quot;asd&quot;;    boolean t=a==b;    String c=new String(&quot;iop&quot;);    String d=new String(&quot;iop&quot;);    boolean y=c==d;    System.out.println(t);    System.out.println(y);&#125;//== 和！= 是用来判断 string 对象地址是否相同的\n\n结果：\ntrue\nfalse\n\n判断 string 对象是否相同用自带的 .equals() 方法，同时还提供一种忽略大小写的判断方法 .equalsIgnoreCase()\npublic static void main(String[] args) &#123;    String a = &quot;asd&quot;;    String b = &quot;asd&quot;;    if (a.equals(b)) &#123;        System.out.println(&quot;==&quot;);    &#125; else &#123;        System.out.println(&quot;!=&quot;);    &#125;    System.out.println(a.equalsIgnoreCase(b.toUpperCase()));&#125;\n\n结果：==\ntrue\n\n要想遍历 string 的字符内容，需要将其转换为字符数组\npublic static void main(String[] args) &#123;    String a = &quot;asd&quot;;    char arr[] = a.toCharArray();    for (char n : arr)        System.out.print(n + &quot; &quot;);&#125;\n\n结果：a s d\n\n\n\n\n方法\n目的\n\n\n\n\ncontains()\n是否包含相应的字符或子串\n\n\ntrim()\n移除首位空白字符(\\t, \\r, \\n)\n\n\nisEmpty()\n是否为空\n\n\nisBlank()\n是否为空白字符串\n\n\nreplace()\n替换字符(串)\n\n\njoin(&quot;?&quot;,arr)\n用指定字符连接字符或字符串\n\n\nsplit(&quot;?&quot;)\n分割字符串\n\n\n\npublic static void main(String[] args) &#123;    String s = &quot;asdeGHAasDeFg&quot;;    for (int i = 0; i &lt; s.length(); i++) &#123;        char c = s.charAt(i);// 字符串转换为字符    &#125;    // 指定字符的查找    s.indexOf(&#x27;s&#x27;);    s.indexOf(&#x27;s&#x27;, 2);    s.lastIndexOf(&#x27;s&#x27;);    s.lastIndexOf(&#x27;s&#x27;, 6);    String[] ss = s.split(&quot;s&quot;);// 将字符串按指定字符分割    String str1 = s.substring(2, 5);// 截取 start 到 end 的子串，左闭右开    char[] cs = s.toCharArray();// 字符串转换为字符数组    String str2 = s.toLowerCase();// 将字符串转换为小写    String sToL = s.toUpperCase();// 将字符串转换为大写    String sToU = String.valueOf(123);    // 将指定数据转换为字符串，也可加参数 radio 将其转换为 radio 进制的字符串&#125;\n StringBuilder\nStringBuilder 对象被当作是一个包含字符序列的变长数组，在需要频繁更改字符串的场景下常用\npublic static void main(String[] args) &#123;    var sb = new StringBuilder(&quot;String&quot;);    sb.append(&quot;123&quot;);// 每次返回添加后的自身，因此可以进行链式操作    sb.append(&quot;456&quot;).append(&quot;789&quot;);    sb.reverse();// 反转    sb.delete(3, 7);// 删除索引从 a 开始到 b 的所有字符（左闭右开）    sb.deleteCharAt(3);// 删除索引为 a 的字符；    sb.insert(4, &quot;string&quot;);// 参数字符插入到指定位置&#125;\n StringJoiner\n在 String 中有 join 方法进行使用特定字符连接字符串，但如果数据太多就不实用了\npublic static void main(String[] args) &#123;    var sj = new StringJoiner(&quot; +++ &quot;, &quot;Hello: &quot;, &quot;!&quot;);    // 初始化时参数默认是连接符，多个参数格式为(连接符，开头，结束)    String[] strArr = &#123;&quot;Aidan&quot;, &quot;Amy&quot;, &quot;Bob&quot;, &quot;Jack&quot;, &quot;Jhon&quot;&#125;;    for (String each : strArr) &#123;        sj.add(each);    &#125;    System.out.println(sj);&#125;\n\n结果：Hello: Aidan +++ Amy +++ Bob +++ Jack +++ Jhon!\n\n 边界处理\n数组判空： if(arr == null|| arr.length == 0)\n二维数组判空： if(arr == null || arr.length == 0 || arr[0].length == 0)\n字符串判空： if(str == null || str.equals(&quot;&quot;))\n所有封装类的最大最小值都有其存在的方法： Integer n=Integer. MAX_VALUE; \n浮点数的判断条件，因为浮点数的值往往没法准确进行显示，所以对数据较为精确的题目的判断条件要使用差的绝对值小于某个临界值的形式： Math.abs(x-0.1)&lt;0.00001\n有些数据的处理还要使用扩大 1000(甚至更大)倍转换成 Long Long 形式，然后在输出的时候除以之前扩大的倍数\n 格式转换\n程序运算时会进行自动转型，但这是由下向上转型，所有有些时候需要进行强制转型\n最简单直接的是在变量前加(目标类型)，此方法只用于基本的数据类型，不支持 String 类型\nString 和其他基本数据类型的转换\n可以使用 toString 将其他数据类型转换为 String 类，但这种方法只对包装类起作用(如：Integer)\n使用 String 自带的 valueOf()方法，支持将基本的数据类型转换\n而将 String 转换为其他，可以用自带类的.parseXXX(string)方法\nInteger a=new Integer(100);String s1=a.toString();// 类自带的 toString()方法 int i=99;String s2=String.valueOf(i);//String 自带的 valueOf() 方法 Integer b=Integer.parseInt(s2);// 每个封装类类都有.parseXXX(String s) 方法\n 快速排序\n实用 Arrays 中的 sort 方法可以对数组进行快速排序\n若要实现降序排序可以使用 Collections.reverseOrder() 方法(数组必须为 Integer 类)\nInteger[] arr = &#123;1, 4, 5, 2, 8, 12, 99, 345, 234, 6&#125;;Arrays.sort(arr);// 默认排序Arrays.sort(arr, Collections.reverseOrder());// 反转\n 比较器\n使用 Comparator 类定义的比较器可以实现自定义排序\n排序自定义类 (结构体) 时也可以使用 comparable 接口在类中直接覆写方法\nimport java.util. Arrays; public class Test &#123;    public static void main(String[] args) &#123;        /* 比较器排序        Arrays.sort(arr, new Comparator&lt;Integer&gt;() &#123;            @Override            public int compare(Integer o1, Integer o2) &#123;                return o2-o1;            &#125;        &#125;);*/        Person[] arr = new Person[]&#123;new Person(12, &quot;Aidan&quot;),                new Person(6, &quot;John&quot;),                new Person(12, &quot;Bob&quot;),                new Person(17, &quot;Amy&quot;),                new Person(15, &quot;Dave&quot;),&#125;;        /* 比较器自定义排序类        Arrays.sort(arr, new Comparator&lt;Person&gt;() &#123;            @Override            public int compare(Person o1, Person o2) &#123;                if (o1.age != o2.age) &#123;                    return o1.age - o2.age;                &#125; else &#123;                    return o1.name.compareTo(o2.name);                &#125;            &#125;        &#125;);*/        Arrays.sort(arr, (o1, o2) -&gt; &#123;// 比较器的简单写法            if (o1.age != o2.age) &#123;                return o1.age - o2.age;// 升序            &#125; else &#123;                return o1.name.compareTo(o2.name);// 降序            &#125;        &#125;);        for (Person each : arr) &#123;            System.out.println(each.toString());        &#125;    &#125;&#125;class Person &#123;    public int age;    public String name;    public Person(int age, String name) &#123;        this.age = age;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot; 姓名：&quot; + name + &quot;，年龄：&quot; + age;    &#125;&#125;\n 大数类\n大数类分为整型 BigInteger 和浮点型BigDecimal\n定义 BigInteger 类型可以使用实例化类的方法，也可以使用 BigInteger 中的 valueOf(数字 / 变量)\nBigInteger a = new BigInteger(&quot;3&quot;);BigInteger b = BigInteger.valueOf(3);int i = 788;BigInteger c = BigInteger.valueOf(i);\n大数的类是在 java.math.* 包里的，所以继承了 math 的所有方法，而运算也是使用方法来进行\nBigInteger a = new BigInteger(&quot;3&quot;);BigInteger b = BigInteger.valueOf(-3);int i = 788;BigInteger c = BigInteger.valueOf(i);BigInteger ad=a.add(c);BigInteger sub=a.subtract(b);BigInteger mul=a.multiply(b);BigInteger div=c.divide(a);BigInteger re=c.remainder(a);BigInteger ab=b.abs();System.out.println(ad);System.out.println(sub);System.out.println(mul);System.out.println(div);System.out.println(re);System.out.println(ab);\n\n结果：791 6 -9 262 2 3\n\nBigDecimal 使用 .scale() 表示小数位数\n具体计算方法与整型差不读，但浮点型进行除法的时候可能会存在除不尽的情况，这样就可以对其进行精度上的取余\n判断相等时可能小数位后面存在多个 0 这样虽然不影响大小但在操作的时候会导致大小不同，可以使用 compareTo() 方法\n Math 类\n可以求 sqrt(平方根)、abs(绝对值)、max、min、pow(幂)、取整 (ceil、floor、round) 具体查阅 API\n输出一个随机数用 random()方法\npublic static void main(String[] args) &#123;    double c = Math.random();    System.out.println(c);// 输出一个 0-1 之间的随机数（double 类型）    int b = 100;    int d = (int) (Math.random() * b + 1);// 输出一个 1-b 之间的随机数     System.out.println(d);    int a = 50;    int e = (int) (Math.random() * (b - a + 1) + a);// 输出一个 a-b 的随机数    System.out.println(e);&#125;//+ 1 是因为 random() 最大取不到 1, 所以上限取整后就会少 1\n 模板\n 公约公倍数\n求最大公约数可以采用辗转相除法，就是两数的最大公约数就是较小数和两数余数的最大公约数\n最小公倍数等于两数的乘积除最大公约数\nBigInteger 提供 .gcd(x, y) 方法自动判断\npublic class Test &#123;    static int gcd(int a,int b)&#123;        return b==0?a:gcd(b,a%b);// 辗转相除法，两数的最大公约数等于较小数与两数余数的最大公约数    &#125;    static int lcm(int a,int b)&#123;        return a*b/gcd(a,b);// 最小公倍数等于两数相乘除最大公约数    &#125;    public static void main(String[] args) &#123;        System.out.println(gcd(12,5));        System.out.println(lcm(12,5));        BigInteger y = BigInteger.valueOf(123);        BigInteger x = BigInteger.valueOf(12345);        System.out.println(x.gcd(y));    &#125;&#125;\n 判断闰年\npublic static void main(String[] args) &#123;    Scanner sc = new Scanner(System.in);    int n = sc.nextInt();    if (n % 400 == 0 || (n % 4 == 0 &amp;&amp; n % 100 != 0))        System.out.println(&quot;true&quot;);    else        System.out.println(&quot;false&quot;);&#125;\n 判断质数\n质数的判断一般有三种方式：定义方法、遍历因子、打表\n一二种的理念相同：遍历因子看能否取余，因子最大不会超过 X 的 sqrt\n打表的复杂度最低\n// 第一种：static boolean judge(int x) &#123;    boolean flag = true;    for (int i = 2; i &lt;= Math.sqrt(x); i++) &#123;        if (x % i == 0) &#123;            flag = false;            break;        &#125;    &#125;    return flag;&#125;// 第二种：while (count &lt; N) &#123;    boolean flag = true;    for (int j = 2; j * j &lt;= i; j++) &#123;        if (i % j == 0) &#123;            flag = false;            break;        &#125;    &#125;&#125;// 打表：判断 0~9999 中是否为素数boolean[] arrPrimer = new boolean[10000];Arrays.fill(arrPrimer, Boolean.TRUE);for (int i = 2; i * i &lt; 10000; i++) &#123;    for (int j = 2; j * j &lt; 10000; j++) &#123;        arrPrimer[i * j] = false;    &#125;&#125;\n 进制转换\n在 Integer 对象中，常用的进制转换\n\n\n\n十进制的转换对象\n对应的方法和参数\n返回值\n\n\n\n\n数字转换字符串\nInteger.toBinaryString(n);\n二进制字符串\n\n\n数字转换字符串\nInteger.toOctalString(n);\n八进制字符串\n\n\n数字转换字符串\nInteger.toHexString(n);\n十六进制字符串\n\n\n数字转换字符串\nInteger.toString(n, r);\nr 进制字符串\n\n\n字符串转换数字\nInteger.parseInt(str, r);\nr 进制整数\n\n\n\npublic static void main(String[] args) &#123;      int n=18;      System.out.println(Integer.toBinaryString(n));// 转换二进制      System.out.println(Integer.toOctalString(n));// 转换成八进制      System.out.println(Integer.toHexString(n));// 转换成十六进制      System.out.println(Integer.toString(n,2));      String s = &quot;10101&quot;;      System.out.println(Integer.parseInt(s,2));// 回转为十进制      // 判断十进制整数转换成二进制后“1”的个数      System.out.println(Integer.bitCount(21));  &#125;\n 全排列\nstatic int arr[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;static int ans = 0;static void dfs(int k) &#123;    if (k &gt;= 9) &#123;// 递归出口        ans++;    &#125;    for (int i = k; i &lt; 9; i++) &#123;        int t = arr[k];        arr[k] = arr[i];        arr[i] = t;// 将相邻的两位数互换        dfs(k + 1);// 互换下一个        t = arr[k];        arr[k] = arr[i];        arr[i] = t;// 回溯时更换回来，不影响下一次排列    &#125;&#125;public static void main(String[] args) &#123;    dfs(0);    System.out.println(ans);&#125;\n 走迷宫\nimport java.util. Scanner; public class MazeDfs &#123;    /**     * DFS 算法解决走迷宫问题     * 0: 表示通路     * 1: 表示死路     */    static String path = &quot;&quot;;    static String shortestPath = &quot;&quot;;    public static void main(String[] args) &#123;        // 初始化一个迷宫地图        // 0: 表示通路        // 1: 表示死路        Scanner sc = new Scanner(System.in);         int x = sc.nextInt();         int y = sc.nextInt();         int count = 0;         int[][] map = new int[x][y];         for (int i = 0; i &lt; x; i++)            for (int j = 0; j &lt; y; j++)                map[i][j] = sc.nextInt();         /*         * 从矩阵的左上角位置开始搜索         * */        dfs(0, 0, map);        if (shortestPath.length() != 0)            System.out.println(&quot; 最短路线为：&quot; + shortestPath);        else            System.out.println(&quot; 没有找到路线！&quot;);        char[] s = shortestPath.toCharArray();        for (char c : s) &#123;            if (c == &#x27;-&#x27;)                count++;        &#125;        System.out.println(count);    &#125;    public static void dfs(int x, int y, int[][] map) &#123;        /*         * 获得矩阵的大小         * */        int m = map.length;        int n = map[0].length;        // 设置结束条件        if (x &lt; 0 || y &lt; 0)            return;        // 如果坐标越界，或者 maze[x][y]==1 表示遇到障碍        if (x &gt; m - 1 || y &gt; n - 1)            return;        // 表示遇到障碍        if (map[x][y] == 1)            return; // 判断是否通路和越界        if (x == m - 1 &amp;&amp; y == n - 1) &#123; // 判断是否抵达出口            path = path + &quot;(&quot; + x + &quot;,&quot; + y + &quot;)&quot;;            if (shortestPath.length() == 0 || shortestPath.length() &gt; path.length())                shortestPath = path;            System.out.println(&quot; 找到路线:&quot; + path);            return;        &#125;        String temp = path;        path = path + &quot;(&quot; + x + &quot;,&quot; + y + &quot;)&quot; + &quot;-&quot;; // 记录路线        map[x][y] = 1; // 将走过的路标记        // 向四个方向搜索        dfs(x + 1, y, map);  // 向右搜索        dfs(x, y + 1, map);  // 向下搜索        dfs(x, y - 1, map);  // 向上搜索        dfs(x - 1, y, map);  // 向左搜索        // 将路线和标记恢复成上一次的状态        map[x][y] = 0;        // 清除        path = temp;    &#125;&#125;\n 背包\nimport java.util.Scanner;public class BackPack &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int N = sc.nextInt();        int V = sc.nextInt();        int[] v = new int[N];// 记录体积        int[] w = new int[N];// 记录价值        for (int i = 0; i &lt; N; i++) &#123;            v[i] = sc.nextInt();            w[i] = sc.nextInt();        &#125;        int[] dp = new int[V + 1];        for (int i = 1; i &lt;= N; i++) &#123;            // 从大到小遍历            for (int j = V; j &gt;= 0; j--) &#123;                if (j &gt;= v[i - 1]) &#123;                    dp[j] = Math.max(dp[j], dp[j - v[i - 1]] + w[i - 1]);                &#125;            &#125;        &#125;        for (int i = 1; i &lt; V + 1; i++) &#123;            System.out.println(dp[i]);        &#125;    &#125;&#125;\n","categories":["算法"],"tags":["Java"]},{"title":"Java 实现 LRU 缓存模型","url":"/data_structure-LRU_cache_model/","content":"\n\nLRC 缓存模型其实是很常见的，像 InnoDB 的缓存池，虚拟内存的调度算法，重点是数据结构的实现，值得单独记录一下，对理解也有很大的帮助 \n\nLeetCode 地址 \n 这道题其实更多的是考察数据结构和集合的使用，所以也放到了实现题这里 \n 思路：\nLRU 直译为最近最少未使用，要想实现首先要搞清它的特点 \n\n 新进来的缓存结点放在最近被使用位 \n 每被使用一次的结点放在最近被使用位 \n\n 根据这两个特点我们可以使用链表存储每一个缓存结点，新放入或者被使用的结点直接放在链表头，当需要淘汰最近最少未使用的结点时直接去掉尾结点就可以，为了存取方便这里使用双向链表 \n 接下来再分析题目需要我们实现的方法 \n\nYour LRUCache object will be instantiated and called as such:\nLRUCache obj = new LRUCache(capacity);\nint param_1 = obj.get(key);\nobj.put(key, value);\n\n 根据存取特点，我们需要使用 Map 存储对应关系；根据构造方法，我们在 put 时还应根据 capacity 的值动态决定是否移除尾结点 \n 代码：\nclass LRUCache &#123;    // 结点结构     class DLinkedNode &#123;        private int key;    // 此处的 key 方便在链表和 Map 同时移除         private int value;        DLinkedNode prev;        DLinkedNode next;        public DLinkedNode() &#123;        &#125;        public DLinkedNode(int _key, int _value) &#123;            key = _key;            value = _value;        &#125;    &#125;    Map&lt;Integer, DLinkedNode&gt; cache = new HashMap&lt;&gt;();    private int size;   // 当前存储大小     private int capacity;   // 指定容量     private DLinkedNode head, tail;    // 默认构造器     public LRUCache(int capacity) &#123;        this.size = 0;        this.capacity = capacity;        head = new DLinkedNode();        tail = new DLinkedNode();        head.next = tail;        tail.prev = head;    &#125;    public void put(int key, int value) &#123;        DLinkedNode node = cache.get(key);        // 先判断是否存在，存在更改值，不存在放入         if (node == null) &#123;            DLinkedNode newNode = new DLinkedNode(key, value);            cache.put(key, newNode);            // 放入后置于链表头             addHead(newNode);            ++size;            // 超过最大容量清除             if (size &gt; capacity) &#123;                DLinkedNode reTail = removeTail();                cache.remove(reTail.key);                --size;            &#125;        &#125; else &#123;            node.value = value;            moveToHead(node);        &#125;    &#125;    public int get(int key) &#123;        DLinkedNode node = cache.get(key);        if (node == null) &#123;            return -1;        &#125;        moveToHead(node);        return node.value;    &#125;    public void addHead(DLinkedNode node) &#123;        node.next = head.next;        head.next.prev = node;        head.next = node;        node.prev = head;    &#125;    public void removeNode(DLinkedNode node) &#123;        node.next.prev = node.prev;        node.prev.next = node.next;    &#125;    public void moveToHead(DLinkedNode node) &#123;        removeNode(node);        addHead(node);    &#125;    public DLinkedNode removeTail() &#123;        DLinkedNode result = tail.prev;        removeNode(result);        return result;    &#125;&#125;\n","categories":["手动实现"],"tags":["Java"]},{"title":"使用原生 tcp 进行数据传输","url":"/data_transfer-tcp/","content":"\n\n 用其做一些传输操作时替代原本 HTTP 的实现方式，可以用在命令行工具之类的操作上 \n\n 先看下大体架构：\n// Conn 是你需要实现的一种连接类型，它支持下面描述的若干接口；// 为了实现这些接口，你需要设计一个基于 TCP 的简单协议；type Conn struct &#123;&#125;// Send 传入一个 key 表示发送者将要传输的数据对应的标识；// 返回 writer 可供发送者分多次写入大量该 key 对应的数据；// 当发送者已将该 key 对应的所有数据写入后，调用 writer.Close 告知接收者：该 key 的数据已经完全写入；func (conn *Conn) Send(key string) (writer io.WriteCloser, err error) &#123;&#125;// Receive 返回一个 key 表示接收者将要接收到的数据对应的标识；// 返回的 reader 可供接收者多次读取该 key 对应的数据；// 当 reader 返回 io.EOF 错误时，表示接收者已经完整接收该 key 对应的数据；func (conn *Conn) Receive() (key string, reader io.Reader, err error) &#123;&#125;// Close 关闭你实现的连接对象及其底层的 TCP 连接 func (conn *Conn) Close() &#123;&#125;// NewConn 从一个 TCP 连接得到一个你实现的连接对象 func NewConn(conn net.Conn) *Conn &#123;&#125;\n 结构看作固定给出，以下就不做扩展了，在此基础上进行后续开发即可，其中各结构与函数的作用在注释中已做完整解释 \n\n 首先对于 Conn 进行定义，golang 的 net 包下有完备的 tcp 实现，复用即可，根据函数的发送接收，考虑进行读写锁的添加防止调用 tcp 实际写入时产生的数据错乱 \nSend 和 Receive 用来实现写入和接收，其通过接口进行参数返回，所以需要根据接口进行实际结构体的定义 \n 写入会使用 writer.Close 用来告知完成，所以在结构体的实现时需要有标识位进行记录 \n\n 实现的结构体如下：\ntype Conn struct &#123;\ttcp net.Conn\twMu sync.Mutex // 写操作锁 \trMu sync.Mutex // 读操作锁 &#125;// 根据 io.WriteCloser 接口实现 type sendWriter struct &#123;\tconn   *Conn\tclosed bool // 通过关闭标志告知数据传输结束 &#125;func (w *sendWriter) Write(p []byte) (int, error) &#123;\tif w.closed &#123;\t\treturn 0, io.ErrClosedPipe\t&#125;\t// 写入数据长度，用于后续获取 \tlengthHeader := make([]byte, 4)\tbinary.BigEndian.PutUint32(lengthHeader, uint32(len(p)))\tif _, err := w.conn.tcp.Write(lengthHeader); err != nil &#123;\t\treturn 0, err\t&#125;\tn, err := w.conn.tcp.Write(p)\tif err != nil &#123;\t\treturn n, err\t&#125;\t// fmt.Println(&quot;send data:&quot;, string(p[:n]))\treturn n, nil&#125;func (w *sendWriter) Close() error &#123;\tif w.closed &#123;\t\treturn nil\t&#125;\tw.closed = true\t// 写入长度为 0 的数据，读取判断结束 \tlengthHeader := make([]byte, 4)\tif _, err := w.conn.tcp.Write(lengthHeader); err != nil &#123;\t\treturn err\t&#125;\tw.conn.wMu.Unlock()\treturn nil&#125;// 根据 io.Reader 接口实现 type receiveReader struct &#123;\tconn      *Conn\tremaining []byte\tclosed    bool&#125;func (r *receiveReader) Read(p []byte) (int, error) &#123;\tif r.closed &#123;\t\treturn 0, io.EOF\t&#125;\tif len(r.remaining) &gt; 0 &#123;\t\tn := copy(p, r.remaining)\t\tr.remaining = r.remaining[n:]\t\treturn n, nil\t&#125;\t// 读取固定位数保留的数据长度，按长度读取数据 \tlengthHeader := make([]byte, 4)\tif _, err := io.ReadFull(r.conn.tcp, lengthHeader); err != nil &#123;\t\treturn 0, err\t&#125;\tdataLength := binary.BigEndian.Uint32(lengthHeader)\tif dataLength == 0 &#123;\t\tr.closed = true\t\tr.conn.rMu.Unlock()\t\treturn 0, io.EOF\t&#125;\tdata := make([]byte, dataLength)\tif _, err := io.ReadFull(r.conn.tcp, data); err != nil &#123;\t\treturn 0, err\t&#125;\tn := copy(p, data)\tif n &lt; len(data) &#123;\t\tr.remaining = data[n:]\t&#125;\t// fmt.Println(&quot;receive data:&quot;, string(data[:n]))\treturn n, nil&#125;\n 以上代码所有具体操作都是借助 Conn 结构体实现，而 Conn 又通过 net.conn 进行直接引用，顾没有理解障碍 \n 需要注意在接收时的 receiveReader.remaining 主要用来进行传输数据的保留，防止数据拆包导致的无法续读，当然也可以使用下标进行实现 \n 根据自定义结构实现的代码逻辑如下：\nfunc (conn *Conn) Send(key string) (writer io.WriteCloser, err error) &#123;\tconn.wMu.Lock()\tkeyBytes := []byte(key)\tlengthHeader := make([]byte, 4)\tbinary.BigEndian.PutUint32(lengthHeader, uint32(len(keyBytes)))\tif _, err := conn.tcp.Write(lengthHeader); err != nil &#123;\t\tconn.wMu.Unlock()\t\treturn nil, err\t&#125;\tif _, err := conn.tcp.Write(keyBytes); err != nil &#123;\t\tconn.wMu.Unlock()\t\treturn nil, err\t&#125;\t// fmt.Println(&quot;send key:&quot;, key)\twriter = &amp;sendWriter&#123;\t\tconn:   conn,\t\tclosed: false,\t&#125;\treturn writer, nil&#125;func (conn *Conn) Receive() (key string, reader io.Reader, err error) &#123;\tconn.rMu.Lock()\tkeyLengthHeader := make([]byte, 4)\tif _, err := io.ReadFull(conn.tcp, keyLengthHeader); err != nil &#123;\t\tconn.rMu.Unlock()\t\treturn &quot;&quot;, nil, err\t&#125;\tkeyLength := binary.BigEndian.Uint32(keyLengthHeader)\tkeyBytes := make([]byte, keyLength)\tif _, err := io.ReadFull(conn.tcp, keyBytes); err != nil &#123;\t\tconn.rMu.Unlock()\t\treturn &quot;&quot;, nil, err\t&#125;\tkey = string(keyBytes)\t// fmt.Println(&quot;receive key:&quot;, key)\treader = &amp;receiveReader&#123;\t\tconn: conn,\t&#125;\treturn key, reader, nil&#125;func (conn *Conn) Close() &#123;\tconn.tcp.Close()&#125;func NewConn(conn net.Conn) *Conn &#123;\treturn &amp;Conn&#123;\t\ttcp: conn,\t&#125;&#125;\n 以上可以看作最简单的基于 tcp 的应用层开发，后续可能在这个点子上做一些别的东西，比如客户端文件上传之类的东西，完整代码如下，因来源特殊性，此代码禁止外传 \npackage mainimport (\t&quot;crypto/rand&quot;\t&quot;crypto/sha256&quot;\t&quot;encoding/binary&quot;\t&quot;encoding/hex&quot;\t&quot;fmt&quot;\t&quot;hash&quot;\t&quot;io&quot;\t&quot;net&quot;\t&quot;sync&quot;)// Conn 是你需要实现的一种连接类型，它支持下面描述的若干接口；// 为了实现这些接口，你需要设计一个基于 TCP 的简单协议；type Conn struct &#123;\ttcp net.Conn\twMu sync.Mutex // 写操作锁 \trMu sync.Mutex // 读操作锁 &#125;// Send 传入一个 key 表示发送者将要传输的数据对应的标识；// 返回 writer 可供发送者分多次写入大量该 key 对应的数据；// 当发送者已将该 key 对应的所有数据写入后，调用 writer.Close 告知接收者：该 key 的数据已经完全写入；func (conn *Conn) Send(key string) (writer io.WriteCloser, err error) &#123;\tconn.wMu.Lock()\tkeyBytes := []byte(key)\tlengthHeader := make([]byte, 4)\tbinary.BigEndian.PutUint32(lengthHeader, uint32(len(keyBytes)))\tif _, err := conn.tcp.Write(lengthHeader); err != nil &#123;\t\tconn.wMu.Unlock()\t\treturn nil, err\t&#125;\tif _, err := conn.tcp.Write(keyBytes); err != nil &#123;\t\tconn.wMu.Unlock()\t\treturn nil, err\t&#125;\t// fmt.Println(&quot;send key:&quot;, key)\twriter = &amp;sendWriter&#123;\t\tconn:   conn,\t\tclosed: false,\t&#125;\treturn writer, nil&#125;// Receive 返回一个 key 表示接收者将要接收到的数据对应的标识；// 返回的 reader 可供接收者多次读取该 key 对应的数据；// 当 reader 返回 io.EOF 错误时，表示接收者已经完整接收该 key 对应的数据；func (conn *Conn) Receive() (key string, reader io.Reader, err error) &#123;\tconn.rMu.Lock()\tkeyLengthHeader := make([]byte, 4)\tif _, err := io.ReadFull(conn.tcp, keyLengthHeader); err != nil &#123;\t\tconn.rMu.Unlock()\t\treturn &quot;&quot;, nil, err\t&#125;\tkeyLength := binary.BigEndian.Uint32(keyLengthHeader)\tkeyBytes := make([]byte, keyLength)\tif _, err := io.ReadFull(conn.tcp, keyBytes); err != nil &#123;\t\tconn.rMu.Unlock()\t\treturn &quot;&quot;, nil, err\t&#125;\tkey = string(keyBytes)\t// fmt.Println(&quot;receive key:&quot;, key)\treader = &amp;receiveReader&#123;\t\tconn: conn,\t&#125;\treturn key, reader, nil&#125;// Close 关闭你实现的连接对象及其底层的 TCP 连接 func (conn *Conn) Close() &#123;\tconn.tcp.Close()&#125;// NewConn 从一个 TCP 连接得到一个你实现的连接对象 func NewConn(conn net.Conn) *Conn &#123;\treturn &amp;Conn&#123;\t\ttcp: conn,\t&#125;&#125;// 除了上面规定的接口，你还可以自行定义新的类型，变量和函数以满足实现需求 // ============= 以下为自定义实现 =============// 根据 io.WriteCloser 接口实现 type sendWriter struct &#123;\tconn   *Conn\tclosed bool // 通过关闭标志告知数据传输结束 &#125;func (w *sendWriter) Write(p []byte) (int, error) &#123;\tif w.closed &#123;\t\treturn 0, io.ErrClosedPipe\t&#125;\t// 写入数据长度，用于后续获取 \tlengthHeader := make([]byte, 4)\tbinary.BigEndian.PutUint32(lengthHeader, uint32(len(p)))\tif _, err := w.conn.tcp.Write(lengthHeader); err != nil &#123;\t\treturn 0, err\t&#125;\tn, err := w.conn.tcp.Write(p)\tif err != nil &#123;\t\treturn n, err\t&#125;\t// fmt.Println(&quot;send data:&quot;, string(p[:n]))\treturn n, nil&#125;func (w *sendWriter) Close() error &#123;\tif w.closed &#123;\t\treturn nil\t&#125;\tw.closed = true\t// 写入长度为 0 的数据，读取判断结束 \tlengthHeader := make([]byte, 4)\tif _, err := w.conn.tcp.Write(lengthHeader); err != nil &#123;\t\treturn err\t&#125;\tw.conn.wMu.Unlock()\treturn nil&#125;// 根据 io.Reader 接口实现 type receiveReader struct &#123;\tconn      *Conn\tremaining []byte\tclosed    bool&#125;func (r *receiveReader) Read(p []byte) (int, error) &#123;\tif r.closed &#123;\t\treturn 0, io.EOF\t&#125;\tif len(r.remaining) &gt; 0 &#123;\t\tn := copy(p, r.remaining)\t\tr.remaining = r.remaining[n:]\t\treturn n, nil\t&#125;\t// 读取固定位数保留的数据长度，按长度读取数据 \tlengthHeader := make([]byte, 4)\tif _, err := io.ReadFull(r.conn.tcp, lengthHeader); err != nil &#123;\t\treturn 0, err\t&#125;\tdataLength := binary.BigEndian.Uint32(lengthHeader)\tif dataLength == 0 &#123;\t\tr.closed = true\t\tr.conn.rMu.Unlock()\t\treturn 0, io.EOF\t&#125;\tdata := make([]byte, dataLength)\tif _, err := io.ReadFull(r.conn.tcp, data); err != nil &#123;\t\treturn 0, err\t&#125;\tn := copy(p, data)\tif n &lt; len(data) &#123;\t\tr.remaining = data[n:]\t&#125;\t// fmt.Println(&quot;receive data:&quot;, string(data[:n]))\treturn n, nil&#125;/////////////////////////////////////////////////////// 接下来的代码为测试代码，请勿修改 ///////////////////////////////////////////////////////// 连接到测试服务器，获得一个你实现的连接对象 func dial(serverAddr string) *Conn &#123;\tconn, err := net.Dial(&quot;tcp&quot;, serverAddr)\tif err != nil &#123;\t\tpanic(err)\t&#125;\treturn NewConn(conn)&#125;// 启动测试服务器 func startServer(handle func(*Conn)) net.Listener &#123;\tln, err := net.Listen(&quot;tcp&quot;, &quot;:0&quot;)\tif err != nil &#123;\t\tpanic(err)\t&#125;\tgo func() &#123;\t\tfor &#123;\t\t\tconn, err := ln.Accept()\t\t\tif err != nil &#123;\t\t\t\tfmt.Println(&quot;[WARNING] ln.Accept&quot;, err)\t\t\t\treturn\t\t\t&#125;\t\t\tgo handle(NewConn(conn))\t\t&#125;\t&#125;()\treturn ln&#125;// 简单断言 func assertEqual[T comparable](actual T, expected T) &#123;\tif actual != expected &#123;\t\tpanic(fmt.Sprintf(&quot;actual:%v expected:%v\\n&quot;, actual, expected))\t&#125;&#125;// 简单 case：单连接，双向传输少量数据 func testCase0() &#123;\tconst (\t\tkey  = &quot;Bible&quot;\t\tdata = `Then I heard the voice of the Lord saying, “Whom shall I send? And who will go for us?”And I said, “Here am I. Send me!”Isaiah 6:8`\t)\tln := startServer(func(conn *Conn) &#123;\t\t// 服务端等待客户端进行传输 \t\t_key, reader, err := conn.Receive()\t\tif err != nil &#123;\t\t\tpanic(err)\t\t&#125;\t\tassertEqual(_key, key)\t\tdataB, err := io.ReadAll(reader)\t\tif err != nil &#123;\t\t\tpanic(err)\t\t&#125;\t\tassertEqual(string(dataB), data)\t\t// 服务端向客户端进行传输 \t\twriter, err := conn.Send(key)\t\tif err != nil &#123;\t\t\tpanic(err)\t\t&#125;\t\tn, err := writer.Write([]byte(data))\t\tif err != nil &#123;\t\t\tpanic(err)\t\t&#125;\t\tif n != len(data) &#123;\t\t\tpanic(n)\t\t&#125;\t\tconn.Close()\t&#125;)\t//goland:noinspection GoUnhandledErrorResult\tdefer ln.Close()\tconn := dial(ln.Addr().String())\t// 客户端向服务端传输 \twriter, err := conn.Send(key)\tif err != nil &#123;\t\tpanic(err)\t&#125;\tn, err := writer.Write([]byte(data))\tif n != len(data) &#123;\t\tpanic(n)\t&#125;\terr = writer.Close()\tif err != nil &#123;\t\tpanic(err)\t&#125;\t// 客户端等待服务端传输 \t_key, reader, err := conn.Receive()\tif err != nil &#123;\t\tpanic(err)\t&#125;\tassertEqual(_key, key)\tdataB, err := io.ReadAll(reader)\tif err != nil &#123;\t\tpanic(err)\t&#125;\tassertEqual(string(dataB), data)\tconn.Close()&#125;// 生成一个随机 keyfunc newRandomKey() string &#123;\tbuf := make([]byte, 8)\t_, err := rand.Read(buf)\tif err != nil &#123;\t\tpanic(err)\t&#125;\treturn hex.EncodeToString(buf)&#125;// 读取随机数据，并返回随机数据的校验和：用于验证数据是否完整传输 func readRandomData(reader io.Reader, hash hash.Hash) (checksum string) &#123;\thash.Reset()\tvar buf = make([]byte, 23&lt;&lt;20) // 调用者读取时的 buf 大小不是固定的，你的实现中不可假定 buf 为固定值 \tfor &#123;\t\tn, err := reader.Read(buf)\t\tif err == io.EOF &#123;\t\t\tbreak\t\t&#125;\t\tif err != nil &#123;\t\t\tpanic(err)\t\t&#125;\t\t_, err = hash.Write(buf[:n])\t\tif err != nil &#123;\t\t\tpanic(err)\t\t&#125;\t&#125;\tchecksum = hex.EncodeToString(hash.Sum(nil))\treturn checksum&#125;// 写入随机数据，并返回随机数据的校验和：用于验证数据是否完整传输 func writeRandomData(writer io.Writer, hash hash.Hash) (checksum string) &#123;\thash.Reset()\tconst (\t\tdataSize = 500 &lt;&lt; 20 // 一个 key 对应 500MB 随机二进制数据，dataSize 也可以是其他值，你的实现中不可假定 dataSize 为固定值 \t\tbufSize  = 1 &lt;&lt; 20   // 调用者写入时的 buf 大小不是固定的，你的实现中不可假定 buf 为固定值 \t)\tvar (\t\tbuf  = make([]byte, bufSize)\t\tsize = 0\t)\tfor i := 0; i &lt; dataSize/bufSize; i++ &#123;\t\t_, err := rand.Read(buf)\t\tif err != nil &#123;\t\t\tpanic(err)\t\t&#125;\t\t_, err = hash.Write(buf)\t\tif err != nil &#123;\t\t\tpanic(err)\t\t&#125;\t\tn, err := writer.Write(buf)\t\tif err != nil &#123;\t\t\tpanic(err)\t\t&#125;\t\tsize += n\t&#125;\tif size != dataSize &#123;\t\tpanic(size)\t&#125;\tchecksum = hex.EncodeToString(hash.Sum(nil))\treturn checksum&#125;// 复杂 case：多连接，双向传输，大量数据，多个不同的 keyfunc testCase1() &#123;\tvar (\t\tmapKeyToChecksum = map[string]string&#123;&#125;\t\tlock             sync.Mutex\t)\tln := startServer(func(conn *Conn) &#123;\t\t// 服务端等待客户端进行传输 \t\tkey, reader, err := conn.Receive()\t\tif err != nil &#123;\t\t\tpanic(err)\t\t&#125;\t\tvar (\t\t\th         = sha256.New()\t\t\t_checksum = readRandomData(reader, h)\t\t)\t\tlock.Lock()\t\tchecksum, keyExist := mapKeyToChecksum[key]\t\tlock.Unlock()\t\tif !keyExist &#123;\t\t\tpanic(fmt.Sprintln(key, &quot;not exist&quot;))\t\t&#125;\t\tassertEqual(_checksum, checksum)\t\t// 服务端向客户端连续进行 2 次传输 \t\tfor _, key := range []string&#123;newRandomKey(), newRandomKey()&#125; &#123;\t\t\twriter, err := conn.Send(key)\t\t\tif err != nil &#123;\t\t\t\tpanic(err)\t\t\t&#125;\t\t\tchecksum := writeRandomData(writer, h)\t\t\tlock.Lock()\t\t\tmapKeyToChecksum[key] = checksum\t\t\tlock.Unlock()\t\t\terr = writer.Close() // 表明该 key 的所有数据已传输完毕 \t\t\tif err != nil &#123;\t\t\t\tpanic(err)\t\t\t&#125;\t\t&#125;\t\tconn.Close()\t&#125;)\t//goland:noinspection GoUnhandledErrorResult\tdefer ln.Close()\tconn := dial(ln.Addr().String())\t// 客户端向服务端传输 \tvar (\t\tkey = newRandomKey()\t\th   = sha256.New()\t)\twriter, err := conn.Send(key)\tif err != nil &#123;\t\tpanic(err)\t&#125;\tchecksum := writeRandomData(writer, h)\tlock.Lock()\tmapKeyToChecksum[key] = checksum\tlock.Unlock()\terr = writer.Close()\tif err != nil &#123;\t\tpanic(err)\t&#125;\t// 客户端等待服务端的多次传输 \tkeyCount := 0\tfor &#123;\t\tkey, reader, err := conn.Receive()\t\tif err == io.EOF &#123;\t\t\t// 服务端所有的数据均传输完毕，关闭连接 \t\t\tbreak\t\t&#125;\t\tif err != nil &#123;\t\t\tpanic(err)\t\t&#125;\t\t_checksum := readRandomData(reader, h)\t\tlock.Lock()\t\tchecksum, keyExist := mapKeyToChecksum[key]\t\tlock.Unlock()\t\tif !keyExist &#123;\t\t\tpanic(fmt.Sprintln(key, &quot;not exist&quot;))\t\t&#125;\t\tassertEqual(_checksum, checksum)\t\tkeyCount++\t&#125;\tassertEqual(keyCount, 2)\tconn.Close()&#125;func main() &#123;\ttestCase0()\ttestCase1()&#125;\n","categories":["手动实现"],"tags":["Go","TCP"]},{"title":"Java 原生实现 HTTP 服务","url":"/native_code-http_service/","content":"\n\n 不依赖任何第三方库或框架（只使用 jdk 里面包含的公开可用的类库），tomcat 属于第三方框架所以不要用，com.sun 下的也不要用，开发一个 http 服务 \n\n\n 做加法运算：计算参数 a 和参数 b 的算术和，在浏览器地址栏里输入 http://localhost:port/add?a=4&amp;b=7 ，浏览器窗口中显示 11\n做乘法运算：计算参数 a 和参数 b 的算术乘积，在浏览器地址栏里输入 http://localhost:port/mult?a=4&amp;b=7 ，浏览器窗口中显示 28\n\nJava 开发文档中已经提供完整的方式， 英文教程 \n 具体流程：\n\n 使用 ServerSocket 对客户端进行监听 \n 接收 http，解析数据 \n 提供服务并响应 \n\nimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;/** * Created by Aidan on 2021/8/31 21:24 * GitHub: github.com/huaxin0304 * Blog: aidanblog.top */public class HttpService &#123;    public static Integer result = 0;    public static void main(String[] args) &#123;        try &#123;            // 监听端口号，只要是 8888 就能接收到             ServerSocket ss = new ServerSocket(8888);            // 实例化客户端，固定套路，通过服务端接受的对象，生成相应的客户端实例             Socket socket = ss.accept();            // 获取客户端输入流，就是请求过来的基本信息：请求头，换行符，请求体             BufferedReader bd = new BufferedReader(new InputStreamReader(socket.getInputStream()));            /**             * 接受 HTTP 请求，并解析数据              */            String requestHeader;            if ((requestHeader = bd.readLine()) != null &amp;&amp; !requestHeader.isEmpty()) &#123;                System.out.println(requestHeader);                /**                 * 方法处理代码                  */                int start = requestHeader.indexOf(&quot;?&quot;) + 3;                int terminal = requestHeader.indexOf(&quot;&amp;&quot;);                String num1 = requestHeader.substring(start, terminal);                int space = requestHeader.indexOf(&quot;HTTP&quot;) - 1;                String num2 = requestHeader.substring(terminal + 3, space);                System.out.println(num1 + num2);                // 加法                 if (requestHeader.contains(&quot;add&quot;)) &#123;    // 重在实现没有做 URL 检查                     result = Integer.parseInt(num1) + Integer.parseInt(num2);                &#125;                // 乘法                 else if (requestHeader.contains(&quot;mult&quot;)) &#123;  // 重在实现没有做 URL 检查                     result = Integer.parseInt(num1) * Integer.parseInt(num2);                &#125;            &#125;            // 发送回执             PrintWriter pw = new PrintWriter(socket.getOutputStream());            pw.println(&quot;HTTP/1.1 200 OK&quot;);            pw.println(&quot;Content-type:text/html&quot;);            pw.println();            pw.println(&quot;&lt;h1&gt;&quot; + result + &quot;&lt;/h1&gt;&quot;);            pw.flush();            socket.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;","categories":["手动实现"],"tags":["Java"]},{"title":"Java 怎么重写 Hash 和 equals","url":"/native_code-overrid_and_equals/","content":"\n\nJava 的 euqals() 和 hashCode() 可以说是最常用的两个 Object 方法，那具体怎么重写这两个方法才能做到真正的实用和有效呢？\n 其实大致思路都是相同的，不过是判断地址和转型后判断属性，但转型和判断属性的方式还要考虑到子类继承的情况，下面是阅读《Java 修炼指南》后的总结写法 \n\n 首先贴一下代码：\nimport java.util.Objects;/** * Created by Aidan on 2021/11/8 20:05 * GitHub: github.com/huaxin0304 * Blog: aidanblog.top */public class Person &#123;        int id;    String name;    @Override    public boolean equals(Object obj) &#123;        // 1. 判断引用是否相等         if (this == obj) &#123;            return true;        &#125;        // 2. 判断传入的对象是否为空         if (obj == null) &#123;            return false;        &#125;        // 3. 判断类型是否相等，考虑到子类继承后重写的情况所以不使用 `instanceof`        // if (!(o instanceof Person)) return false;        if (this.getClass() != obj.getClass()) &#123;            return false;        &#125;        // 4. 进行类型转换         Person person = (Person) obj;        // 5. 进行属性的判断（应该使用 `getXXX()` 的方式，这里为了简便）        return this.id == person.id &amp;&amp; Objects.equals(this.name, person.name);    &#125;    @Override    public int hashCode() &#123;        return Objects.hashCode(this);        // return Objects.hash(this.id, this.name);    &#125;&#125;\n 其实大部分的使用都是相同的，只是在判断类型时有些不同，这里主要是考虑到类继承后重写父类（自定义）的 euqals() 方法，导致判断方式各异的情况，如下：\npublic class Person &#123;    int id;    String name;    ...&#125;public class Man extends Person &#123;&#125;public class Women extends Person &#123;    String favor;    @Override    public boolean equals(Object obj) &#123;        if (this == obj) &#123;            return true;        &#125;        if (this.getClass() != obj.getClass()) &#123;            return false;        &#125;        Women women = (Women) obj;        return this.id == women.id &amp;&amp; this.name.equals(women.name) &amp;&amp; this.favor.equals(women.favor);    &#125;&#125;","categories":["通用案例"],"tags":["Java"]},{"title":"Java 中遍历集合的最佳解决方案","url":"/native_code-traversal_collection/","content":"\n\n 进行集合的遍历无非就是 for(forEach), Iterator 两种方式，其实迭代器被设计出来就是为了方便集合的遍历，但为什么要这么使用，以及一些骚操作在这里做一个总结 \n\n ArrayList\n 直接看综合的测试代码 \nimport java.util.ArrayList;import java.util.Iterator;import java.util.List;/** * @author Aidan * @createTime 2021/11/16 16:20 * @GitHub github.com/huaxin0304 * @Blog aidanblog.top */public class TraversalList &#123;    private static final int MAX_SIZE = 10000;    public static void main(String[] args) &#123;        // 构建初始 ArrayList        List&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();        for (int i = 0; i &lt; MAX_SIZE; i++) &#123;            arrayList.add(i);        &#125;        // for 循环测试         long start = System.currentTimeMillis();        for (int i = 0; i &lt; MAX_SIZE; i++) &#123;            Integer integer = arrayList.get(i);            System.out.print(integer.toString() + &quot; &quot;);        &#125;        long resultFor = System.currentTimeMillis() - start;        // forEach 遍历测试         start = System.currentTimeMillis();        for (Integer integer : arrayList) &#123;            System.out.print(integer + &quot; &quot;);        &#125;        long resultForEach = System.currentTimeMillis() - start;        // Iterator 遍历测试         start = System.currentTimeMillis();        Iterator&lt;Integer&gt; iterator = arrayList.iterator();        while (iterator.hasNext()) &#123;            System.out.print(iterator.next() + &quot; &quot;);        &#125;        long resultIterator = System.currentTimeMillis() - start;        System.out.println(&quot;\\n\\n=============== Result ================\\n&quot;);        System.out.println(resultFor);        System.out.println(resultForEach);        System.out.println(resultIterator);    &#125;&#125;\n 测试结果几次都不同，但时间花费基本上大差不差，看起来用哪个无所谓，不过 forEach 也是基于 Iterator 来实现，相较于 for 和 Iterator 来说，其语法更加简洁，使用时不用考虑下标，所以如果只是单纯的进行遍历元素， 推荐使用 forEach，如果有遍历修改的需求一般会使用 for 循环来实现，但如果添加或是向前遍历可以使用 ListIterator 进行操作 \nListIterator&lt;Integer&gt; integerListIterator = arrayList.listIterator();while (integerListIterator.hasNext()) &#123;    // 为集合中的每个元素后添加一个 -1    integerListIterator.add(-1);    integerListIterator.next();&#125;// 此时迭代器游标处于最后 while (integerListIterator.hasPrevious()) &#123;    System.out.println(integerListIterator.previous());&#125;\n LinkedList\nprivate static final int MAX_SIZE = 10000;public static void main(String[] args) &#123;    List&lt;Integer&gt; linked = new LinkedList&lt;&gt;();    for (int i = 0; i &lt; MAX_SIZE; i++) &#123;        linked.add(i);    &#125;    long start = System.currentTimeMillis();    for (int i = 0; i &lt; linked.size(); i++) &#123;        System.out.print(linked.get(i));    &#125;    long resultFor = System.currentTimeMillis() - start;    start = System.currentTimeMillis();    for (Integer integer : linked) &#123;        System.out.println(integer);    &#125;    long resultForEach = System.currentTimeMillis() - start;    start = System.currentTimeMillis();    Iterator&lt;Integer&gt; iterator = linked.iterator();    while (iterator.hasNext()) &#123;        System.out.println(iterator.next());    &#125;    long resultIterator = System.currentTimeMillis() - start;    System.out.println(&quot;\\n\\n========== Result =========\\n&quot;);    System.out.println(resultFor);    System.out.println(resultForEach);    System.out.println(resultIterator);&#125;\n 这时花费的时间就优点意思了，for 使用的时间比其他两种方式加起来都多，至于 forEach 和 Iterator 大致相同 \n 原因就是 LinkedList 不支持随机存储，大量的 get() 不过是每次的遍历到指定的位置，也就是说数据规模越大，花费的时间越长 \n HashMap\n 遍历 HashMap 有三种方式，使用 keySet 或者 valueSet 进行遍历，适合只遍历一种类型的情况下进行使用，其次就是使用 entrySet 进行所有的遍历，还有就是使用 EntrySet 的 Iterator 进行遍历，还有不常使用的一种就是先使用 KeySet 获取所有的键，然后使用键去获取对应的 Value，实际使用性能太低，所以不做考虑， 推荐使用 entrySet 的方式进行遍历 \nimport java.util.HashMap;import java.util.Iterator;import java.util.Map;/** * @author Aidan * @createTime 2021/11/16 20:14 * @GitHub github.com/huaxin0304 * @Blog aidanblog.top */public class TraversalMap &#123;    public static void main(String[] args) &#123;        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(10);        for (int i = 0; i &lt; 10; i++) &#123;            map.put(String.valueOf(i), String.valueOf(Math.random()));        &#125;        // 使用 KeySet 或者 ValSet 进行遍历         for (String s : map.keySet()) &#123;            System.out.println(s);        &#125;        System.out.println(&quot;===========&quot;);        for (String value : map.values()) &#123;            System.out.println(value);        &#125;        // 使用 EntrySet 进行遍历         for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;            System.out.println(entry.getKey() + &quot;:entry:&quot; + entry.getValue());        &#125;        // 使用 Iterator 进行遍历         Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();        while (iterator.hasNext()) &#123;            System.out.println(iterator.next().getKey() + &quot;:iterator:&quot; + iterator.next().getValue());        &#125;    &#125;&#125;\n 总结 \n\nArrayList 为了简洁方便使用 forEach\nLinkedList 因为链式存储的原因使用迭代器进行访问 \nHshMap 使用 EntrySet 的方式进行遍历性能最佳同时适用于大多数情况 \n\n","categories":["通用案例"],"tags":["Java"]},{"title":"SQL 查询连续（递增）ID","url":"/sql-continuous_id/","content":"\n\n 查询一个表中连续出现的 ID 或者是查询连续递增的 ID 其实是很常见的场景，这里记录一下我使用的方法 \n\n 查询连续重复的 ID\nLeetCode 地址 \n 直接进行连接通过连续的 ID 值保证元组的平行，然后约束相等条件即可 \nselect distinct l1.Num as ConsecutiveNumsfrom Logs l1         left join Logs l2 on l1.id = l2.id + 1         left join Logs l3 on l1.id = l3.id + 2where l1.num = l2.num  and l1.num = l3.num;\n 查询连续递增的 ID\nLeetCode 地址 \n 先看结果要求：\n\n 找出每行的人数大于或等于 100 且 id 连续的三行或更多行记录 \n\n 人数大于 100 好说，重点是连续三行以上的 id 连续 \n 这是我的测试数据：\n\n\n\nid\nvisit_date\npeople\n\n\n\n\n1\n2021-09-01\n999\n\n\n2\n2021-09-02\n1000\n\n\n3\n2021-09-03\n1001\n\n\n4\n2021-09-04\n100\n\n\n5\n2021-09-05\n1003\n\n\n6\n2021-09-06\n1004\n\n\n7\n2021-09-07\n1005\n\n\n8\n2021-09-08\n1006\n\n\n\n 要找三行以上就将三个表进行一个左连接，当 S1.id + 1 = S2.id &amp;&amp; S1.id + 2 = S3.id 就表示连续三个以上了，但这时三个连续以上的数据并不是在一个表中，比如上表中符合条件的最后四行，只有 S1 中只有 5, 6 时 S2 才可以有 6, 7，S3 才可以有 7, 8，但这时的结果是这样的 \n\n\n\nS1.id\nS2.id\nS3.id\n\n\n\n\n5\n6\n7\n\n\n6\n7\n8\n\n\n\n 所以将查询出来看作一个子表，使用内连接的方式对数据进行筛选， S.id = SS.i or S.id = SS.ii or S.id = SS.iii 其中 SS 作为结果子表，i, ii, iii 分别是每个连接表的 id，这时在表 S 中符合条件的 id 就是 5, 6, 6, 7, 7, 8 ，使用 distinct 修饰一下即可，完整代码如下：\nselect distinct S.*     # 进行结果去重 from Stadium as S         inner join     # 将主表与连续 id 的结果进行内连接      (         select S1.id as i, S2.id as ii, S3.id as iii         from Stadium as S1                  left join Stadium as S2 on S1.id + 1 = S2.id                  left join Stadium as S3 on S1.id + 2 = S3.id         where S1.people &gt;= 1000        # 这里使用的测试数据为大于 1000 的            and S2.people &gt;= 1000           and S3.people &gt;= 1000     ) SSwhere (S.id = SS.i or S.id = SS.ii or S.id = SS.iii)order by S.id\n","categories":["通用案例"],"tags":["SQL"]},{"title":"删除多字段数据重复且只保留一条","url":"/sql-keep_one_piece/","content":"\n\n 这工作中遇到这样一种情况，需要删除某一列内容相同的数据，但需要保留一行，这一行可能根据某一列的值进行判断 \n\n 首先开始看表，目前的表结构和数据如下所示：\n+----+-------+-----+| id | name  | pwd |+----+-------+-----+| 1  | aidan | 123 || 2  | aidan | 124 || 3  | jack  | 125 || 4  | aidan | 125 || 5  | aidan | 125 || 6  | alisa | 125 |+----+-------+-----+\n 因为数据量不多，所以大家脑补一下，此时我们在有大量数据的情况下进行对 name , pwd 字段的去重是很麻烦的，而且在工作的实际情况中要复杂的多，这条代码是我的老师给我的，适应性很强，而且不同情况需要修改的代码量也不算多。\n# 删除重复数据只保留一条 DELETEfrom `user`where (name, pwd) in (    SELECT name, pwd    from (             select name, pwd             from `user`             group by name, pwd             having count(*) &gt; 1         ) t)  and id not in (    SELECT a.id    from (             select min(id) as id             from `user`             group by name, pwd             having count(*) &gt; 1         ) a);\n 执行此段代码之后， name , pwd 同时相等的数据被删除，也就是行号为 4, 5 的两行，但这里选择保留 id 最小的一行，也就是第 4 行，执行之后的结果为：\n+----+-------+-----+| id | name  | pwd |+----+-------+-----+| 1  | aidan | 123 || 2  | aidan | 124 || 3  | jack  | 125 || 4  | aidan | 125 || 6  | alisa | 125 |+----+-------+-----+\n 最后放上 SQL 模板，想抄作业的话改改占位内容就能用 \nDELETEfrom $tableName$where ($fields$) in (    SELECT $fields$    from (             select $fields$             from $tableName$             group by $fields$             having count(*) &gt; 1         ) t)  and id not in (    SELECT a.id    from (             select min(id) as id             from $tableName$             group by $fields$             having count(*) &gt; 1         ) a);\n","categories":["通用案例"],"tags":["SQL"]},{"title":"使用 Go 语言爬取豆瓣图书 Top250","url":"/web_crawler-douban_book_top/","content":"\n\n 今天做核酸的时候在掘金看到一篇讲学 Go 语言的帖子，好家伙写的跟小说是的，不过里边有一个使用 goquery 爬取网页的操作我很感兴趣，自己尝试了一下 \n 感悟就是 Go 确实很简单，但只要逻辑理明白了语言真的只是工具而已 \n\n 具体实现可以看掘金的  原文 ，写的特别好，我这里直接贴一下代码 \npackage mainimport (\t&quot;fmt&quot;\t&quot;log&quot;\t&quot;net/http&quot;\t&quot;os&quot;\t&quot;strconv&quot;\t&quot;strings&quot;\t&quot;github.com/PuerkitoBio/goquery&quot;)func main() &#123;\t// 创建我们要导出的 TXT 文件 \tfile, err := os.Create(&quot;Douban-Book-TOP250&quot;)\tif err != nil &#123;\t\tfmt.Println(err)\t&#125;\tdefer file.Close()\t// 创建一个客户端对象，用于发送请求 \tvar client = http.Client&#123;&#125;\tfor i := 0; i &lt; 250; i += 25 &#123;\t\t// 发送一条新请求 \t\treq, _ := http.NewRequest(&quot;GET&quot;, &quot;https://book.douban.com/top250?start=&quot;+strconv.Itoa(i), nil)\t\t// 设置 User-Agent（必须）\t\treq.Header.Set(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&quot;)\t\t// 发送请求 \t\tresp, err := client.Do(req)\t\t// 处理异常 \t\tif err != nil &#123;\t\t\tfmt.Println(&quot;http get error&quot;, err)\t\t\treturn\t\t&#125;\t\t// 关闭流 \t\tdefer resp.Body.Close()\t\t// 通过 goquery 将流中的内容构建成一棵 DOM 树 \t\tdoc, err := goquery.NewDocumentFromReader(resp.Body)\t\tif err != nil &#123;\t\t\tlog.Fatal(err)\t\t&#125;\t\t// 拿到所有标记的节点集合进行 each 循环，i = 序号，s = 节点本身 \t\tdoc.Find(&quot;div.indent&gt;table&gt;tbody&gt;tr.item&quot;).Each(func(i int, s *goquery.Selection) &#123;\t\t\t// 拿到节点集合中的 Items\t\t\titem := s.Find(&quot;td[valign=top]&quot;)\t\t\t// 通过 Item 节点获取到我们所需要的数据 \t\t\t// 对数据进行去空格 去换行操作 \t\t\tbookName := strings.Replace(strings.Replace(item.Find(&quot;div.pl2&gt;a&quot;).Text(), &quot;\\n&quot;, &quot;&quot;, -1), &quot; &quot;, &quot;&quot;, -1)\t\t\tauthor := strings.Split(s.Find(&quot;p.pl&quot;).Text(), &quot;/&quot;)[0]\t\t\tquote := strings.Replace(strings.Replace(s.Find(&quot;p.quote&quot;).Text(), &quot;\\n&quot;, &quot;&quot;, -1), &quot; &quot;, &quot;&quot;, -1)\t\t\t// 拿到处理好的数据后填充文件即可 \t\t\t//fmt.Print(&quot;TOP&quot; + fmt.Sprint(i) + &quot;-&quot; + bookName + &quot;-&quot; + author + &quot;-&quot; + quote)\t\t\t// 处理字符直接的空格长度，尽量对齐 \t\t\tbookName = bookName + strings.Repeat(&quot; &quot;, (120-len(bookName)))\t\t\tauthor = author + strings.Repeat(&quot; &quot;, (50-len(author)))\t\t\tcontent := &quot;TOP&quot; + strconv.Itoa(i) + &quot;\\t&quot; + bookName + author + quote + &quot;\\n&quot;\t\t\tfile.WriteString(content)\t\t&#125;)\t&#125;\tfmt.Print(&quot; 程序执行完毕，请查看结果。&quot;)&#125;\n 几个需要注意的点：\n\nUser-Agent 必须使用，可以在豆瓣中 F12 查看一下，这里使用的和我浏览器中的不一样，但也可以使用 \n 写入到文件时如果处理对齐，需要考虑空格的重复次数不要出现负数的情况 \n 编号受豆瓣分页的影响，如果按升序来需要单独处理 \n\n","categories":["手动实现"],"tags":["Go"]},{"title":"具有父子关系的结构处理","url":"/work-three_level-labels/","content":"\n\n 在工作过程中遇到一个实现三级标签的问题，是同事写的，单说实现其实算不上有难度，但这是我第一次见到算法的实际产出应用，因为公司的代码需要保密，所以将其实现场景做了改变，只保留核心逻辑 \n\n 问题 \n 有一个结构体数组，其中包含以下属性：\nid    当前标识 cotet 内容 parId 父标识 \n 根据其中连接关系对其进行排序输出，可能存在多组 \n 解决 \n\n 将标签数组转换为二维 map，其格式为 map[parId]map[id]*lable\n 将得到的 map 根据 parId 进行子内容的查询，对根据子内容的 id 作为 parId 递归查询，将所有的标签连接起来 \n 处理输出即可 \n\npackage workimport &quot;fmt&quot;type lable struct &#123;\tid       int\tname     string\tparentId int\tson      []*lable&#125;var lables = [...]*lable&#123;&#123;\tid:       1,\tname:     &quot; 爷爷 &quot;,\tparentId: 0,&#125;, &#123;\tid:       2,\tname:     &quot; 姥姥 &quot;,\tparentId: 0,&#125;, &#123;\tid:       3,\tname:     &quot; 父亲 &quot;,\tparentId: 1,&#125;, &#123;\tid:       4,\tname:     &quot; 母亲 &quot;,\tparentId: 2,&#125;, &#123;\tid:       5,\tname:     &quot; 大儿子 &quot;,\tparentId: 3,&#125;, &#123;\tid:       6,\tname:     &quot; 二儿子 &quot;,\tparentId: 4,&#125;&#125;func buildLabelData(list []*lable) map[int]map[int]*lable &#123;\tvar data = make(map[int]map[int]*lable)\tfor _, val := range list &#123;\t\tid := val.id\t\tparentId := val.parentId\t\tif _, ok := data[parentId]; !ok &#123;\t\t\tdata[parentId] = make(map[int]*lable)\t\t&#125;\t\tdata[parentId][id] = val\t&#125;\treturn data&#125;func makeTreeLabel(index int, data map[int]map[int]*lable) []*lable &#123;\ttmp := make([]*lable, 0)\tfor id, item := range data[index] &#123;\t\tif data[id] != nil &#123;\t\t\titem.son = makeTreeLabel(id, data)\t\t&#125; else &#123;\t\t\titem.son = []*lable&#123;&#125;\t\t&#125;\t\ttmp = append(tmp, item)\t&#125;\treturn tmp&#125;func lastOperate(labs []*lable) [][]string &#123;\tvar lastData [][]string\tfor _, f := range labs &#123;\t\tfor _, s := range f.son &#123;\t\t\tfor _, t := range s.son &#123;\t\t\t\ttmpData := []string&#123;\t\t\t\t\tf.name,\t\t\t\t\ts.name,\t\t\t\t\tt.name,\t\t\t\t&#125;\t\t\t\tlastData = append(lastData, tmpData)\t\t\t&#125;\t\t&#125;\t&#125;\treturn lastData&#125;func Entrance() &#123;\tdata := buildLabelData(lables[:])\tlabs := makeTreeLabel(0, data)\tlastData := lastOperate(labs)\tfor _, slices := range lastData &#123;\t\tfor _, dada := range slices &#123;\t\t\tfmt.Printf(&quot;%s\\t&quot;, dada)\t\t&#125;\t\tfmt.Println()\t&#125;&#125;\n\nresult\n爷爷    父亲    大儿子 \n姥姥    母亲    二儿子 \n\n","categories":["手动实现"],"tags":["Go"]},{"title":"博客搭建","url":"/blog-setup/","content":"之前一直在 CSDN 写点东西，今天心血来潮尝试了 GitHub Pages + Hexo 的方式，真香，跟着教程手把手来的，但还有一些没提到的小坑，这里做一个汇总\n\n自己跟的两个教程是：\n\n知乎 -crystal\nB 站 -hojun_cn\n⭐官方文档⭐\n\n上面个两个教程比较精简直接不过年岁有点久了，在实际操作中我遇到的坑主要是\n\n安装时注意目录的选择，尤其是像我这种习惯只用一个盘的用户，看到安装就惯性选择 Program Files，结果在后面更改部署时控制台一直提示权限不够，不怕麻烦可以每次选择 以管理员身份打开  终端，其实没有必要，只要环境配置正确，博客文件的根目录放哪都行\n本地资源主要以图片为主，但大量的图片也会导致每次的部署缓慢，这里推荐一个图床 PicX\n部署时实用的 SSH 默认为 22 的端口号，偶尔会遇到占用的情况，这时候可以在其目录：C:\\Users\\userName\\.ssh创建一个 config 文件（没有后缀），在其中写入\n\nHost github.comUser # GitHub 的邮箱Hostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort # 更改端口\n\n\n不翻墙的情况下，即便 SSH 端口号没有占用，也会出现部署连接失败的情况，这时候就需要开启全局代理\n\n\n“网络和 Internet 设置” =&gt; 代理，复制“脚本地址”到浏览器\n\n\n会自动下载一个 pac 文件，找到其中的 PROXY\n\n\n执行 git config --global https.proxy #PROXY_value\n\n\n\n\n下载主题模板时如果自定义需求较少，可以使用 npm 或 git clone 的方式下载，然后拷贝配置文件，如果修改项比较多，可以下载 release 版压缩文件手动添加\n\n\n第一次更新：文件托管外链\n\n使用过程中发现自己有文件下载的需求，放到目录部署的操作性太差，容量大了部署也吃不消，考虑到和图床使用的类似操作，我这边选择的是 七牛云，刚跟客服挂掉电话，也不用什么教程，操作界面很清晰，上传文件之后获取外链使用即可，如果没有自己的域名可以买一个（需要备案，阿里云最便宜有首年几块钱的），也可以使用 files.userName.github.io 使用海外域名，但后续使用可能不太方便，譬如出现限制访问的情况\n第二次更新：排版和渲染\n\n中英文之间的添加空格，以提升阅读体验，其实我本身是有文档书写时手动添加空格的习惯，也尝试过一些本地使用的排版插件，如：pangu，但这些插件往往也会对语法符号（如：#、*）进行空格插入，造成排版与预期不符，但目前使用的 hexo-filter-auto-spacing 插件，或者说这一系列插件都不会产生这样的问题，因为是将已渲染完成的 html 页面进行中英文空格插入\n\n有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白 [1]\n\n使用 Hexo 默认的渲染器 hexo-renderer-marked 是不支持注脚或者其他 Markdown 的非核心功能，当然这可以使用渲染插件来解决，但是  没有必要，我这边直接换了底层渲染器，目前功能最强大的是：@upupming/hexo-renderer-markdown-it-plus 跟着教程操作就好了\nhexo-renderer-markdown-it-plus 是默认支持 Katex 数学公式的，但还需要在每篇文章前放入渲染引用，所以直接将其写入到 /scaffolds/post.md 的模板当中，这样每次创建时就无需手动添加\n---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:sticky:---&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css&quot;&gt;&lt;script defer src=&quot;https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 摘要 --&gt;&lt;!--more--&gt;&lt;!-- 正文 --&gt;\n第三次更新：GitHub Actions 自动部署\n\n\n\n可以直接在线编辑 md 文件，立即生效。假设你已发布一篇文章，过几天你在别的电脑上浏览发现有几个明显的错别字，这是完全不能容忍的。但此时你电脑上又没有 hexo + node.js + git 等完整的开发环境，重新配置开发环境明显不现实。如果使用 CI，你可以直接用浏览器访问 GitHub 上的项目仓库，直接编辑带错别字的 md 文章，改完，在线提交，稍等片刻，你的网站就自动更新了\n如果手动部署，需要先执行 hexo g 编译生成静态文件， 然后推送 public 整个文件夹到 GitHub 上，当后期网站文章、图片较多时候，很多时候连接 GitHub 不是那么顺畅，经常要傻等很长的上传时间。使用 GitHub Actions 自动部署，你只需 push _post 文件里单独的 md 文件即可，其他不用管，效率瞬间高了许多，其中的好处，谁用谁知道\n使用 GitHub Actions，你还可以一次性将这些静态博客页面部署到多个服务器上，例如：GitHub Pages、Gitee pages、七牛云、阿里云、腾讯云等等\n\n\n用了之后发现确实不是大话，好用归好用，但是配置属实有些麻烦，而且还不懂 Workflow 语法，自动部署教程\n注意自动部署的时候，根目录下的 .deploy_git 最好删掉\n第四次更新：http 图床与 https 协议不能混合\n\nGitHub Pages 中是支持 https 协议的，也有自动续费的安全证书，但是大部分图床外链都是采用 http 协议，导致不能显示，这里提供三个解决方案：\n\n将协议指向去掉，链接直接使用 // 开头，让其自己尝试协议（我用这种方式没成功）\n关闭 GitHub Pages 中的协议支持，并删除 DNS 中的相应记录\n升级图床链接（大部分图床都是 https，不是的也大都支持更改）\n\n第五次更新：URL 规范\n\n在 _config.yml 中可以配置文件的链接形式，一般是日期加文件名的形式，但是也可以使用 -s 指定 URL，但是最实用的方式，还是将 URL 格式修改为文件名。至于创建的规范大致如下：\n\n(M) url 的单词使用全小写，避免驼峰的方式\n(S) 如果有多个单词使用 _ 进行连接（但是我使用的是 -）\n(M) url 必须有其含义，避免使用序号和随机数字，使用数字的使用尽量替换为英文序数而不是基数\n\n\n\n\n盘古之白的说法和这句话来源于 GitHub 中一个自动添加空格的小工具。其真实性不详 ↩︎\n\n\n\n","categories":["实用操作"],"tags":["Hexo"]},{"title":"mysql 导出 csv 文件（非常规）","url":"/mysql-export-csv/","content":"\n\n 公司最近在搞安全，把数据库的导出都给限制了，所以这里使用外部查询 + sed 的方式，理论上只要能连接上数据库都能导出 \n\n 直接上命令，一看就懂：\nmysql -h xxx.xxx.xxx.xxx -u[user] -p[pwd] --default-character-set=utf8 -e &quot;SET NAMES utf8;/* 实际查询语句 */| sed -e  &quot;s/\\t/,/g&quot; -e &quot;s/NULL/  /g&quot; -e &quot;s/\\n/\\r\\n/g&quot; &gt; /[path]/fileName.csv","categories":["实用操作"],"tags":["SQL"]},{"title":"WSL2 的备份与清理","url":"/wsl2-backup_and_clean/","content":"\n\n 毕竟 WSL2 只是一个子系统，所以可以大胆折腾，搞坏了重置 Ubuntu 即可，但是每次弄坏了可能还要去重新配置环境，MySQL, Redis, Docker 啥乱七八糟的装一遍也很麻烦，后来发现可以使用导入导出的方式做一个快照和回滚 \n 其次我这种强迫症人选对磁盘清理真是谜之依赖，所以又找到了对 WSL 虚拟磁盘的压缩方式 \n\n WSL 的快照和回滚 \n\n 其实就是把阿里云的备份方式做一个套用，结果完全能用 \n\n 这里首先要去关闭当前运行的子系统 \nPS C:\\&gt;wsl --shutdownPS C:\\&gt; wsl -l -v  NAME            STATE           VERSION* Ubuntu-20.04    Stopped         2\n 然后直接执行导出命令即可 \nwsl --export Ubuntu-20.04 c:\\wsl-ubuntu20-04.tar\n 之后系统数据会打包成一个 .tar 文件，然后放到 U 盘云端都可以 \n 如果需要回滚首先进行系统的注销，然后将 .tar 包进行导入 \n# 注销当前系统 wsl --unregister Ubuntu-20.04# 进行数据的导入 wsl --import Ubuntu-20.04 c:\\wsl c:\\wsl-ubuntu20-04.tar --version 2# 重新设置默认用户名 ubuntu2004 config --default-user userName\n WSL2 宿主机磁盘清理 \nWSL2 使用虚拟磁盘，如果往 WSL2 中放了大量的数据，然后就删掉，会发现 WSL2 的磁盘占用并没有降下来，这时强迫症如我就需要手动去压缩磁盘 \n 第一步还是关闭运行状态的子系统，然后使用 diskpart 命令打开磁盘工具窗口，然后找到自己 WSL 版本对应的磁盘位置，例如我的 Ubuntu-20.04 是 C:\\Users\\aidan\\AppData\\Local\\Packages\\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc\\LocalState\\ext4.vhdx\n 执行磁盘选择命令后压缩 \n# 选择磁盘 select vdisk file=&quot;&#123;vhdx 文件名 &#125;&quot;# 压缩磁盘 compact vdisk\n 如果执行压缩命令时报错不要慌，因为当前磁盘是一个只读的状态，只需要执行 detach vdisk 命令即可，然后压缩，完成后不要忘了把权限换回来： attach vdisk readonly\n Debian 存储清理 \n 旧内核清理 \nsudo apt purge $(dpkg -l &#x27;linux-*&#x27; | awk &#x27;/^ii/&#123;print $2&#125;&#x27; | grep -P &#x27;^(?!linux-(?:generic|raspi|aws)).*&#x27;)\n 旧软件清理 \n\n 清理旧版本的软件缓存：sudo apt-get autoclean\n 清理所有软件缓存：sudo apt-get clean\n 清理系统中不再使用的孤立文件：sudo apt-get autoremove\n可以使用 sudo du -sh /var/cache/apt 命令查看缓存大小 \n 清理软件的残余配置：sudo apt-get autoremove -purge\n 卸载软件：sudo apt --purge remove xxx\n\nsudo apt autoclean &amp;&amp; sudo apt clean &amp;&amp; sudo apt autoremove &amp;&amp; sudo apt remove &amp;&amp; sudo apt autoremove --purge\n 删除残余配置文件 \nremove 但没有 purge 的软件会残留一部分配置文件，这里做一个清除操作 \n\n 找出系统上哪些软件包留下了残余的配置文件：dpkg --list | grep &quot;^rc&quot;\n 提取软件名：dpkg --list | grep &quot;^rc&quot; | cut -d &quot; &quot; -f 3\n 删除软件包：dpkg --list | grep &quot;^rc&quot; | cut -d &quot; &quot; -f 3 | xargs sudo dpkg --purge\n\n 清除无用依赖包 \n\n 安装查看工具 deborphan，执行软件名列出所有无用依赖：sudo apt install deborphan\n 删除软件：deborphan | xargs sudo apt purge -y\n\n 清楚过时软件 \n 所谓过时（obsolete）的软件包是指 /etc/apt/sources.list 源文件中没有任何一个软件源提供这个软件的 deb 安装包 \n也就是说这个软件包在软件源里找不到了，不被支持了．这可能是因为下面几个原因：\n\n 上游开发者不维护这个软件，又没有人来接管这个软件的开发．所以 Debian/Ubuntu 的软件包维护人员决定将这个软件从软件源中删除 \n 这个软件成了孤儿，同时用户很少．所以它就从软件源里消失了 \n 这个软件有了一个新的名字，维护人员给它起了一个新的名字并保留旧软件包 \n\n\n 查找所有过时软件：sudo aptitude search ?obsolete\n 可以手动删除，也可以清除所有：sudo aptitude purge ~o\n\n 清理日志文件 \nncdu 工具可以查看文件大小 \n\n 安装后执行：sudo ncdu /var/log\n 删除可以使用：sudo dd if=/dev/null of=/var/log/xxx.log\n\n 查看大软件 \ndebian-goodies 工具可以查看软件大小，可以执行 dpigs -H 查看大容量软件，默认展示前十条结果，可以指定展示行数 dpigs -H --lines=20\n1.1GiB elasticsearch315MiB golang-1.18-go228MiB openjdk-17-jdk-headless183MiB openjdk-17-jre-headless140MiB docker.io105MiB libllvm14102MiB golang-1.18-src96MiB containerd67MiB gcc-1252MiB guile-3.0-libs.............\n\n\n 参考文章：\nhttps://www.linuxdashen.com/debianubuntu 清理硬盘空间的 8 个技巧 \n\n","categories":["实用操作"],"tags":["Linux"]},{"title":"在 vscode 中搭建 C/C++ 开发环境","url":"/wsl2-build_c_dev/","content":"\n\n 之前写 C/C++ 一直在 CLion 上，但现在工作了，主要写的语言就只有 Golang 了，但其实工作中还要看一些 PHP，帮同事改改跑跑 Python 脚本啥的，所以现在统一开始使用 vscode 进行开发了，有时候心血来潮也用用 Neovim\n 这里分享一下 C/C++ 的运行配置，系统用的是 wsl2-Debian\n\n 软件安装 \n 首先是安装必备的软件 \nsudo apt install gdb gcc build-essential// 可选 sudo apt install glibc-source\n tasks.json\n 接下来就是创建一个项目目录，执行 Ctrl+Shift+P 输入 Configure Default Build Task\n&#123;\t&quot;version&quot;: &quot;2.0.0&quot;,\t&quot;tasks&quot;: [\t\t&#123;\t\t\t&quot;type&quot;: &quot;cppbuild&quot;,\t\t\t&quot;label&quot;: &quot;C/C++: g++ build active file&quot;,\t\t\t&quot;command&quot;: &quot;/usr/bin/g++&quot;,\t\t\t&quot;args&quot;: [\t\t\t\t&quot;-fdiagnostics-color=always&quot;,\t\t\t\t&quot;-g&quot;,\t\t\t\t&quot;$&#123;file&#125;&quot;,\t\t\t\t&quot;-I&quot;,\t\t\t\t&quot;$&#123;workspaceFolder&#125;/include&quot;,\t\t\t\t&quot;$&#123;workspaceFolder&#125;/execute/**&quot;,\t\t\t\t&quot;-o&quot;,\t\t\t\t&quot;$&#123;workspaceFolder&#125;/build/$&#123;fileBasenameNoExtension&#125;&quot;\t\t\t],\t\t\t&quot;options&quot;: &#123;\t\t\t\t&quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;\t\t\t&#125;,\t\t\t&quot;problemMatcher&quot;: [\t\t\t\t&quot;$gcc&quot;\t\t\t],\t\t\t&quot;group&quot;: &#123;\t\t\t\t&quot;kind&quot;: &quot;build&quot;,\t\t\t\t&quot;isDefault&quot;: true\t\t\t&#125;,\t\t\t&quot;detail&quot;: &quot;compiler: /usr/bin/g++&quot;\t\t&#125;\t]&#125;\n 需要重点看的配置项有 command , args , isDefault\nargs 的多个项中有如下含义：\n\n-g 用来指定编译的文件 \n$file 当前文件，同时编译多个只能指定类型，如：$&#123;workspaceFolder&#125;/*.cpp\n-o 指定生成的可执行文件的地址 \n\n launch.json\n 第二步是添加运行配置： Run-&gt;Add Configuration 生成 launch.json\n&#123;\t&quot;version&quot;: &quot;0.2.0&quot;,\t&quot;configurations&quot;: [\t\t&#123;\t\t\t&quot;name&quot;: &quot;gdb&quot;,\t\t\t&quot;type&quot;: &quot;cppdbg&quot;,\t\t\t&quot;request&quot;: &quot;launch&quot;,\t\t\t&quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/$&#123;fileBasenameNoExtension&#125;&quot;,\t\t\t&quot;args&quot;: [],\t\t\t&quot;stopAtEntry&quot;: false,\t\t\t&quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,\t\t\t&quot;environment&quot;: [],\t\t\t&quot;externalConsole&quot;: false,\t\t\t&quot;MIMode&quot;: &quot;gdb&quot;,\t\t\t&quot;setupCommands&quot;: [\t\t\t\t&#123;\t\t\t\t\t&quot;description&quot;: &quot; 为 gdb 启用整齐打印 &quot;,\t\t\t\t\t&quot;text&quot;: &quot;-enable-pretty-printing&quot;,\t\t\t\t\t&quot;ignoreFailures&quot;: true\t\t\t\t&#125;,\t\t\t\t&#123;\t\t\t\t\t&quot;description&quot;: &quot; 将反汇编风格设置为 Intel&quot;,\t\t\t\t\t&quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;,\t\t\t\t\t&quot;ignoreFailures&quot;: true\t\t\t\t&#125;\t\t\t],\t\t\t&quot;preLaunchTask&quot;: &quot;C/C++: g++ build active file&quot;,\t\t\t&quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;,\t\t\t&quot;sourceFileMap&quot;: &#123;\t\t\t\t&quot;/build/glibc-eX1tMB&quot;: &quot;/usr/src/glibc&quot;\t\t\t&#125;\t\t&#125;\t]&#125;\n 这里的 stopAtEntry 必须设置为 true 才能打断点， sourceFileMap 如果有报错可以进行安装设置（最开始的可选安装）\n 声明路径 \n 调试会需要获取获取相关路径，因为设置过 glibc 的原因可以不进行声明，但是要忍受红红的报错，也可以关掉报错，但是最好不要掩耳盗铃 \n 获取相关路径的方式也很简单，只需要执行 g++ -v -E -x c++ - 然后添加到配置即可 \n&#123;\t&quot;configurations&quot;: [\t\t&#123;\t\t\t&quot;name&quot;: &quot;Linux&quot;,\t\t\t&quot;includePath&quot;: [\t\t\t\t&quot;$&#123;workspaceFolder&#125;/**&quot;,\t\t\t\t&quot;$&#123;workspaceFolder&#125;/include/**&quot;,\t\t\t\t&quot;/usr/include/**&quot;,\t\t\t\t&quot;/usr/local/include/**&quot;,\t\t\t\t&quot;/usr/include/c++/12/**&quot;,\t\t\t\t&quot;/usr/include/c++/12/backward/**&quot;,\t\t\t\t&quot;/usr/include/x86_64-linux-gnu/**&quot;,\t\t\t\t&quot;/usr/include/x86_64-linux-gnu/c++/12/**&quot;,\t\t\t\t&quot;/usr/lib/gcc/x86_64-linux-gnu/12/include/**&quot;\t\t\t],\t\t\t&quot;defines&quot;: [],\t\t\t&quot;compilerPath&quot;: &quot;/usr/bin/gcc&quot;,\t\t\t&quot;cStandard&quot;: &quot;gnu17&quot;,\t\t\t&quot;cppStandard&quot;: &quot;gnu++14&quot;,\t\t\t&quot;intelliSenseMode&quot;: &quot;linux-gcc-x64&quot;,\t\t\t&quot;browse&quot;: &#123;\t\t\t\t&quot;limitSymbolsToIncludedHeaders&quot;: true\t\t\t&#125;\t\t&#125;\t],\t&quot;version&quot;: 4&#125;\nEND\n","categories":["开发工具"],"tags":["C/C++"]}]